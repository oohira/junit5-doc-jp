[[writing-tests]]
== テストを書く

[source,java,indent=0]
.最初のテストケース
----
include::{testDir}/example/FirstJUnit5Tests.java[tags=user_guide]
----

[[writing-tests-annotations]]
=== アノテーション

JUnit Jupiterは、テストを構成し、フレームワークを拡張するために、次のアノテーションをサポートします。

中心となるすべてのアノテーションは、 `junit-jupiter-api` モジュールの `{api-package}` パッケージに含まれます。

[cols="20,80"]
|===
| アノテーション         | 説明

| `@Test`              | このメソッドが、テストメソッドであることを示します。JUnit 4の `@Test` アノテーションとは異なり、このアノテーションはどんな属性も宣言しません。というのも、JUnit Jupiterのテスト拡張は、それ専用のアノテーションベースで行われるからです。このメソッドは、_オーバーライド_ されない限り、_継承_ されます。
| `@ParameterizedTest` | このメソッドが、<<writing-tests-parameterized-tests, パラメーター化テスト>> であることを示します。このメソッドは、_オーバーライド_ されない限り、_継承_ されます。
| `@RepeatedTest`      | このメソッドが、<<writing-tests-repeated-tests, 繰り返しテスト>> のためのテストテンプレートであることを示します。このメソッドは、_オーバーライド_ されない限り、_継承_ されます。
| `@TestFactory`       | このメソッドが、<<writing-tests-dynamic-tests, 動的テスト>> のためのテストファクトリであることを示します。このメソッドは、_オーバーライド_ されない限り、_継承_ されます。
| `@TestInstance`      | アノテーションを付与したテストクラスに対して、<<writing-tests-test-instance-lifecycle, テストインスタンスのライフサイクル>> を設定するために使われます。このアノテーションは、_継承_ されます。
| `@TestTemplate`      | このメソッドが、<<writing-tests-test-templates, テストケースのテンプレート>> であることを示します。このメソッドは、登録した <<extensions-test-templates, プロバイダ>> が返す実行コンテキストの数に応じて、複数回呼び出されます。このメソッドは、_オーバーライド_ されない限り、_継承_ されます。
| `@DisplayName`       | テストクラスやテストメソッドにカスタムの表示名を指定します。このアノテーションは、_継承_ されません。
| `@BeforeEach`        | このメソッドが、現在のクラスの `@Test`, `@RepeatedTest`, `@ParameterizedTest`, `@TestFactory` メソッドの _前に毎回_ 実行されるよう指定します。JUnit 4の `@Before` と同じです。このメソッドは、_オーバーライド_ されない限り、_継承_ されます。
| `@AfterEach`         | このメソッドが、現在のクラスの `@Test`, `@RepeatedTest`, `@ParameterizedTest`, `@TestFactory` メソッドの _後に毎回_ 実行されるよう指定します。JUnit 4の `@After` と同じです。このメソッドは、_オーバーライド_ されない限り、_継承_ されます。
| `@BeforeAll`         | このメソッドが、現在のクラスの *すべての* `@Test`, `@RepeatedTest`, `@ParameterizedTest`, `@TestFactory` メソッドの _前に一度だけ_ 実行されるよう指定します。JUnit 4の `@BeforeClass` と同じです。 このメソッドは、（_隠す_ か _オーバーライドする_ かしない限り）_継承_ されますが、（<<writing-tests-test-instance-lifecycle, テストインスタンスのライフサイクル>> に "per-class" が使われない限り）`static` でなければいけません。
| `@AfterAll`          | このメソッドが、現在のクラスの *すべての* `@Test`, `@RepeatedTest`, `@ParameterizedTest`, `@TestFactory` メソッドの _後に一度だけ_ 実行されるよう指定します。JUnit 4の `@AfterClass` と同じです。このメソッドは、（_隠す_ か _オーバーライドする_ かしない限り）_継承_ されますが、（<<writing-tests-test-instance-lifecycle, テストインスタンスのライフサイクル>> に "per-class" が使われない限り）`static` でなければいけません。
| `@Nested`            | このクラスが、ネストした非staticのテストクラスであることを示します。 `@BeforeAll` および `@AfterAll` メソッドは、<<writing-tests-test-instance-lifecycle, テストインスタンスのライフサイクル>> に "per-class" が使われない限り、`@Nested` テストクラスの中で直接使うことはできません。このアノテーションは、_継承_ されません。
| `@Tag`               | クラスまたはメソッドレベルでテストをフィルタリングするための _タグ_ を宣言するのに使われます。TestNGのテストグループやJUnit 4のCategoryと同じです。このアノテーションは、クラスレベルでは _継承_ されますが、メソッドレベルでは _継承_ されません。
| `@Disabled`          | テストクラスやテストメソッドを _無効化_ するのに使われます。JUnit 4の `@Ignore` と同じです。このアノテーションは、_継承_ されません。
| `@ExtendWith`        | カスタムの <<extensions, 拡張機能>> を登録するために使われます。このアノテーションは、_継承_ されます。
|===

`@Test`, `@TestTemplate`, `@RepeatedTest`, `@BeforeAll`, `@AfterAll`, `@BeforeEach`, `@AfterEach`
アノテーションの付与されたメソッドは、戻り値を返してはいけません。

WARNING: いくつかのアノテーションは現在 _実験中_ です。詳細は、
<<api-evolution-experimental-apis>> のテーブルを参照してください。

[[writing-tests-meta-annotations]]
==== メタアノテーションと合成アノテーション

JUnit Jupiterアノテーションは、_メタアノテーション_ として使うことができます。つまり、
メタアノテーションの意味を自動的に _継承_ した独自の _合成アノテーション_ を作れるということです。

例えば、`@Tag("fast")` をコードベース全体にコピー＆ペーストする代わりに
（<<writing-tests-tagging-and-filtering>> 参照）、以下の `@Fast`
のような名前のカスタム _合成アノテーション_ を作ることができます。
`@Fast` は、`@Tag("fast")` の代わりに使うことができます。

[source,java,indent=0]
----
include::{testDir}/example/Fast.java[tags=user_guide]
----

[[writing-tests-standard]]
=== 標準的なテストクラス

[source,java,indent=0]
.標準的なテストケース
----
include::{testDir}/example/StandardTests.java[tags=user_guide]
----

NOTE: テストクラスやテストメソッドは、 `public` である必要がありません。

[[writing-tests-display-names]]
=== 表示名

テストクラスやテストメソッドは、カスタムの表示名を宣言できます。
空白や特殊文字だけでなく絵文字も含めることができ、テストランナーやテストレポートに表示されます。

[source,java,indent=0]
----
include::{testDir}/example/DisplayNameDemo.java[tags=user_guide]
----

[[writing-tests-assertions]]
=== アサーション

JUnit Jupiterは、JUnit 4にあった多くのアサーションメソッドをもち、
Java 8のラムダ式と一緒に使いやすいものもいくつか追加しています。
すべてのJUnit Jupiterアサーションは、 `{Assertions}` クラスの `static` メソッドです。

[source,java,indent=0]
----
include::{testDir}/example/AssertionsDemo.java[tags=user_guide]
----

JUnit Jupiterは、 https://kotlinlang.org/[Kotlin]
と一緒に使いやすいアサーションもいくつか含んでいます。すべてのJUnit Jupiter Kotlinアサーションは、
`org.junit.jupiter.api` パッケージのトップレベル関数です。

// TODO: Change to using kotlin language highlighting after switch to rouge syntax highlighter
[source,groovy,indent=0]
----
include::{kotlinTestDir}/example/AssertionsDemoKotlin.kt[tags=user_guide]
----

[[writing-tests-assertions-third-party]]
==== サードパーティーのアサーションライブラリ

多くのテストシナリオではJUnit Jupiterが提供するアサーション機能だけで十分ですが、
時にはさらなるパワーや _マッチャー_ のような追加機能が必要になることもあります。
そのような場合には、 {AssertJ} や {Hamcrest}、 {Truth} のようなサードパーティーの
アサーションライブラリを使うことをJUnitチームはお勧めします。
開発者は、好みに応じてアサーションライブラリを自由に選択することができます。

例えば、 _マッチャー_ と流れるようなAPIを組み合わせれば、アサーションをもっと説明的で
読みやすくすることができます。しかし、JUnit Jupiterの `{Assertions}` クラスは、
JUnit 4の `org.junit.Assert` クラスのようにHamcrestの
http://junit.org/junit4/javadoc/latest/org/hamcrest/Matcher.html[`Matcher`]
を受け付ける
http://junit.org/junit4/javadoc/latest/org/junit/Assert.html#assertThat[`assertThat()`]
メソッドを提供していません。代わりに、開発者はサードパーティーのアサーションライブラリが
提供するマッチャーを利用することが推奨されます。

次の例は、JUnit JupiterテストでHamcrestの `assertThat()` を使う方法を示しています。
Hamcrestライブラリをクラスパスに追加しさえすれば、 `assertThat()` や `is()`、 `equalTo()`
のようなメソッドをstatic importして、下の `assertWithHamcrestMatcher()` メソッドのように
テストの中で使うことができます。

[source,java,indent=0]
----
include::{testDir}/example/HamcrestAssertionDemo.java[tags=user_guide]
----

当然ながら、JUnit 4のプログラミングモデルに基づくレガシーなテストでは、引き続き
`org.junit.Assert#assertThat` を使い続けることができます。

[[writing-tests-assumptions]]
=== 前提条件

JUnit Jupiterは、JUnit 4が提供する前提条件用メソッドの一部を備え、
Java 8のラムダ式と一緒に使いやすいものをいくつか追加しています。
JUnit Jupiterの前提条件メソッドは、すべて `{Assumptions}` クラスのstaticメソッドです。

[source,java,indent=0]
----
include::{testDir}/example/AssumptionsDemo.java[tags=user_guide]
----

[[writing-tests-disabling]]
=== テストの無効化

テストクラス全体または個々のテストメソッドは、 `{Disabled}` アノテーションや
<<writing-tests-conditional-execution>> で説明するアノテーション、
あるいはカスタムの <<extensions-conditions, `ExecutionCondition`>>
によって _無効化_ することができます。

次の例は、`@Disabled` されたテストクラスです。

[source,java,indent=0]
----
include::{testDir}/example/DisabledClassDemo.java[tags=user_guide]
----

そして次の例は、`@Disabled` されたテストメソッドをもつテストクラスです。

[source,java,indent=0]
----
include::{testDir}/example/DisabledTestsDemo.java[tags=user_guide]
----

[[writing-tests-conditional-execution]]
=== 条件付きテスト実行

JUnit Jupiterの <<extensions-conditions, `ExecutionCondition`>> 拡張APIは、
開発者がある一定の条件にもとづいて _手続き的に_  コンテナやテストを有効化したり、
無効化したりすることができるようにします。
簡単な例は、`{Disabled}` アノテーションをサポートする `{DisabledCondition}` です
（<<writing-tests-disabling>> 参照）。

JUnit Jupiterは、`org.junit.jupiter.api.condition` パッケージで `@Disabled`
以外にもアノテーションベースの条件をサポートしています。これにより、開発者は _宣言的に_
コンテナやテストを有効化したり、無効化したりすることができます。
詳細は、以降の節を参照してください。

[TIP]
.合成アノテーション
====
以降で説明するいずれの _条件_ アノテーションも、カスタムの _合成アノテーション_
を作るためのメタアノテーションとして使われうる点に注意してください。例えば、
<<writing-tests-conditional-execution-os-demo, @EnabledOnOsデモ>> の `@TestOnMac`
アノテーションは、`@Test` と `@EnabledOnOs` を1つの再利用可能なアノテーションとして
組み合わせる方法を示しています。
====

[WARNING]
====
以降の節で取り上げられる _条件_ アノテーションは、あるテストインターフェースやテストクラス、
テストメソッドに対して一度しか宣言できません。条件アノテーションがある要素に対して直接、
間接、あるいはメタアノテーションで複数回指定されたとしても、JUnitが最初に見つけた
アノテーションだけが使われます。その他のアノテーションは、黙って無視されます。ただし、
`org.junit.jupiter.api.condition` パッケージのそれぞれの条件アノテーションは、
組み合わせて使うことができる点に注意してください。
====

[[writing-tests-conditional-execution-os]]
==== オペレーティングシステム条件

`{EnabledOnOs}` および `{DisabledOnOs}` アノテーションを使うと、
コンテナやテストを特定のオペレーティングシステムで有効にしたり無効にしたりできます。

[[writing-tests-conditional-execution-os-demo]]
[source,java,indent=0]
----
include::{testDir}/example/ConditionalTestExecutionDemo.java[tags=user_guide_os]
----

[[writing-tests-conditional-execution-jre]]
==== Javaランタイム環境条件

`{EnabledOnJre}` および `{DisabledOnJre}` アノテーションを使うと、
コンテナやテストを特定のバージョンのJavaランタイム環境（JRE）で有効にしたり無効にしたりできます。

[source,java,indent=0]
----
include::{testDir}/example/ConditionalTestExecutionDemo.java[tags=user_guide_jre]
----

[[writing-tests-conditional-execution-system-properties]]
==== システムプロパティ条件

`{EnabledIfSystemProperty}` および `{DisabledIfSystemProperty}` アノテーションを使うと、
指定した名前をもつJVMシステムプロパティの値に応じて、コンテナやテストを有効にしたり
無効にしたりできます。 `matches` 属性で指定する値は、正規表現として解釈されます。

[source,java,indent=0]
----
include::{testDir}/example/ConditionalTestExecutionDemo.java[tags=user_guide_system_property]
----

[[writing-tests-conditional-execution-environment-variables]]
==== 環境変数条件

`{EnabledIfEnvironmentVariable}` および `{DisabledIfEnvironmentVariable}`
アノテーションを使うと、指定した名前をもつ環境変数の値に応じて、コンテナやテストを
有効にしたり無効にしたりできます。`matches` 属性で指定する値は、正規表現として解釈されます。

[source,java,indent=0]
----
include::{testDir}/example/ConditionalTestExecutionDemo.java[tags=user_guide_environment_variable]
----

[[writing-tests-conditional-execution-scripts]]
==== スクリプトベースの条件

JUnit Jupiterは、`{EnabledIf}` または `{DisabledIf}` アノテーションで設定された
スクリプトの実行結果に応じて、コンテナやテストを有効にしたり無効にしたりする機能を提供します。
スクリプトは、JavaScript、Groovy、あるいはJSR 223で定義されたJava Scripting API
をサポートする任意の言語で記述することができます。

WARNING: `{EnabledIf}` および `{DisabledIf}` を使った条件付きテスト実行は、
現在 _試験的な_ 機能です。詳細は、<<api-evolution-experimental-apis>>
のテーブルを参考にしてください。

TIP: もしスクリプトのロジックが現在のオペレーティングシステムやJavaランタイム環境の
バージョン、特定のJVMシステムプロパティや環境変数だけに依存するなら、その目的専用の
組み込みアノテーションの使用を検討すべきです。詳細は、この章の前の節を参照してください。

NOTE: もし同じようなスクリプトベースの条件を何回も使っていると感じたら、
高速かつタイプセーフで、よりメンテナンスしやすい方法で実装するために、専用の
<<extensions-conditions, ExecutionCondition>> 拡張を書くことを検討してください。

[source,java,indent=0]
----
include::{testDir}/example/ConditionalTestExecutionDemo.java[tags=user_guide_scripts]
----

[[writing-tests-conditional-execution-scripts-bindings]]
===== スクリプトバインディング

以下の名前は、スクリプトのコンテキストに束縛されるため、スクリプト内で使うことができます。
_accessor_ は、単純な `String get(String name)` メソッドを介したマップ構造への
アクセスを提供します。

[cols="25,25,75"]
|===
| Name                          | Type          | Description

| `systemEnvironment`           | _accessor_    | オペレーティングシステムの環境変数へのアクセッサ
| `systemProperty`              | _accessor_    | JVMのシステムプロパティへのアクセッサ
| `junitConfigurationParameter` | _accessor_    | 設定パラメーターへのアクセッサ
| `junitDisplayName`            | `String`      | テストやコンテナの表示名
| `junitTags`                   | `Set<String>` | テストやコンテナにアサインされたすべてのタグ
| `junitUniqueId`               | `String`      | テストやコンテナの一意なID
|===


[[writing-tests-tagging-and-filtering]]
=== タグとフィルタリング

テストクラスとテストメソッドには、`@Tag` アノテーションでタグを付与することができます。
これらのタグはあとで <<running-tests, テストを発見・実行>> するときのフィルタリングに
使うことができます。

==== タグの構文規則

* タグは、`null` または _空_ であってはならない
* _トリミングした_ タグは、空白文字を含んではならない
* _トリミングした_ タグは、ISO制御文字を含んではならない
* _トリミングした_ タグは、次の _予約済み文字_ を含んではならない
  - `,`: _カンマ_
  - `(`: _左括弧_
  - `)`: _右括弧_
  - `&`: _アンパサンド_
  - `|`: _縦棒_
  - `!`: _感嘆符_

NOTE: 上のコンテキストで "トリミングした" とは、先頭および末尾の空白文字が
取り除かれていることを意味する。

[source,java,indent=0]
----
include::{testDir}/example/TaggingDemo.java[tags=user_guide]
----

[[writing-tests-test-instance-lifecycle]]
=== テストインスタンスのライフサイクル

個々のテストメソッドを隔離された環境で実行し、テストインスタンスをミュータブルにすると
起こりうる意図しない副作用を避けるため、JUnitは _テスト_ メソッド毎にそのテストクラスの
新しいインスタンスを生成して実行します（_テスト_ メソッドが何を指すかは、後述のNOTEを参照）。
この "per-method（メソッド毎）" のテストインスタンスライフサイクルは、JUnit Jupiter
のデフォルトの挙動で、過去のJUnitのバージョンと同じです。

もしすべてのテストメソッドを同じテストインスタンスで実行させたい場合は、テストクラスに
`@TestInstance(Lifecycle.PER_CLASS)` アノテーションを付与してください。
このモードを使うと、新しいテストインスタンスはテストクラス毎に1回だけ生成されます。
そのため、もしテストメソッドがインスタンス変数の状態に依存するのであれば、
`@BeforeEach` や `@AfterEach` メソッドで状態をリセットする必要があります。

"per-class（クラス毎）" モードは、デフォルトの "per-method（メソッド毎）" モードに比べて
追加のメリットがあります。具体的には、"per-class" モードでは `@BeforeAll` および
`@AfterAll` をインターフェースの `default` メソッドやクラスの非staticなメソッドに
対して宣言できるようになります。そのため、"per-class" モードでは `@BeforeAll` や
`@AfterAll` メソッドを `@Nested` テストクラスでも使えます。

もしプログラミング言語Kotlinでテストを書く場合は、テストインスタンスのライフサイクルを
"per-class" モードに切り替えると、`@BeforeAll` および `@AfterAll` メソッドを
より実装しやすいでしょう。

NOTE: テストインスタンスのライフサイクルのコンテキストでは、_テスト_ メソッドとは
`@Test`, `@RepeatedTest`, `@ParameterizedTest`, `@TestFactory`, `@TestTemplate`
のいずれかのアノテーションが付与されたメソッドを意味します。

[[writing-tests-test-instance-lifecycle-changing-default]]
==== テストインスタンスのデフォルトのライフサイクルの変更

テストクラスやテストインターフェースに `@TestInstance` アノテーションを付与すると、
JUnit Jupiterは _デフォルト_ のライフサイクルモードを使います。標準の _デフォルト_
モードは `PER_METHOD` ですが、テストプラン全体で _デフォルト_ を変更することもできます。
テストインスタンスのデフォルトのライフサイクルモードを変更するには、単に
`junit.jupiter.testinstance.lifecycle.default` _設定パラメーター_ に
`TestInstance.Lifecycle` で定義された列挙定数を指定するだけです。
これは、JVMシステムプロパティや `Launcher` に渡される `LauncherDiscoveryRequest`
の _設定パラメーター_ 、あるいはJUnit Platform設定ファイルなどで指定できます
（詳細は、<<running-tests-config-params>> 参照）。

例えば、デフォルトのライフサイクルモードを `Lifecycle.PER_CLASS` に設定するには、
次のシステムプロパティを指定してJVMを起動します。

`-Djunit.jupiter.testinstance.lifecycle.default=per_class`

ただし、デフォルトのライフサイクルモードをJUnit Platform設定ファイルで指定する方が、
よりロバストである点に注意してください。というのも、設定ファイルならプロジェクトの
バージョン管理システムにチェックインでき、IDEやビルドツールからも使えるからです。

JUnit Platform設定ファイルを使ってデフォルトのライフサイクルモードを `Lifecycle.PER_CLASS`
にするには、クラスパスのルート（例えば、`src/test/resources`）に `junit-platform.properties`
という名前で次のファイルを作ります。

`junit.jupiter.testinstance.lifecycle.default = per_class`

WARNING: テストインスタンスの _デフォルト_ のライフサイクルモードを変更する場合は、
一貫性のある方法で適用しないと予測できない結果や不安定なビルドにつながる可能性があります。
例えば、ビルドでは "per-class" をデフォルトとして設定していても、IDEが "per-method"
でテストを実行していると、ビルドサーバーで起きたエラーをデバッグするのが難しくなります。
そのため、JVMシステムプロパティの代わりにJUnit Platform設定ファイルを使って
デフォルトを変更することをお勧めします。

[[writing-tests-nested]]
=== ネストしたテスト

ネストしたテストは、テスト作成者がテストのグループ関係を表現しやすくします。
詳しい例は次の通りです。

[source,java,indent=0]
.スタックをテストするためのネストしたテストスイート
----
include::{testDir}/example/TestingAStackDemo.java[tags=user_guide]
----

NOTE: _非staticなネストクラス_（すなわち、_内部クラス_）だけが、`@Nested`
テストクラスとして使えます。ネストの深さは自由で、すべての内部クラスがテストクラスの
一部とみなされます。ただし、1つだけ例外があり、`@BeforeAll` および `@AfterAll`
メソッドは、_デフォルトでは_ 機能しません。というのも、Javaでは内部クラスで
`static` メンバーを使用できないからです。しかし、この制限は `@Nested` テストクラスに
`@TestInstance(Lifecycle.PER_CLASS)` アノテーションを付与することで回避できます
（ <<writing-tests-test-instance-lifecycle>> 参照）。

[[writing-tests-dependency-injection]]
=== コンストラクタとメソッドへの依存性注入

これまでのバージョンのJUnitでは、テストクラスのコンストラクタとメソッドは
（少なくとも標準の `Runner` 実装では）引数をもつことができませんでした。
JUnit Jupiterの大きな変更点の1つは、テストのコンストラクタやメソッドが
引数をもてるようになったことです。これは大きな柔軟性をもたらし、
_依存性注入_ を可能にします。

`{ParameterResolver}` は、実行時に _動的に_ 引数を解決したいテスト拡張のための
APIを定義しています。もしテストコンストラクタや `@Test`, `@TestFactory`,
`@BeforeEach`, `@AfterEach`, `@BeforeAll`, `@AfterAll` メソッドが引数をもつ場合、
その引数は登録済みの `ParameterResolver` によって解決されます。

現状、自動的に登録される組み込みのResolverが3つあります。

* `{TestInfoParameterResolver}`: もしメソッドの引数の型が `{TestInfo}` の場合、
  `TestInfoParameterResolver` が現在のテストに応じた `TestInfo` をその引数の値として
  与えます。 `TestInfo` は、テストの表示名やテストクラス、テストメソッド、付与されたタグなど、
  現在のテストに関する情報を取得するために使用できます。表示名は、テストクラスやテストメソッド
  の名前か、`@DisplayName` で設定されたカスタムの名前か、どちらかになります。
+
`{TestInfo}` は、JUnit 4の `TestName` ルールの代替として使えます。
次の例は、`TestInfo` をテストのコンストラクタ、`@BeforeEach` メソッド、および
`@Test` メソッドに注入する方法を示しています。

[source,java,indent=0]
----
include::{testDir}/example/TestInfoDemo.java[tags=user_guide]
----

* `RepetitionInfoParameterResolver`: もし `@RepeatedTest`, `@BeforeEach`,
  `@AfterEach` メソッドの引数の型が `{RepetitionInfo}` の場合、
  `RepetitionInfoParameterResolver` が `RepetitionInfo` インスタンスを与えます。
  `RepetitionInfo` は、`@RepeatedTest` の現在の繰り返し回数や合計回数の情報を
  取得するために使用できます。ただし、`RepetitionInfoParameterResolver` は
  `@RepeatedTest` 以外では登録されないことに注意してください。
  <<writing-tests-repeated-tests-examples>> を参照。

* `{TestReporterParameterResolver}`: もしメソッドの引数の型が `{TestReporter}`
  の場合、`TestReporterParameterResolver` が `TestReporter` インスタンスを与えます。
  `TestReporter` は、現在のテスト実行に関する追加のデータを出力するために使用できます。
  このデータは、`{TestExecutionListener}.reportingEntryPublished()`
  を通して取得できるので、IDEで参照したり、レポートに含めたりできます。
+
JUnit Jupiterでは、JUnit 4で `stdout` や `stderr` に情報を出力していた代わりに、
`TestReporter` を使うべきです。 `@RunWith(JUnitPlatform.class)` を使うときも、
すべてのレポート情報が `stdout` に出力されます。

[source,java,indent=0]
----
include::{testDir}/example/TestReporterDemo.java[tags=user_guide]
----

NOTE: そのほかの `ParameterResolver` は、`@ExtendWith` を使って適切な
<<extensions, 拡張機能>> を登録することで、明示的に有効にしなければなりません。


カスタムの `{ParameterResolver}` のサンプルとしては、`{MockitoExtension}`
を参照してください。本番利用を想定したものではありませんが、
拡張モデルとパラメーター解決処理のシンプルさや高い表現力を示しています。
`MyMockitoTest` は、Mockitoのモックを `@BeforeEach` と `@Test`
に注入する方法をデモしています。

[source,java,indent=0]
----
import static org.junit.jupiter.api.Assertions.assertEquals;
import static org.mockito.Mockito.when;

import org.junit.jupiter.api.BeforeEach;
import org.junit.jupiter.api.Test;
import org.junit.jupiter.api.extension.ExtendWith;
import org.mockito.Mock;
import com.example.Person;
import com.example.mockito.MockitoExtension;

@ExtendWith(MockitoExtension.class)
class MyMockitoTest {

	@BeforeEach
	void init(@Mock Person person) {
		when(person.getName()).thenReturn("Dilbert");
	}

	@Test
	void simpleTestWithInjectedMock(@Mock Person person) {
		assertEquals("Dilbert", person.getName());
	}

}
----

[[writing-tests-test-interfaces-and-default-methods]]
=== テストインターフェースとデフォルトメソッド

JUnit Jupiterでは、`@Test`, `@RepeatedTest`, `@ParameterizedTest`, `@TestFactory`,
`@TestTemplate`, `@BeforeEach`, `@AfterEach` アノテーションをインターフェースの
`default` メソッドに対して宣言することもできます。 `@BeforeAll` と `@AfterAll`
はテストインターフェースの `static` メソッドにしか宣言できませんが、
`@TestInstance(Lifecycle.PER_CLASS)` がテストインターフェースまたはテストクラスに
付与されていればインターフェースの `default` メソッドに宣言することもできます
（<<writing-tests-test-instance-lifecycle>> 参照）。以下はサンプルです。

[source,java]
----
include::{testDir}/example/testinterface/TestLifecycleLogger.java[tags=user_guide]
----

[source,java]
----
include::{testDir}/example/testinterface/TestInterfaceDynamicTestsDemo.java[tags=user_guide]
----

`@ExtendWith` と `@Tag` はテストインターフェースに宣言することで、
そのインタフェースを実装したクラスにタグと拡張機能を自動的に継承させることができます。
<<extensions-lifecycle-callbacks-before-after-execution>> にある
<<extensions-lifecycle-callbacks-timing-extension, TimingExtension>>
のソースコードを参照してください。

[source,java]
----
include::{testDir}/example/testinterface/TimeExecutionLogger.java[tags=user_guide]
----

これらのインタフェースを実装することでテストクラスに適用することができます。

[source,java]
----
include::{testDir}/example/testinterface/TestInterfaceDemo.java[tags=user_guide]
----

`TestInterfaceDemo` を実行すると、次のような出力となります。

....
:junitPlatformTest
INFO  example.TestLifecycleLogger - Before all tests
INFO  example.TestLifecycleLogger - About to execute [dynamicTestsFromCollection()]
INFO  example.TimingExtension - Method [dynamicTestsFromCollection] took 13 ms.
INFO  example.TestLifecycleLogger - Finished executing [dynamicTestsFromCollection()]
INFO  example.TestLifecycleLogger - About to execute [isEqualValue()]
INFO  example.TimingExtension - Method [isEqualValue] took 1 ms.
INFO  example.TestLifecycleLogger - Finished executing [isEqualValue()]
INFO  example.TestLifecycleLogger - After all tests

Test run finished after 190 ms
[         3 containers found      ]
[         0 containers skipped    ]
[         3 containers started    ]
[         0 containers aborted    ]
[         3 containers successful ]
[         0 containers failed     ]
[         3 tests found           ]
[         0 tests skipped         ]
[         3 tests started         ]
[         0 tests aborted         ]
[         3 tests successful      ]
[         0 tests failed          ]

BUILD SUCCESSFUL
....

この機能の別の適用例としては、インタフェース契約に対するテストが考えられます。
例えば、`Object.equals` や `Comparable.compareTo` の実装クラスが
どう振る舞うべきかのテストを次のように書くことができます。

[source,java]
----
include::{testDir}/example/defaultmethods/Testable.java[tags=user_guide]
----

[source,java]
----
include::{testDir}/example/defaultmethods/EqualsContract.java[tags=user_guide]
----

[source,java]
----
include::{testDir}/example/defaultmethods/ComparableContract.java[tags=user_guide]
----

テストクラスでこれらの契約インターフェースを実装することで、対応するテストケースを
継承することができます。もちろん、抽象メソッドは自分で実装する必要があります。

[source,java]
----
include::{testDir}/example/defaultmethods/StringTests.java[tags=user_guide]
----

NOTE: 前述のテストはサンプル目的であり、完全なものではありません。


[[writing-tests-repeated-tests]]
=== 繰り返しテスト

JUnit Jupiterは、`@RepeatedTest` アノテーションを使って指定した回数だけ
繰り返しテストを実行する機能を提供しています。
繰り返しテストの1回毎の呼び出しは、ライフサイクルコールバックや拡張機能など、通常の
`@Test` メソッドの実行と同じように振る舞います。

次の例は、自動的に10回繰り返す `repeatedTest()` を宣言する方法を示しています。

[source,java]
----
@RepeatedTest(10)
void repeatedTest() {
	// ...
}
----

繰り返し回数を指定するだけでなく、`@RepeatedTest` アノテーションの `name`
属性を使って、繰り返し実行毎の表示名を変更することもできます。表示名は、
静的なテキストと動的なプレースホルダーを組み合わせたパターンにできます。
以下が、現在サポートされているプレースホルダーです。

- `{displayName}`: `@RepeatedTest` メソッドの表示名
- `{currentRepetition}`: 現在の実行回数
- `{totalRepetitions}`: トータルの実行回数

デフォルトの表示名は、`"repetition {currentRepetition} of {totalRepetitions}"`
というパターンに従います。そのため、前述の `repeatedTest()` に対する表示名は、
`repetition 1 of 10`, `repetition 2 of 10` のようになります。
もし `@RepeatedTest` メソッドの名前を含めたい場合は、カスタムのパターンを指定するか、
定義済みの `RepeatedTest.LONG_DISPLAY_NAME` パターンを指定できます。
後者は、`"{displayName} :: repetition {currentRepetition} of {totalRepetitions}"`
というパターンと同等で、`repeatedTest() :: repetition 1 of 10`,
`repeatedTest() :: repetition 2 of 10` のようになります。

現在の繰り返し回数やトータルの繰り返し回数をプログラムから取得するためには、
`RepetitionInfo` インスタンスを `@RepeatedTest`, `@BeforeEach`, `@AfterEach`
メソッドのいずれかに注入させることができます。

[[writing-tests-repeated-tests-examples]]
==== 繰り返しテストの例

この節の最後の `RepeatedTestsDemo` クラスは、繰り返しテストの様々な例を示しています。

`repeatedTest()` メソッドは、前の節で紹介した例と同じです。一方、
`repeatedTestWithRepetitionInfo()` は、トータルの繰り返し回数を取得するために
`RepetitionInfo` インスタンスをテストに注入させる方法を示しています。

その次の2つのメソッドは、`@RepeatedTest` メソッドに対するカスタムの `@DisplayName`
を各繰り返しの表示名に含める方法を示しています。`customDisplayName()` は、
カスタムの表示名とパターンを組み合わせて指定し、生成された表示名を検証するのに
`TestInfo` を使っています。
`{displayName}` が `@DisplayName` の宣言から `Repeat!` となり、
`{currentRepetition}/{totalRepetitions}` が `1/1` となります。
一方、`customDisplayNameWithLongPattern()` は前述の定義済みパターン
`RepeatedTest.LONG_DISPLAY_NAME` を使っています。

`repeatedTestInGerman()` は、繰り返しテストの表示名を外国語（この場合、ドイツ語）
に翻訳する方法を示しています。各繰り返しの表示名は、`Wiederholung 1 von 5`,
`Wiederholung 2 von 5` のようになります。

`beforeEach()` メソッドは `@BeforeEach` アノテーションが付与されているため、
繰り返しテストの個々の繰り返し実行の度に実行されます。`TestInfo` と
`RepetitionInfo` をメソッドに注入させることで、現在実行中の繰り返しテストに
関する情報を取得できることが分かります。`INFO` レベルのログを有効にして
`RepeatedTestsDemo` を実行すると、次のような出力となります。

....
INFO: About to execute repetition 1 of 10 for repeatedTest
INFO: About to execute repetition 2 of 10 for repeatedTest
INFO: About to execute repetition 3 of 10 for repeatedTest
INFO: About to execute repetition 4 of 10 for repeatedTest
INFO: About to execute repetition 5 of 10 for repeatedTest
INFO: About to execute repetition 6 of 10 for repeatedTest
INFO: About to execute repetition 7 of 10 for repeatedTest
INFO: About to execute repetition 8 of 10 for repeatedTest
INFO: About to execute repetition 9 of 10 for repeatedTest
INFO: About to execute repetition 10 of 10 for repeatedTest
INFO: About to execute repetition 1 of 5 for repeatedTestWithRepetitionInfo
INFO: About to execute repetition 2 of 5 for repeatedTestWithRepetitionInfo
INFO: About to execute repetition 3 of 5 for repeatedTestWithRepetitionInfo
INFO: About to execute repetition 4 of 5 for repeatedTestWithRepetitionInfo
INFO: About to execute repetition 5 of 5 for repeatedTestWithRepetitionInfo
INFO: About to execute repetition 1 of 1 for customDisplayName
INFO: About to execute repetition 1 of 1 for customDisplayNameWithLongPattern
INFO: About to execute repetition 1 of 5 for repeatedTestInGerman
INFO: About to execute repetition 2 of 5 for repeatedTestInGerman
INFO: About to execute repetition 3 of 5 for repeatedTestInGerman
INFO: About to execute repetition 4 of 5 for repeatedTestInGerman
INFO: About to execute repetition 5 of 5 for repeatedTestInGerman
....

[source,java]
----
include::{testDir}/example/RepeatedTestsDemo.java[tags=user_guide]
----

Unicodeテーマを有効にした `ConsoleLauncher` または `junitPlatformTest`
Gradle プラグインで `RepeatedTestsDemo` を実行すると、コンソールには
以下のように出力されます。

....
├─ RepeatedTestsDemo ✔
│  ├─ repeatedTest() ✔
│  │  ├─ repetition 1 of 10 ✔
│  │  ├─ repetition 2 of 10 ✔
│  │  ├─ repetition 3 of 10 ✔
│  │  ├─ repetition 4 of 10 ✔
│  │  ├─ repetition 5 of 10 ✔
│  │  ├─ repetition 6 of 10 ✔
│  │  ├─ repetition 7 of 10 ✔
│  │  ├─ repetition 8 of 10 ✔
│  │  ├─ repetition 9 of 10 ✔
│  │  └─ repetition 10 of 10 ✔
│  ├─ repeatedTestWithRepetitionInfo(RepetitionInfo) ✔
│  │  ├─ repetition 1 of 5 ✔
│  │  ├─ repetition 2 of 5 ✔
│  │  ├─ repetition 3 of 5 ✔
│  │  ├─ repetition 4 of 5 ✔
│  │  └─ repetition 5 of 5 ✔
│  ├─ Repeat! ✔
│  │  └─ Repeat! 1/1 ✔
│  ├─ Details... ✔
│  │  └─ Details... :: repetition 1 of 1 ✔
│  └─ repeatedTestInGerman() ✔
│     ├─ Wiederholung 1 von 5 ✔
│     ├─ Wiederholung 2 von 5 ✔
│     ├─ Wiederholung 3 von 5 ✔
│     ├─ Wiederholung 4 von 5 ✔
│     └─ Wiederholung 5 von 5 ✔
....


[[writing-tests-parameterized-tests]]
=== パラメーター化テスト

パラメーター化テストは、異なる引数でテストを複数回実行できるようにします。
通常の `@Test` メソッドに似ていますが、`{ParameterizedTest}` アノテーションを
使って宣言します。また、各呼び出しに対する引数を生成するための _ソース (source)_
を少なくとも1つは指定しなければいけません。

WARNING: パラーメーター化テストは、現在 _実験中_ の機能です。
詳細は、<<api-evolution-experimental-apis>> の表を確認してください。

[source,java,indent=0]
----
include::{testDir}/example/ParameterizedTestDemo.java[tags=first_example]
----

このパラメーター化テストは、引数のソースとして `String` 配列を指定するために、
`@ValueSource` アノテーションを使用しています。上のメソッドを実行すると、
各実行が別々にレポートされます。例えば、`ConsoleLauncher`
を使うと次のように出力されます。

....
palindromes(String) ✔
├─ [1] racecar ✔
├─ [2] radar ✔
└─ [3] able was I ere I saw elba ✔
....

[[writing-tests-parameterized-tests-setup]]
==== 必要なセットアップ

パラメーター化テストを使うには、`junit-jupiter-params` への依存を追加する必要があります。
詳細は、<<dependency-metadata>> を参照してください。

[[writing-tests-parameterized-tests-sources]]
==== 引数のソース

JUnit Jupiterは、あらかじめいくつかの _ソース_ アノテーションを提供しています。
以降では、これらのアノテーションについて簡単な説明とサンプルを示します。
より詳細な情報は、`{params-provider-package}` パッケージのJavaDocを参照してください。

[[writing-tests-parameterized-tests-sources-ValueSource]]
===== @ValueSource

`@ValueSource` は、最もシンプルなソースの1つです。リテラル値の配列を指定できますが、
パラメーター化テストの1回の実行につき1つのパラメーターしか与えることができません。

`@ValueSource` では、以下の型のリテラル値がサポートされています。

- `short`
- `byte`
- `int`
- `long`
- `float`
- `double`
- `char`
- `java.lang.String`
- `java.lang.Class`

例えば、次の `@ParameterizedTest` メソッドは、`1`, `2`, `3` をパラメーターとして
3回呼び出されます。

[source,java,indent=0]
----
include::{testDir}/example/ParameterizedTestDemo.java[tags=ValueSource_example]
----

[[writing-tests-parameterized-tests-sources-EnumSource]]
===== @EnumSource

`@EnumSource` は、`Enum` 定数を指定する便利な方法を提供します。このアノテーションでは、
省略可能な `names` パラメーターを指定すると、その列挙定数だけが使われます。
省略すると、次の例のようにすべての列挙定数が使われます。

[source,java,indent=0]
----
include::{testDir}/example/ParameterizedTestDemo.java[tags=EnumSource_example]
----

[source,java,indent=0]
----
include::{testDir}/example/ParameterizedTestDemo.java[tags=EnumSource_include_example]
----

`@EnumSource` アノテーションは、テストメソッドに渡される列挙定数をさらに細かく制御するために、
省略可能な `mode` パラメーターも提供しています。例えば、一部の名前をもつ列挙定数だけ除外したり、
正規表現で列挙定数を指定したりすることができます。

[source,java,indent=0]
----
include::{testDir}/example/ParameterizedTestDemo.java[tags=EnumSource_exclude_example]
----

[source,java,indent=0]
----
include::{testDir}/example/ParameterizedTestDemo.java[tags=EnumSource_regex_example]
----

[[writing-tests-parameterized-tests-sources-MethodSource]]
===== @MethodSource

`@MethodSource` は、テストクラスの _ファクトリ_ メソッドによる指定を可能にします。
ファクトリメソッドは、`Stream`, `Iterable`, `Iterator`, または配列のいずれかを
返さなければいけません。また、引数を受け取ることもできません。デフォルトでは、テストクラスに
`@TestInstance(Lifecycle.PER_CLASS)` アノテーションが付与されていない限り、
`static` メソッドでなければいけません。

パラメーターが1つしか必要なければ、次の例のようにパラメーターのインスタンスを
`Stream` で返すことができます。

[source,java,indent=0]
----
include::{testDir}/example/ParameterizedTestDemo.java[tags=simple_MethodSource_example]
----

もし `@MethodSource` でファクトリメソッドの名前を明示的に指定しなかった場合、JUnit Jupiter
は `@ParameterizedTest` メソッドと同じ名前をもつファクトリメソッドを自動的に探します。

[source,java,indent=0]
----
include::{testDir}/example/ParameterizedTestDemo.java[tags=simple_MethodSource_without_value_example]
----

プリミティブ型のストリーム (`DoubleStream`, `IntStream`, `LongStream`)
もサポートされています。

[source,java,indent=0]
----
include::{testDir}/example/ParameterizedTestDemo.java[tags=primitive_MethodSource_example]
----

テストメソッドが複数のパラメーターを宣言している場合、以下で示すように `Arguments`
のコレクションかストリームを返す必要があります。`Arguments.of(Object...)` は、
`Arguments` インターフェースで定義されるstaticファクトリメソッドである点に注意してください。

[source,java,indent=0]
----
include::{testDir}/example/ParameterizedTestDemo.java[tags=multi_arg_MethodSource_example]
----

[[writing-tests-parameterized-tests-sources-CsvSource]]
===== @CsvSource

`@CsvSource` は、引数のリストをカンマ区切りの値（`String` リテラル）
で指定できるようにします。

[source,java,indent=0]
----
include::{testDir}/example/ParameterizedTestDemo.java[tags=CsvSource_example]
----

`@CsvSource` は、シングルクォート `'` を引用符として使います。
上の例の `'baz, qux'` と、以下のテーブルを参照してください。
引用符で囲まれた空の値 `''` は空の `String` になりますが、
（引用符で囲まれない）完全に _空_ の値は `null` と解釈されます。
`null` の代入先パラメーターがプリミティブ型の場合は、
`ArgumentConversionException` が発生します。

[cols="50,50"]
|===
| Example Input                        | Resulting Argument List

| `@CsvSource({ "foo, bar" })`         | `"foo"`, `"bar"`
| `@CsvSource({ "foo, 'baz, qux'" })`  | `"foo"`, `"baz, qux"`
| `@CsvSource({ "foo, ''" })`          | `"foo"`, `""`
| `@CsvSource({ "foo, " })`            | `"foo"`, `null`
|===

[[writing-tests-parameterized-tests-sources-CsvFileSource]]
===== @CsvFileSource

`@CsvFileSource` は、クラスパスにあるCSVファイルを使えるようにします。
CSVファイルの各行は、パラメーター化テストの1回の実行になります。

[source,java,indent=0]
----
include::{testDir}/example/ParameterizedTestDemo.java[tags=CsvFileSource_example]
----

[source,csv,indent=0]
.two-column.csv
----
include::{testResourcesDir}/two-column.csv[]
----

NOTE: `@CsvSource` のシンタックスとは異なり、`@CsvFileSource` はダブルクォート `"`
を引用符として使います。上の例の、`"United States of America"` を参考にしてください。
引用符で囲まれた空の値 `""` は空の `String` になりますが、
（引用符で囲まれない）完全に _空_ の値は `null` と解釈されます。
`null` の代入先パラメーターがプリミティブ型の場合は、
`ArgumentConversionException` が発生します。

[[writing-tests-parameterized-tests-sources-ArgumentsSource]]
===== @ArgumentsSource

`@ArgumentsSource` は、カスタムの再利用可能な `ArgumentsProvider`
を指定する場合に使えます。

[source,java,indent=0]
----
include::{testDir}/example/ParameterizedTestDemo.java[tags=ArgumentsSource_example]
----


[[writing-tests-parameterized-tests-argument-conversion]]
==== 引数の変換

[[writing-tests-parameterized-tests-argument-conversion-implicit]]
===== 暗黙的な変換

`@CsvSource` のようなユースケースをサポートするために、JUnit Jupiter
は多くの組み込みの型変換を提供しています。
変換処理は、メソッド引数の型に依存します。

例えば、`@ParameterizedTest` が `TimeUnit` 型のパラメーターを宣言し、
ソースから実際に渡される型が `String` の場合、その文字列は対応する
`TimeUnit` 列挙定数に自動的に変換されます。

[source,java,indent=0]
----
include::{testDir}/example/ParameterizedTestDemo.java[tags=implicit_conversion_example]
----

`String` インスタンスは、今のところ次のようなターゲット型に暗黙的に変換されます。

[[writing-tests-parameterized-tests-argument-conversion-implicit-table]]
[cols="10,90"]
|===
| Target Type | Example

| `boolean`/`Boolean`        | `"true"`                                 -> `true`
| `byte`/`Byte`              | `"1"`                                    -> `(byte) 1`
| `char`/`Character`         | `"o"`                                    -> `'o'`
| `short`/`Short`            | `"1"`                                    -> `(short) 1`
| `int`/`Integer`            | `"1"`                                    -> `1`
| `long`/`Long`              | `"1"`                                    -> `1L`
| `float`/`Float`            | `"1.0"`                                  -> `1.0f`
| `double`/`Double`          | `"1.0"`                                  -> `1.0d`
| `Enum` subclass            | `"SECONDS"`                              -> `TimeUnit.SECONDS`
| `java.io.File`             | `"/path/to/file"`                        -> `new File("/path/to/file")`
| `java.math.BigDecimal`     | `"123.456e789"`                          -> `new BigDecimal("123.456e789")`
| `java.math.BigInteger`     | `"1234567890123456789"`                  -> `new BigInteger("1234567890123456789")`
| `java.net.URI`             | `"http://junit.org/"`                    -> `URI.create("http://junit.org/")`
| `java.net.URL`             | `"http://junit.org/"`                    -> `new URL("http://junit.org/")`
| `java.nio.charset.Charset` | `"UTF-8"`                                -> `Charset.forName("UTF-8")`
| `java.nio.file.Path`       | `"/path/to/file"`                        -> `Paths.get("/path/to/file")`
| `java.time.Instant`        | `"1970-01-01T00:00:00Z"`                 -> `Instant.ofEpochMilli(0)`
| `java.time.LocalDateTime`  | `"2017-03-14T12:34:56.789"`              -> `LocalDateTime.of(2017, 3, 14, 12, 34, 56, 789_000_000)`
| `java.time.LocalDate`      | `"2017-03-14"`                           -> `LocalDate.of(2017, 3, 14)`
| `java.time.LocalTime`      | `"12:34:56.789"`                         -> `LocalTime.of(12, 34, 56, 789_000_000)`
| `java.time.OffsetDateTime` | `"2017-03-14T12:34:56.789Z"`             -> `OffsetDateTime.of(2017, 3, 14, 12, 34, 56, 789_000_000, ZoneOffset.UTC)`
| `java.time.OffsetTime`     | `"12:34:56.789Z"`                        -> `OffsetTime.of(12, 34, 56, 789_000_000, ZoneOffset.UTC)`
| `java.time.YearMonth`      | `"2017-03"`                              -> `YearMonth.of(2017, 3)`
| `java.time.Year`           | `"2017"`                                 -> `Year.of(2017)`
| `java.time.ZonedDateTime`  | `"2017-03-14T12:34:56.789Z"`             -> `ZonedDateTime.of(2017, 3, 14, 12, 34, 56, 789_000_000, ZoneOffset.UTC)`
| `java.util.Currency`       | `"JPY"`                                  -> `Currency.getInstance("JPY")`
| `java.util.Locale`         | `"en"`                                   -> `new Locale("en")`
| `java.util.UUID`           | `"d043e930-7b3b-48e3-bdbe-5a3ccfb833db"` -> `UUID.fromString("d043e930-7b3b-48e3-bdbe-5a3ccfb833db")`
|===

[[writing-tests-parameterized-tests-argument-conversion-implicit-fallback]]
====== String → Object変換のフォールバック

上の表で示した文字列からターゲット型への暗黙的な変換に加えて、JUnit Jupiter
は `String` 型からターゲット型に自動変換するフォールバックの仕組みも提供しています。
この変換は、ターゲット型が以下に示す _ファクトリメソッド_ か _ファクトリコンストラクタ_
を1つだけ宣言している場合に機能します。

- __ファクトリメソッド__: ターゲット型に宣言された非privateの `static` メソッドで、
  `String` 型の引数を1つだけ受け取ってターゲット型のインスタンスを返す。
  メソッドの名前は任意であり、特定のルールに従う必要はない。
- __ファクトリコンストラクタ__: ターゲット型に宣言された非privateのコンストラクタで、
  `String` 型の引数を1つだけ受け取ってインスタンスを作る。

NOTE: 複数の _ファクトリメソッド_ が見つかった場合、それらは無視されます。
_ファクトリメソッド_ と _ファクトリコンストラクタ_ が両方見つかった場合は、
ファクトリメソッドの方が使われます。

例えば、次の `@ParameterizedTest` メソッドでは、`Book` 型の引数は
`Book.fromTitle(String)` ファクトリメソッドに本のタイトルとして `"42 Cats"`
を渡して実行することで作られます。

[source,java,indent=0]
----
include::{testDir}/example/ParameterizedTestDemo.java[tags=implicit_fallback_conversion_example]
----

[[writing-tests-parameterized-tests-argument-conversion-explicit]]
===== 明示的な変換

引数の暗黙的な変換を使う代わりに、`@ConvertWith` アノテーションで
特定のパラメーターの変換に使う `ArgumentConverter` を明示的に指定することもできます。

[source,java,indent=0]
----
include::{testDir}/example/ParameterizedTestDemo.java[tags=explicit_conversion_example]
----

明示的な型変換器はテストまたは拡張機能の作者に実装されることを想定しています。
そのため、`junit-jupiter-params` モジュールは参照実装として `JavaTimeArgumentConverter`
の1つだけしか提供していません。これは、合成アノテーション `JavaTimeConversionPattern`
経由で使用できます。

[source,java,indent=0]
----
include::{testDir}/example/ParameterizedTestDemo.java[tags=explicit_java_time_converter]
----


[[writing-tests-parameterized-tests-display-names]]
==== 表示名のカスタマイズ

デフォルトでは、パラメーター化テストの表示名には、呼び出しインデックスとすべての引数の
`String` 表現が含まれます。ただし、`@ParameterizedTest` アノテーションの `name`
属性を指定すれば、次の例のようにカスタマイズすることもできます。

[source,java,indent=0]
----
include::{testDir}/example/ParameterizedTestDemo.java[tags=custom_display_names]
----

上のメソッドを `ConsoleLauncher` で実行すると、以下のような出力となります。

....
Display name of container ✔
├─ 1 ==> first='foo', second=1 ✔
├─ 2 ==> first='bar', second=2 ✔
└─ 3 ==> first='baz, qux', second=3 ✔
....

次のプレースホルダーがサポートされています。

[cols="20,80"]
|===
| Placeholder       | Description

| `{index}`         | 現在の呼び出しインデックス（1始まり）
| `{arguments}`     | カンマ区切りの完全な引数のリスト
| `{0}`, `{1}`, ... | 引数
|===


[[writing-tests-parameterized-tests-lifecycle-interop]]
==== ライフサイクルと相互運用性

パラメーター化テストの各呼び出しは、通常の `@Test` メソッドと同じライフサイクルをもちます。
例えば、`@BeforeEach` メソッドが各呼び出しの前に実行されます。
<<writing-tests-dynamic-tests>> と同様に、パラメーター化テストの各呼び出しは、
IDEのテストツリーの中に1つずつ表示されます。同じテストクラスの中で、
`@Test` メソッドと `@ParameterizedTest` メソッドを混在させるのも自由です。

`ParameterResolver` 拡張を `@ParameterizedTest` メソッドと使いたいかもしれません。
その場合は、パラメーター化テストのソースから渡される引数を先に宣言する必要があります。
テストクラスは、パラメーター化テストだけでなく通常のテストも含んでいる可能性があるので、
引数ソースからの値はライフサイクルメソッド (例えば、`@BeforeEach`)
やテストコンストラクタに対しては渡すことができません。

[source,java,indent=0]
----
include::{testDir}/example/ParameterizedTestDemo.java[tags=ParameterResolver_example]
----


[[writing-tests-test-templates]]
=== Test Templates

A `{TestTemplate}` method is not a regular test case but rather a template for test
cases. As such, it is designed to be invoked multiple times depending on the number of
invocation contexts returned by the registered providers. Thus, it must be used in
conjunction with a registered `{TestTemplateInvocationContextProvider}` extension. Each
invocation of a test template method behaves like the execution of a regular `@Test`
method with full support for the same lifecycle callbacks and extensions. Please refer to
<<extensions-test-templates>> for usage examples.


[[writing-tests-dynamic-tests]]
=== Dynamic Tests

The standard `@Test` annotation in JUnit Jupiter described in
<<writing-tests-annotations>> is very similar to the `@Test` annotation in JUnit 4. Both
describe methods that implement test cases. These test cases are static in the sense that
they are fully specified at compile time, and their behavior cannot be changed by
anything happening at runtime. _Assumptions provide a basic form of dynamic behavior but
are intentionally rather limited in their expressiveness._

In addition to these standard tests a completely new kind of test programming model has
been introduced in JUnit Jupiter. This new kind of test is a _dynamic test_ which is
generated at runtime by a factory method that is annotated with `@TestFactory`.

In contrast to `@Test` methods, a `@TestFactory` method is not itself a test case but
rather a factory for test cases. Thus, a dynamic test is the product of a factory.
Technically speaking, a `@TestFactory` method must return a `Stream`, `Collection`,
`Iterable`, or `Iterator` of `DynamicNode` instances. Instantiable subclasses of
`DynamicNode` are `DynamicContainer` and `DynamicTest`. `DynamicContainer` instances are
composed of a _display name_ and a list of dynamic child nodes, enabling the creation of
arbitrarily nested hierarchies of dynamic nodes. `DynamicTest` instances will then be
executed lazily, enabling dynamic and even non-deterministic generation of test cases.

Any `Stream` returned by a `@TestFactory` will be properly closed by calling
`stream.close()`, making it safe to use a resource such as `Files.lines()`.

As with `@Test` methods, `@TestFactory` methods must not be `private` or `static` and may
optionally declare parameters to be resolved by `ParameterResolvers`.

A `DynamicTest` is a test case generated at runtime. It is composed of a _display name_
and an `Executable`. `Executable` is a `@FunctionalInterface` which means that the
implementations of dynamic tests can be provided as _lambda expressions_ or _method
references_.

.Dynamic Test Lifecycle
WARNING: The execution lifecycle of a dynamic test is quite different than it is for a
standard `@Test` case. Specifically, there are no lifecycle callbacks for individual
dynamic tests. This means that `@BeforeEach` and `@AfterEach` methods and their
corresponding extension callbacks are executed for the `@TestFactory` method but not for
each _dynamic test_. In other words, if you access fields from the test instance within a
lambda expression for a dynamic test, those fields will not be reset by callback methods
or extensions between the execution of individual dynamic tests generated by the same
`@TestFactory` method.

As of JUnit Jupiter {jupiter-version}, dynamic tests must always be created by factory
methods; however, this might be complemented by a registration facility in a later
release.

WARNING: Dynamic tests are currently an _experimental_ feature. Consult the table in
<<api-evolution-experimental-apis>> for details.

[[writing-tests-dynamic-tests-examples]]
==== Dynamic Test Examples

The following `DynamicTestsDemo` class demonstrates several examples of test factories
and dynamic tests.

The first method returns an invalid return type. Since an invalid return type cannot be
detected at compile time, a `JUnitException` is thrown when it is detected at runtime.

The next five methods are very simple examples that demonstrate the generation of a
`Collection`, `Iterable`, `Iterator`, or `Stream` of `DynamicTest` instances. Most of
these examples do not really exhibit dynamic behavior but merely demonstrate the
supported return types in principle. However, `dynamicTestsFromStream()` and
`dynamicTestsFromIntStream()` demonstrate how easy it is to generate dynamic tests for a
given set of strings or a range of input numbers.

The next method is truly dynamic in nature. `generateRandomNumberOfTests()` implements an
`Iterator` that generates random numbers, a display name generator, and a test executor
and then provides all three to `DynamicTest.stream()`. Although the non-deterministic
behavior of `generateRandomNumberOfTests()` is of course in conflict with test
repeatability and should thus be used with care, it serves to demonstrate the
expressiveness and power of dynamic tests.

The last method generates a nested hierarchy of dynamic tests utilizing
`DynamicContainer`.

[source,java]
----
include::{testDir}/example/DynamicTestsDemo.java[tags=user_guide]
----
