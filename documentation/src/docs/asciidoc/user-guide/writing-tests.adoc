[[writing-tests]]
== テストを書く

[source,java,indent=0]
.最初のテストケース
----
include::{testDir}/example/FirstJUnit5Tests.java[tags=user_guide]
----

[[writing-tests-annotations]]
=== アノテーション

JUnit Jupiterは、テストを構成し、フレームワークを拡張するために、次のアノテーションをサポートします。

中心となるすべてのアノテーションは、 `junit-jupiter-api` モジュールの `{api-package}` パッケージに含まれます。

[cols="20,80"]
|===
| アノテーション         | 説明

| `@Test`              | このメソッドが、テストメソッドであることを示します。JUnit 4の `@Test` アノテーションとは異なり、このアノテーションはどんな属性も宣言しません。というのも、JUnit Jupiterのテスト拡張は、それ専用のアノテーションベースで行われるからです。このメソッドは、_オーバーライド_ されない限り、_継承_ されます。
| `@ParameterizedTest` | このメソッドが、<<writing-tests-parameterized-tests, パラメーター化テスト>> であることを示します。このメソッドは、_オーバーライド_ されない限り、_継承_ されます。
| `@RepeatedTest`      | このメソッドが、<<writing-tests-repeated-tests, 繰り返しテスト>> のためのテストテンプレートであることを示します。このメソッドは、_オーバーライド_ されない限り、_継承_ されます。
| `@TestFactory`       | このメソッドが、<<writing-tests-dynamic-tests, 動的テスト>> のためのテストファクトリであることを示します。このメソッドは、_オーバーライド_ されない限り、_継承_ されます。
| `@TestInstance`      | アノテーションを付与したテストクラスに対して、<<writing-tests-test-instance-lifecycle, テストインスタンスのライフサイクル>> を設定するために使われます。このアノテーションは、_継承_ されます。
| `@TestTemplate`      | このメソッドが、<<writing-tests-test-templates, テストケースのテンプレート>> であることを示します。このメソッドは、登録した <<extensions-test-templates, プロバイダ>> が返す実行コンテキストの数に応じて、複数回呼び出されます。このメソッドは、_オーバーライド_ されない限り、_継承_ されます。
| `@DisplayName`       | テストクラスやテストメソッドにカスタムの表示名を指定します。このアノテーションは、_継承_ されません。
| `@BeforeEach`        | このメソッドが、現在のクラスの `@Test`, `@RepeatedTest`, `@ParameterizedTest`, `@TestFactory` メソッドの _前に毎回_ 実行されるよう指定します。JUnit 4の `@Before` と同じです。このメソッドは、_オーバーライド_ されない限り、_継承_ されます。
| `@AfterEach`         | このメソッドが、現在のクラスの `@Test`, `@RepeatedTest`, `@ParameterizedTest`, `@TestFactory` メソッドの _後に毎回_ 実行されるよう指定します。JUnit 4の `@After` と同じです。このメソッドは、_オーバーライド_ されない限り、_継承_ されます。
| `@BeforeAll`         | このメソッドが、現在のクラスの *すべての* `@Test`, `@RepeatedTest`, `@ParameterizedTest`, `@TestFactory` メソッドの _前に一度だけ_ 実行されるよう指定します。JUnit 4の `@BeforeClass` と同じです。 このメソッドは、（_隠す_ か _オーバーライドする_ かしない限り）_継承_ されますが、（<<writing-tests-test-instance-lifecycle, テストインスタンスのライフサイクル>> に "per-class" が使われない限り）`static` でなければいけません。
| `@AfterAll`          | このメソッドが、現在のクラスの *すべての* `@Test`, `@RepeatedTest`, `@ParameterizedTest`, `@TestFactory` メソッドの _後に一度だけ_ 実行されるよう指定します。JUnit 4の `@AfterClass` と同じです。このメソッドは、（_隠す_ か _オーバーライドする_ かしない限り）_継承_ されますが、（<<writing-tests-test-instance-lifecycle, テストインスタンスのライフサイクル>> に "per-class" が使われない限り）`static` でなければいけません。
| `@Nested`            | このクラスが、ネストした非staticのテストクラスであることを示します。 `@BeforeAll` および `@AfterAll` メソッドは、<<writing-tests-test-instance-lifecycle, テストインスタンスのライフサイクル>> に "per-class" が使われない限り、`@Nested` テストクラスの中で直接使うことはできません。このアノテーションは、_継承_ されません。
| `@Tag`               | クラスまたはメソッドレベルでテストをフィルタリングするための _タグ_ を宣言するのに使われます。TestNGのテストグループやJUnit 4のCategoryと同じです。このアノテーションは、クラスレベルでは _継承_ されますが、メソッドレベルでは _継承_ されません。
| `@Disabled`          | テストクラスやテストメソッドを _無効化_ するのに使われます。JUnit 4の `@Ignore` と同じです。このアノテーションは、_継承_ されません。
| `@ExtendWith`        | カスタムの <<extensions, 拡張機能>> を登録するために使われます。このアノテーションは、_継承_ されます。
|===

`@Test`, `@TestTemplate`, `@RepeatedTest`, `@BeforeAll`, `@AfterAll`, `@BeforeEach`, `@AfterEach`
アノテーションの付与されたメソッドは、戻り値を返してはいけません。

WARNING: いくつかのアノテーションは現在 _実験中_ です。詳細は、
<<api-evolution-experimental-apis>> のテーブルを参照してください。

[[writing-tests-meta-annotations]]
==== メタアノテーションと合成アノテーション

JUnit Jupiterアノテーションは、_メタアノテーション_ として使うことができます。つまり、
メタアノテーションの意味を自動的に _継承_ した独自の _合成アノテーション_ を作れるということです。

例えば、`@Tag("fast")` をコードベース全体にコピー＆ペーストする代わりに
（<<writing-tests-tagging-and-filtering>> 参照）、以下の `@Fast`
のような名前のカスタム _合成アノテーション_ を作ることができます。
`@Fast` は、`@Tag("fast")` の代わりに使うことができます。

[source,java,indent=0]
----
include::{testDir}/example/Fast.java[tags=user_guide]
----

[[writing-tests-standard]]
=== 標準的なテストクラス

[source,java,indent=0]
.標準的なテストケース
----
include::{testDir}/example/StandardTests.java[tags=user_guide]
----

NOTE: テストクラスやテストメソッドは、 `public` である必要がありません。

[[writing-tests-display-names]]
=== 表示名

テストクラスやテストメソッドは、カスタムの表示名を宣言できます。
空白や特殊文字だけでなく絵文字も含めることができ、テストランナーやテストレポートに表示されます。

[source,java,indent=0]
----
include::{testDir}/example/DisplayNameDemo.java[tags=user_guide]
----

[[writing-tests-assertions]]
=== アサーション

JUnit Jupiterは、JUnit 4にあった多くのアサーションメソッドをもち、
Java 8のラムダ式と一緒に使いやすいものもいくつか追加しています。
すべてのJUnit Jupiterアサーションは、 `{Assertions}` クラスの `static` メソッドです。

[source,java,indent=0]
----
include::{testDir}/example/AssertionsDemo.java[tags=user_guide]
----

JUnit Jupiterは、 https://kotlinlang.org/[Kotlin]
と一緒に使いやすいアサーションもいくつか含んでいます。すべてのJUnit Jupiter Kotlinアサーションは、
`org.junit.jupiter.api` パッケージのトップレベル関数です。

// TODO: Change to using kotlin language highlighting after switch to rouge syntax highlighter
[source,groovy,indent=0]
----
include::{kotlinTestDir}/example/AssertionsDemoKotlin.kt[tags=user_guide]
----

[[writing-tests-assertions-third-party]]
==== サードパーティーのアサーションライブラリ

多くのテストシナリオではJUnit Jupiterが提供するアサーション機能だけで十分ですが、
時にはさらなるパワーや _マッチャー_ のような追加機能が必要になることもあります。
そのような場合には、 {AssertJ} や {Hamcrest}、 {Truth} のようなサードパーティーの
アサーションライブラリを使うことをJUnitチームはお勧めします。
開発者は、好みに応じてアサーションライブラリを自由に選択することができます。

例えば、 _マッチャー_ と流れるようなAPIを組み合わせれば、アサーションをもっと説明的で
読みやすくすることができます。しかし、JUnit Jupiterの `{Assertions}` クラスは、
JUnit 4の `org.junit.Assert` クラスのようにHamcrestの
http://junit.org/junit4/javadoc/latest/org/hamcrest/Matcher.html[`Matcher`]
を受け付ける
http://junit.org/junit4/javadoc/latest/org/junit/Assert.html#assertThat[`assertThat()`]
メソッドを提供していません。代わりに、開発者はサードパーティーのアサーションライブラリが
提供するマッチャーを利用することが推奨されます。

次の例は、JUnit JupiterテストでHamcrestの `assertThat()` を使う方法を示しています。
Hamcrestライブラリをクラスパスに追加しさえすれば、 `assertThat()` や `is()`、 `equalTo()`
のようなメソッドをstatic importして、下の `assertWithHamcrestMatcher()` メソッドのように
テストの中で使うことができます。

[source,java,indent=0]
----
include::{testDir}/example/HamcrestAssertionDemo.java[tags=user_guide]
----

当然ながら、JUnit 4のプログラミングモデルに基づくレガシーなテストでは、引き続き
`org.junit.Assert#assertThat` を使い続けることができます。

[[writing-tests-assumptions]]
=== 前提条件

JUnit Jupiterは、JUnit 4が提供する前提条件用メソッドの一部を備え、
Java 8のラムダ式と一緒に使いやすいものをいくつか追加しています。
JUnit Jupiterの前提条件メソッドは、すべて `{Assumptions}` クラスのstaticメソッドです。

[source,java,indent=0]
----
include::{testDir}/example/AssumptionsDemo.java[tags=user_guide]
----

[[writing-tests-disabling]]
=== テストの無効化

テストクラス全体または個々のテストメソッドは、 `{Disabled}` アノテーションや
<<writing-tests-conditional-execution>> で説明するアノテーション、
あるいはカスタムの <<extensions-conditions, `ExecutionCondition`>>
によって _無効化_ することができます。

次の例は、`@Disabled` されたテストクラスです。

[source,java,indent=0]
----
include::{testDir}/example/DisabledClassDemo.java[tags=user_guide]
----

そして次の例は、`@Disabled` されたテストメソッドをもつテストクラスです。

[source,java,indent=0]
----
include::{testDir}/example/DisabledTestsDemo.java[tags=user_guide]
----

[[writing-tests-conditional-execution]]
=== 条件付きテスト実行

JUnit Jupiterの <<extensions-conditions, `ExecutionCondition`>> 拡張APIは、
開発者がある一定の条件にもとづいて _手続き的に_  コンテナやテストを有効化したり、
無効化したりすることができるようにします。
簡単な例は、`{Disabled}` アノテーションをサポートする `{DisabledCondition}` です
（<<writing-tests-disabling>> 参照）。

JUnit Jupiterは、`org.junit.jupiter.api.condition` パッケージで `@Disabled`
以外にもアノテーションベースの条件をサポートしています。これにより、開発者は _宣言的に_
コンテナやテストを有効化したり、無効化したりすることができます。
詳細は、以降の節を参照してください。

[TIP]
.合成アノテーション
====
以降で説明するいずれの _条件_ アノテーションも、カスタムの _合成アノテーション_
を作るためのメタアノテーションとして使われうる点に注意してください。例えば、
<<writing-tests-conditional-execution-os-demo, @EnabledOnOsデモ>> の `@TestOnMac`
アノテーションは、`@Test` と `@EnabledOnOs` を1つの再利用可能なアノテーションとして
組み合わせる方法を示しています。
====

[WARNING]
====
以降の節で取り上げられる _条件_ アノテーションは、あるテストインターフェースやテストクラス、
テストメソッドに対して一度しか宣言できません。条件アノテーションがある要素に対して直接、
間接、あるいはメタアノテーションで複数回指定されたとしても、JUnitが最初に見つけた
アノテーションだけが使われます。その他のアノテーションは、黙って無視されます。ただし、
`org.junit.jupiter.api.condition` パッケージのそれぞれの条件アノテーションは、
組み合わせて使うことができる点に注意してください。
====

[[writing-tests-conditional-execution-os]]
==== オペレーティングシステム条件

`{EnabledOnOs}` および `{DisabledOnOs}` アノテーションを使うと、
コンテナやテストを特定のオペレーティングシステムで有効にしたり無効にしたりできます。

[[writing-tests-conditional-execution-os-demo]]
[source,java,indent=0]
----
include::{testDir}/example/ConditionalTestExecutionDemo.java[tags=user_guide_os]
----

[[writing-tests-conditional-execution-jre]]
==== Javaランタイム環境条件

`{EnabledOnJre}` および `{DisabledOnJre}` アノテーションを使うと、
コンテナやテストを特定のバージョンのJavaランタイム環境（JRE）で有効にしたり無効にしたりできます。

[source,java,indent=0]
----
include::{testDir}/example/ConditionalTestExecutionDemo.java[tags=user_guide_jre]
----

[[writing-tests-conditional-execution-system-properties]]
==== システムプロパティ条件

`{EnabledIfSystemProperty}` および `{DisabledIfSystemProperty}` アノテーションを使うと、
指定した名前をもつJVMシステムプロパティの値に応じて、コンテナやテストを有効にしたり
無効にしたりできます。 `matches` 属性で指定する値は、正規表現として解釈されます。

[source,java,indent=0]
----
include::{testDir}/example/ConditionalTestExecutionDemo.java[tags=user_guide_system_property]
----

[[writing-tests-conditional-execution-environment-variables]]
==== 環境変数条件

`{EnabledIfEnvironmentVariable}` および `{DisabledIfEnvironmentVariable}`
アノテーションを使うと、指定した名前をもつ環境変数の値に応じて、コンテナやテストを
有効にしたり無効にしたりできます。`matches` 属性で指定する値は、正規表現として解釈されます。

[source,java,indent=0]
----
include::{testDir}/example/ConditionalTestExecutionDemo.java[tags=user_guide_environment_variable]
----

[[writing-tests-conditional-execution-scripts]]
==== スクリプトベースの条件

JUnit Jupiterは、`{EnabledIf}` または `{DisabledIf}` アノテーションで設定された
スクリプトの実行結果に応じて、コンテナやテストを有効にしたり無効にしたりする機能を提供します。
スクリプトは、JavaScript、Groovy、あるいはJSR 223で定義されたJava Scripting API
をサポートする任意の言語で記述することができます。

WARNING: `{EnabledIf}` および `{DisabledIf}` を使った条件付きテスト実行は、
現在 _試験的な_ 機能です。詳細は、<<api-evolution-experimental-apis>>
のテーブルを参考にしてください。

TIP: もしスクリプトのロジックが現在のオペレーティングシステムやJavaランタイム環境の
バージョン、特定のJVMシステムプロパティや環境変数だけに依存するなら、その目的専用の
組み込みアノテーションの使用を検討すべきです。詳細は、この章の前の節を参照してください。

NOTE: もし同じようなスクリプトベースの条件を何回も使っていると感じたら、
高速かつタイプセーフで、よりメンテナンスしやすい方法で実装するために、専用の
<<extensions-conditions, ExecutionCondition>> 拡張を書くことを検討してください。

[source,java,indent=0]
----
include::{testDir}/example/ConditionalTestExecutionDemo.java[tags=user_guide_scripts]
----

[[writing-tests-conditional-execution-scripts-bindings]]
===== スクリプトバインディング

以下の名前は、スクリプトのコンテキストに束縛されるため、スクリプト内で使うことができます。
_accessor_ は、単純な `String get(String name)` メソッドを介したマップ構造への
アクセスを提供します。

[cols="25,25,75"]
|===
| Name                          | Type          | Description

| `systemEnvironment`           | _accessor_    | オペレーティングシステムの環境変数へのアクセッサ
| `systemProperty`              | _accessor_    | JVMのシステムプロパティへのアクセッサ
| `junitConfigurationParameter` | _accessor_    | 構成パラメーターへのアクセッサ
| `junitDisplayName`            | `String`      | テストやコンテナの表示名
| `junitTags`                   | `Set<String>` | テストやコンテナにアサインされたすべてのタグ
| `junitUniqueId`               | `String`      | テストやコンテナの一意なID
|===


[[writing-tests-tagging-and-filtering]]
=== タグとフィルタリング

テストクラスとテストメソッドには、`@Tag` アノテーションでタグを付与することができます。
これらのタグはあとで <<running-tests, テストを発見・実行>> するときのフィルタリングに
使うことができます。

==== タグの構文規則

* タグは、`null` または _空_ であってはならない
* _トリミングした_ タグは、空白文字を含んではならない
* _トリミングした_ タグは、ISO制御文字を含んではならない
* _トリミングした_ タグは、次の _予約済み文字_ を含んではならない
  - `,`: _カンマ_
  - `(`: _左括弧_
  - `)`: _右括弧_
  - `&`: _アンパサンド_
  - `|`: _縦棒_
  - `!`: _感嘆符_

NOTE: 上のコンテキストで "トリミングした" とは、先頭および末尾の空白文字が
取り除かれていることを意味する。

[source,java,indent=0]
----
include::{testDir}/example/TaggingDemo.java[tags=user_guide]
----

[[writing-tests-test-instance-lifecycle]]
=== Test Instance Lifecycle

In order to allow individual test methods to be executed in isolation and to avoid
unexpected side effects due to mutable test instance state, JUnit creates a new instance
of each test class before executing each _test_ method (see note below for what qualifies
as a _test_ method). This "per-method" test instance lifecycle is the default behavior in
JUnit Jupiter and is analogous to all previous versions of JUnit.

If you would prefer that JUnit Jupiter execute all test methods on the same test
instance, simply annotate your test class with `@TestInstance(Lifecycle.PER_CLASS)`. When
using this mode, a new test instance will be created once per test class. Thus, if your
test methods rely on state stored in instance variables, you may need to reset that state
in `@BeforeEach` or `@AfterEach` methods.

The "per-class" mode has some additional benefits over the default "per-method" mode.
Specifically, with the "per-class" mode it becomes possible to declare `@BeforeAll` and
`@AfterAll` on non-static methods as well as on interface `default` methods. The
"per-class" mode therefore also makes it possible to use `@BeforeAll` and `@AfterAll`
methods in `@Nested` test classes.

If you are authoring tests using the Kotlin programming language, you may also find it
easier to implement `@BeforeAll` and `@AfterAll` methods by switching to the "per-class"
test instance lifecycle mode.

NOTE: In the context of test instance lifecycle a _test_ method is any method annotated
with `@Test`, `@RepeatedTest`, `@ParameterizedTest`, `@TestFactory`, or `@TestTemplate`.

[[writing-tests-test-instance-lifecycle-changing-default]]
==== Changing the Default Test Instance Lifecycle

If a test class or test interface is not annotated with `@TestInstance`, JUnit Jupiter
will use a _default_ lifecycle mode. The standard _default_ mode is `PER_METHOD`;
however, it is possible to change the _default_ for the execution of an entire test plan.
To change the default test instance lifecycle mode, simply set the
`junit.jupiter.testinstance.lifecycle.default` _configuration parameter_ to the name of
an enum constant defined in `TestInstance.Lifecycle`, ignoring case. This can be supplied
as a JVM system property, as a _configuration parameter_ in the
`LauncherDiscoveryRequest` that is passed to the `Launcher`, or via the JUnit Platform
configuration file (see <<running-tests-config-params>> for details).

For example, to set the default test instance lifecycle mode to `Lifecycle.PER_CLASS`,
you can start your JVM with the following system property.

`-Djunit.jupiter.testinstance.lifecycle.default=per_class`

Note, however, that setting the default test instance lifecycle mode via the JUnit
Platform configuration file is a more robust solution since the configuration file can be
checked into a version control system along with your project and can therefore be used
within IDEs and your build software.

To set the default test instance lifecycle mode to `Lifecycle.PER_CLASS` via the JUnit
Platform configuration file, create a file named `junit-platform.properties` in the root
of the class path (e.g., `src/test/resources`) with the following content.

`junit.jupiter.testinstance.lifecycle.default = per_class`

WARNING: Changing the _default_ test instance lifecycle mode can lead to unpredictable
results and fragile builds if not applied consistently. For example, if the build
configures "per-class" semantics as the default but tests in the IDE are executed using
"per-method" semantics, that can make it difficult to debug errors that occur on the
build server. It is therefore recommended to change the default in the JUnit Platform
configuration file instead of via a JVM system property.

[[writing-tests-nested]]
=== Nested Tests

Nested tests give the test writer more capabilities to express the relationship among
several group of tests. Here's an elaborate example.

[source,java,indent=0]
.Nested test suite for testing a stack
----
include::{testDir}/example/TestingAStackDemo.java[tags=user_guide]
----

NOTE: _Only non-static nested classes_ (i.e. _inner classes_) can serve as `@Nested` test
classes. Nesting can be arbitrarily deep, and those inner classes are considered to be
full members of the test class family with one exception: `@BeforeAll` and `@AfterAll`
methods do not work _by default_. The reason is that Java does not allow `static` members
in inner classes. However, this restriction can be circumvented by annotating a `@Nested`
test class with `@TestInstance(Lifecycle.PER_CLASS)` (see
<<writing-tests-test-instance-lifecycle>>).

[[writing-tests-dependency-injection]]
=== Dependency Injection for Constructors and Methods

In all prior JUnit versions, test constructors or methods were not allowed to have
parameters (at least not with the standard `Runner` implementations). As one of the major
changes in JUnit Jupiter, both test constructors and methods are now permitted to have
parameters. This allows for greater flexibility and enables _Dependency Injection_ for
constructors and methods.

`{ParameterResolver}` defines the API for test extensions that wish to _dynamically_
resolve parameters at runtime. If a test constructor or a `@Test`, `@TestFactory`,
`@BeforeEach`, `@AfterEach`, `@BeforeAll`, or `@AfterAll` method accepts a parameter, the
parameter must be resolved at runtime by a registered `ParameterResolver`.

There are currently three built-in resolvers that are registered automatically.

* `{TestInfoParameterResolver}`: if a method parameter is of type `{TestInfo}`, the
  `TestInfoParameterResolver` will supply an instance of `TestInfo` corresponding to the
  current test as the value for the parameter. The `TestInfo` can then be used to retrieve
  information about the current test such as the test's display name, the test class, the
  test method, or associated tags. The display name is either a technical name, such as
  the name of the test class or test method, or a custom name configured via `@DisplayName`.
+
`{TestInfo}` acts as a drop-in replacement for the `TestName` rule from JUnit 4. The
following demonstrates how to have `TestInfo` injected into a test constructor,
`@BeforeEach` method, and `@Test` method.

[source,java,indent=0]
----
include::{testDir}/example/TestInfoDemo.java[tags=user_guide]
----

* `RepetitionInfoParameterResolver`: if a method parameter in a `@RepeatedTest`,
  `@BeforeEach`, or `@AfterEach` method is of type `{RepetitionInfo}`, the
  `RepetitionInfoParameterResolver` will supply an instance of `RepetitionInfo`.
  `RepetitionInfo` can then be used to retrieve information about the current repetition
  and the total number of repetitions for the corresponding `@RepeatedTest`. Note,
  however, that `RepetitionInfoParameterResolver` is not registered outside the context
  of a `@RepeatedTest`. See <<writing-tests-repeated-tests-examples>>.

* `{TestReporterParameterResolver}`: if a method parameter is of type `{TestReporter}`,
  the `TestReporterParameterResolver` will supply an instance of `TestReporter`. The
  `TestReporter` can be used to publish additional data about the current test run. The
  data can be consumed through `{TestExecutionListener}.reportingEntryPublished()` and
  thus be viewed by IDEs or included in reports.
+
In JUnit Jupiter you should use `TestReporter` where you used to print information to
`stdout` or `stderr` in JUnit 4. Using `@RunWith(JUnitPlatform.class)` will even output
all reported entries to `stdout`.

[source,java,indent=0]
----
include::{testDir}/example/TestReporterDemo.java[tags=user_guide]
----

NOTE: Other parameter resolvers must be explicitly enabled by registering appropriate
<<extensions,extensions>> via `@ExtendWith`.

Check out the `{MockitoExtension}` for an example of a custom `{ParameterResolver}`.
While not intended to be production-ready, it demonstrates the simplicity and
expressiveness of both the extension model and the parameter resolution process.
`MyMockitoTest` demonstrates how to inject Mockito mocks into `@BeforeEach` and `@Test`
methods.

[source,java,indent=0]
----
import static org.junit.jupiter.api.Assertions.assertEquals;
import static org.mockito.Mockito.when;

import org.junit.jupiter.api.BeforeEach;
import org.junit.jupiter.api.Test;
import org.junit.jupiter.api.extension.ExtendWith;
import org.mockito.Mock;
import com.example.Person;
import com.example.mockito.MockitoExtension;

@ExtendWith(MockitoExtension.class)
class MyMockitoTest {

	@BeforeEach
	void init(@Mock Person person) {
		when(person.getName()).thenReturn("Dilbert");
	}

	@Test
	void simpleTestWithInjectedMock(@Mock Person person) {
		assertEquals("Dilbert", person.getName());
	}

}
----

[[writing-tests-test-interfaces-and-default-methods]]
=== Test Interfaces and Default Methods

JUnit Jupiter allows `@Test`, `@RepeatedTest`, `@ParameterizedTest`, `@TestFactory`,
`@TestTemplate`, `@BeforeEach`, and `@AfterEach` to be declared on interface `default`
methods. `@BeforeAll` and `@AfterAll` can either be declared on `static` methods in a
test interface or on interface `default` methods _if_ the test interface or test class is
annotated with `@TestInstance(Lifecycle.PER_CLASS)` (see
<<writing-tests-test-instance-lifecycle>>). Here are some examples.

[source,java]
----
include::{testDir}/example/testinterface/TestLifecycleLogger.java[tags=user_guide]
----

[source,java]
----
include::{testDir}/example/testinterface/TestInterfaceDynamicTestsDemo.java[tags=user_guide]
----

`@ExtendWith` and `@Tag` can be declared on a test interface so that classes that
implement the interface automatically inherit its tags and extensions. See
<<extensions-lifecycle-callbacks-before-after-execution>> for the source code of the
<<extensions-lifecycle-callbacks-timing-extension, TimingExtension>>.

[source,java]
----
include::{testDir}/example/testinterface/TimeExecutionLogger.java[tags=user_guide]
----

In your test class you can then implement these test interfaces to have them applied.

[source,java]
----
include::{testDir}/example/testinterface/TestInterfaceDemo.java[tags=user_guide]
----

Running the `TestInterfaceDemo` results in output similar to the following:

....
:junitPlatformTest
INFO  example.TestLifecycleLogger - Before all tests
INFO  example.TestLifecycleLogger - About to execute [dynamicTestsFromCollection()]
INFO  example.TimingExtension - Method [dynamicTestsFromCollection] took 13 ms.
INFO  example.TestLifecycleLogger - Finished executing [dynamicTestsFromCollection()]
INFO  example.TestLifecycleLogger - About to execute [isEqualValue()]
INFO  example.TimingExtension - Method [isEqualValue] took 1 ms.
INFO  example.TestLifecycleLogger - Finished executing [isEqualValue()]
INFO  example.TestLifecycleLogger - After all tests

Test run finished after 190 ms
[         3 containers found      ]
[         0 containers skipped    ]
[         3 containers started    ]
[         0 containers aborted    ]
[         3 containers successful ]
[         0 containers failed     ]
[         3 tests found           ]
[         0 tests skipped         ]
[         3 tests started         ]
[         0 tests aborted         ]
[         3 tests successful      ]
[         0 tests failed          ]

BUILD SUCCESSFUL
....

Another possible application of this feature is to write tests for interface contracts.
For example, you can write tests for how implementations of `Object.equals` or
`Comparable.compareTo` should behave as follows.

[source,java]
----
include::{testDir}/example/defaultmethods/Testable.java[tags=user_guide]
----

[source,java]
----
include::{testDir}/example/defaultmethods/EqualsContract.java[tags=user_guide]
----

[source,java]
----
include::{testDir}/example/defaultmethods/ComparableContract.java[tags=user_guide]
----

In your test class you can then implement both contract interfaces thereby inheriting the
corresponding tests. Of course you'll have to implement the abstract methods.

[source,java]
----
include::{testDir}/example/defaultmethods/StringTests.java[tags=user_guide]
----

NOTE: The above tests are merely meant as examples and therefore not complete.


[[writing-tests-repeated-tests]]
=== Repeated Tests

JUnit Jupiter provides the ability to repeat a test a specified number of times simply by
annotating a method with `@RepeatedTest` and specifying the total number of repetitions
desired. Each invocation of a repeated test behaves like the execution of a regular
`@Test` method with full support for the same lifecycle callbacks and extensions.

The following example demonstrates how to declare a test named `repeatedTest()` that
will be automatically repeated 10 times.

[source,java]
----
@RepeatedTest(10)
void repeatedTest() {
	// ...
}
----

In addition to specifying the number of repetitions, a custom display name can be
configured for each repetition via the `name` attribute of the `@RepeatedTest`
annotation. Furthermore, the display name can be a pattern composed of a combination of
static text and dynamic placeholders. The following placeholders are currently supported.

- `{displayName}`: display name of the `@RepeatedTest` method
- `{currentRepetition}`: the current repetition count
- `{totalRepetitions}`: the total number of repetitions

The default display name for a given repetition is generated based on the following
pattern: `"repetition {currentRepetition} of {totalRepetitions}"`. Thus, the display
names for individual repetitions of the previous `repeatedTest()` example would be:
`repetition 1 of 10`, `repetition 2 of 10`, etc. If you would like the display name of
the `@RepeatedTest` method included in the name of each repetition, you can define your
own custom pattern or use the predefined `RepeatedTest.LONG_DISPLAY_NAME` pattern. The
latter is equal to `"{displayName} :: repetition {currentRepetition} of
{totalRepetitions}"` which results in display names for individual repetitions like
`repeatedTest() :: repetition 1 of 10`, `repeatedTest() :: repetition 2 of 10`, etc.

In order to retrieve information about the current repetition and the total number of
repetitions programmatically, a developer can choose to have an instance of
`RepetitionInfo` injected into a `@RepeatedTest`, `@BeforeEach`, or `@AfterEach` method.

[[writing-tests-repeated-tests-examples]]
==== Repeated Test Examples

The `RepeatedTestsDemo` class at the end of this section demonstrates several examples of
repeated tests.

The `repeatedTest()` method is identical to example from the previous section; whereas,
`repeatedTestWithRepetitionInfo()` demonstrates how to have an instance of
`RepetitionInfo` injected into a test to access the total number of repetitions for the
current repeated test.

The next two methods demonstrate how to include a custom `@DisplayName` for the
`@RepeatedTest` method in the display name of each repetition. `customDisplayName()`
combines a custom display name with a custom pattern and then uses `TestInfo` to verify
the format of the generated display name. `Repeat!` is the `{displayName}` which comes
from the `@DisplayName` declaration, and `1/1` comes from
`{currentRepetition}/{totalRepetitions}`. In contrast,
`customDisplayNameWithLongPattern()` uses the aforementioned predefined
`RepeatedTest.LONG_DISPLAY_NAME` pattern.

`repeatedTestInGerman()` demonstrates the ability to translate display names of repeated
tests into foreign languages -- in this case German, resulting in names for individual
repetitions such as: `Wiederholung 1 von 5`, `Wiederholung 2 von 5`, etc.

Since the `beforeEach()` method is annotated with `@BeforeEach` it will get executed
before each repetition of each repeated test. By having the `TestInfo` and
`RepetitionInfo` injected into the method, we see that it's possible to obtain
information about the currently executing repeated test. Executing `RepeatedTestsDemo`
with the `INFO` log level enabled results in the following output.

....
INFO: About to execute repetition 1 of 10 for repeatedTest
INFO: About to execute repetition 2 of 10 for repeatedTest
INFO: About to execute repetition 3 of 10 for repeatedTest
INFO: About to execute repetition 4 of 10 for repeatedTest
INFO: About to execute repetition 5 of 10 for repeatedTest
INFO: About to execute repetition 6 of 10 for repeatedTest
INFO: About to execute repetition 7 of 10 for repeatedTest
INFO: About to execute repetition 8 of 10 for repeatedTest
INFO: About to execute repetition 9 of 10 for repeatedTest
INFO: About to execute repetition 10 of 10 for repeatedTest
INFO: About to execute repetition 1 of 5 for repeatedTestWithRepetitionInfo
INFO: About to execute repetition 2 of 5 for repeatedTestWithRepetitionInfo
INFO: About to execute repetition 3 of 5 for repeatedTestWithRepetitionInfo
INFO: About to execute repetition 4 of 5 for repeatedTestWithRepetitionInfo
INFO: About to execute repetition 5 of 5 for repeatedTestWithRepetitionInfo
INFO: About to execute repetition 1 of 1 for customDisplayName
INFO: About to execute repetition 1 of 1 for customDisplayNameWithLongPattern
INFO: About to execute repetition 1 of 5 for repeatedTestInGerman
INFO: About to execute repetition 2 of 5 for repeatedTestInGerman
INFO: About to execute repetition 3 of 5 for repeatedTestInGerman
INFO: About to execute repetition 4 of 5 for repeatedTestInGerman
INFO: About to execute repetition 5 of 5 for repeatedTestInGerman
....

[source,java]
----
include::{testDir}/example/RepeatedTestsDemo.java[tags=user_guide]
----

When using the `ConsoleLauncher` or the `junitPlatformTest` Gradle plugin with the
unicode theme enabled, execution of `RepeatedTestsDemo` results in the following output
to the console.

....
├─ RepeatedTestsDemo ✔
│  ├─ repeatedTest() ✔
│  │  ├─ repetition 1 of 10 ✔
│  │  ├─ repetition 2 of 10 ✔
│  │  ├─ repetition 3 of 10 ✔
│  │  ├─ repetition 4 of 10 ✔
│  │  ├─ repetition 5 of 10 ✔
│  │  ├─ repetition 6 of 10 ✔
│  │  ├─ repetition 7 of 10 ✔
│  │  ├─ repetition 8 of 10 ✔
│  │  ├─ repetition 9 of 10 ✔
│  │  └─ repetition 10 of 10 ✔
│  ├─ repeatedTestWithRepetitionInfo(RepetitionInfo) ✔
│  │  ├─ repetition 1 of 5 ✔
│  │  ├─ repetition 2 of 5 ✔
│  │  ├─ repetition 3 of 5 ✔
│  │  ├─ repetition 4 of 5 ✔
│  │  └─ repetition 5 of 5 ✔
│  ├─ Repeat! ✔
│  │  └─ Repeat! 1/1 ✔
│  ├─ Details... ✔
│  │  └─ Details... :: repetition 1 of 1 ✔
│  └─ repeatedTestInGerman() ✔
│     ├─ Wiederholung 1 von 5 ✔
│     ├─ Wiederholung 2 von 5 ✔
│     ├─ Wiederholung 3 von 5 ✔
│     ├─ Wiederholung 4 von 5 ✔
│     └─ Wiederholung 5 von 5 ✔
....


[[writing-tests-parameterized-tests]]
=== Parameterized Tests

Parameterized tests make it possible to run a test multiple times with different
arguments. They are declared just like regular `@Test` methods but use the
`{ParameterizedTest}` annotation instead. In addition, you must declare at least one
_source_ that will provide the arguments for each invocation.

WARNING: Parameterized tests are currently an _experimental_ feature. Consult the table
in <<api-evolution-experimental-apis>> for details.

[source,java,indent=0]
----
include::{testDir}/example/ParameterizedTestDemo.java[tags=first_example]
----

This parameterized test uses the `@ValueSource` annotation to specify a `String` array as
the source of arguments. When executing the above method, each invocation will be
reported separately. For instance, the `ConsoleLauncher` will print output similar to the
following.

....
palindromes(String) ✔
├─ [1] racecar ✔
├─ [2] radar ✔
└─ [3] able was I ere I saw elba ✔
....

[[writing-tests-parameterized-tests-setup]]
==== Required Setup

In order to use parameterized tests you need to add a dependency on the
`junit-jupiter-params` artifact. Please refer to <<dependency-metadata>> for details.

[[writing-tests-parameterized-tests-sources]]
==== Sources of Arguments

Out of the box, JUnit Jupiter provides quite a few _source_ annotations. Each of the
following subsections provides a brief overview and an example for each of them. Please
refer to the JavaDoc in the `{params-provider-package}` package for additional
information.

[[writing-tests-parameterized-tests-sources-ValueSource]]
===== @ValueSource

`@ValueSource` is one of the simplest possible sources. It lets you specify a single
array of literal values and can only be used for providing a single parameter per
parameterized test invocation.

The following types of literal values are supported by `@ValueSource`.

- `short`
- `byte`
- `int`
- `long`
- `float`
- `double`
- `char`
- `java.lang.String`
- `java.lang.Class`

For example, the following `@ParameterizedTest` method will be invoked three times, with
the values `1`, `2`, and `3` respectively.

[source,java,indent=0]
----
include::{testDir}/example/ParameterizedTestDemo.java[tags=ValueSource_example]
----

[[writing-tests-parameterized-tests-sources-EnumSource]]
===== @EnumSource

`@EnumSource` provides a convenient way to use `Enum` constants. The annotation provides
an optional `names` parameter that lets you specify which constants shall be used. If
omitted, all constants will be used like in the following example.

[source,java,indent=0]
----
include::{testDir}/example/ParameterizedTestDemo.java[tags=EnumSource_example]
----

[source,java,indent=0]
----
include::{testDir}/example/ParameterizedTestDemo.java[tags=EnumSource_include_example]
----

The `@EnumSource` annotation also provides an optional `mode` parameter that enables
fine-grained control over which constants are passed to the test method. For example, you
can exclude names from the enum constant pool or specify regular expressions as in the
following examples.

[source,java,indent=0]
----
include::{testDir}/example/ParameterizedTestDemo.java[tags=EnumSource_exclude_example]
----

[source,java,indent=0]
----
include::{testDir}/example/ParameterizedTestDemo.java[tags=EnumSource_regex_example]
----

[[writing-tests-parameterized-tests-sources-MethodSource]]
===== @MethodSource

`@MethodSource` allows you to refer to one or more _factory_ methods of the test class.
Such methods must return a `Stream`, `Iterable`, `Iterator`, or array of arguments. In
addition, such methods must not accept any arguments. By default such methods must be
`static` unless the test class is annotated with `@TestInstance(Lifecycle.PER_CLASS)`.

If you only need a single parameter, you can return a `Stream` of instances of the
parameter type as demonstrated by the following example.

[source,java,indent=0]
----
include::{testDir}/example/ParameterizedTestDemo.java[tags=simple_MethodSource_example]
----

If you do not explicitly provide a factory method name via `@MethodSource`, JUnit Jupiter
will search for a _factory_ method that has the same name as the current
`@ParameterizedTest` method by convention. This is demonstrated in the following example.

[source,java,indent=0]
----
include::{testDir}/example/ParameterizedTestDemo.java[tags=simple_MethodSource_without_value_example]
----

Streams for primitive types (`DoubleStream`, `IntStream`, and `LongStream`) are also
supported as demonstrated by the following example.

[source,java,indent=0]
----
include::{testDir}/example/ParameterizedTestDemo.java[tags=primitive_MethodSource_example]
----

If a test method declares multiple parameters, you need to return a collection or stream
of `Arguments` instances as shown below. Note that `Arguments.of(Object...)` is a static
factory method defined in the `Arguments` interface.

[source,java,indent=0]
----
include::{testDir}/example/ParameterizedTestDemo.java[tags=multi_arg_MethodSource_example]
----

[[writing-tests-parameterized-tests-sources-CsvSource]]
===== @CsvSource

`@CsvSource` allows you to express argument lists as comma-separated values (i.e.,
`String` literals).

[source,java,indent=0]
----
include::{testDir}/example/ParameterizedTestDemo.java[tags=CsvSource_example]
----

`@CsvSource` uses a single quote `'` as its quote character. See the `'baz, qux'` value
in the example above and in the table below. An empty, quoted value `''` results in an
empty `String`; whereas, an entirely _empty_ value is interpreted as a `null` reference.
An `ArgumentConversionException` is raised if the target type of a `null` reference is a
primitive type.

[cols="50,50"]
|===
| Example Input                        | Resulting Argument List

| `@CsvSource({ "foo, bar" })`         | `"foo"`, `"bar"`
| `@CsvSource({ "foo, 'baz, qux'" })`  | `"foo"`, `"baz, qux"`
| `@CsvSource({ "foo, ''" })`          | `"foo"`, `""`
| `@CsvSource({ "foo, " })`            | `"foo"`, `null`
|===

[[writing-tests-parameterized-tests-sources-CsvFileSource]]
===== @CsvFileSource

`@CsvFileSource` lets you use CSV files from the classpath. Each line from a CSV file
results in one invocation of the parameterized test.

[source,java,indent=0]
----
include::{testDir}/example/ParameterizedTestDemo.java[tags=CsvFileSource_example]
----

[source,csv,indent=0]
.two-column.csv
----
include::{testResourcesDir}/two-column.csv[]
----

NOTE: In contrast to the syntax used in `@CsvSource`, `@CsvFileSource` uses a double
quote `"` as the quote character. See the `"United States of America"` value in the
example above. An empty, quoted value `""` results in an empty `String`; whereas, an
entirely _empty_ value is interpreted as a `null` reference. An
`ArgumentConversionException` is raised if the target type of a `null` reference is a
primitive type.

[[writing-tests-parameterized-tests-sources-ArgumentsSource]]
===== @ArgumentsSource

`@ArgumentsSource` can be used to specify a custom, reusable `ArgumentsProvider`.

[source,java,indent=0]
----
include::{testDir}/example/ParameterizedTestDemo.java[tags=ArgumentsSource_example]
----


[[writing-tests-parameterized-tests-argument-conversion]]
==== Argument Conversion

[[writing-tests-parameterized-tests-argument-conversion-implicit]]
===== Implicit Conversion

To support use cases like `@CsvSource`, JUnit Jupiter provides a number of built-in
implicit type converters. The conversion process depends on the declared type of each
method parameter.

For example, if a `@ParameterizedTest` declares a parameter of type `TimeUnit` and the
actual type supplied by the declared source is a `String`, the string will be
automatically converted into the corresponding `TimeUnit` enum constant.

[source,java,indent=0]
----
include::{testDir}/example/ParameterizedTestDemo.java[tags=implicit_conversion_example]
----

`String` instances are currently implicitly converted to the following target types.

[[writing-tests-parameterized-tests-argument-conversion-implicit-table]]
[cols="10,90"]
|===
| Target Type | Example

| `boolean`/`Boolean`        | `"true"`                                 -> `true`
| `byte`/`Byte`              | `"1"`                                    -> `(byte) 1`
| `char`/`Character`         | `"o"`                                    -> `'o'`
| `short`/`Short`            | `"1"`                                    -> `(short) 1`
| `int`/`Integer`            | `"1"`                                    -> `1`
| `long`/`Long`              | `"1"`                                    -> `1L`
| `float`/`Float`            | `"1.0"`                                  -> `1.0f`
| `double`/`Double`          | `"1.0"`                                  -> `1.0d`
| `Enum` subclass            | `"SECONDS"`                              -> `TimeUnit.SECONDS`
| `java.io.File`             | `"/path/to/file"`                        -> `new File("/path/to/file")`
| `java.math.BigDecimal`     | `"123.456e789"`                          -> `new BigDecimal("123.456e789")`
| `java.math.BigInteger`     | `"1234567890123456789"`                  -> `new BigInteger("1234567890123456789")`
| `java.net.URI`             | `"http://junit.org/"`                    -> `URI.create("http://junit.org/")`
| `java.net.URL`             | `"http://junit.org/"`                    -> `new URL("http://junit.org/")`
| `java.nio.charset.Charset` | `"UTF-8"`                                -> `Charset.forName("UTF-8")`
| `java.nio.file.Path`       | `"/path/to/file"`                        -> `Paths.get("/path/to/file")`
| `java.time.Instant`        | `"1970-01-01T00:00:00Z"`                 -> `Instant.ofEpochMilli(0)`
| `java.time.LocalDateTime`  | `"2017-03-14T12:34:56.789"`              -> `LocalDateTime.of(2017, 3, 14, 12, 34, 56, 789_000_000)`
| `java.time.LocalDate`      | `"2017-03-14"`                           -> `LocalDate.of(2017, 3, 14)`
| `java.time.LocalTime`      | `"12:34:56.789"`                         -> `LocalTime.of(12, 34, 56, 789_000_000)`
| `java.time.OffsetDateTime` | `"2017-03-14T12:34:56.789Z"`             -> `OffsetDateTime.of(2017, 3, 14, 12, 34, 56, 789_000_000, ZoneOffset.UTC)`
| `java.time.OffsetTime`     | `"12:34:56.789Z"`                        -> `OffsetTime.of(12, 34, 56, 789_000_000, ZoneOffset.UTC)`
| `java.time.YearMonth`      | `"2017-03"`                              -> `YearMonth.of(2017, 3)`
| `java.time.Year`           | `"2017"`                                 -> `Year.of(2017)`
| `java.time.ZonedDateTime`  | `"2017-03-14T12:34:56.789Z"`             -> `ZonedDateTime.of(2017, 3, 14, 12, 34, 56, 789_000_000, ZoneOffset.UTC)`
| `java.util.Currency`       | `"JPY"`                                  -> `Currency.getInstance("JPY")`
| `java.util.Locale`         | `"en"`                                   -> `new Locale("en")`
| `java.util.UUID`           | `"d043e930-7b3b-48e3-bdbe-5a3ccfb833db"` -> `UUID.fromString("d043e930-7b3b-48e3-bdbe-5a3ccfb833db")`
|===

[[writing-tests-parameterized-tests-argument-conversion-implicit-fallback]]
====== Fallback String-to-Object Conversion

In addition to implicit conversion from strings to the target types listed in the above
table, JUnit Jupiter also provides a fallback mechanism for automatic conversion from a
`String` to a given target type if the target type declares exactly one suitable _factory
method_ or a _factory constructor_ as defined below.

- __factory method__: a non-private, `static` method declared in the target type that
  accepts a single `String` argument and returns an instance of the target type. The name
  of the method can be arbitrary and need not follow any particular convention.
- __factory constructor__: a non-private constructor in the target type that accepts a
  single `String` argument.

NOTE: If multiple _factory methods_ are discovered, they will be ignored. If a _factory
method_ and a _factory constructor_ are discovered, the factory method will be used
instead of the constructor.

For example, in the following `@ParameterizedTest` method, the `Book` argument will be
created by invoking the `Book.fromTitle(String)` factory method and passing `"42 Cats"`
as the title of the book.

[source,java,indent=0]
----
include::{testDir}/example/ParameterizedTestDemo.java[tags=implicit_fallback_conversion_example]
----

[[writing-tests-parameterized-tests-argument-conversion-explicit]]
===== Explicit Conversion

Instead of relying on implicit argument conversion you may explicitly specify an
`ArgumentConverter` to use for a certain parameter using the `@ConvertWith` annotation
like in the following example.

[source,java,indent=0]
----
include::{testDir}/example/ParameterizedTestDemo.java[tags=explicit_conversion_example]
----

Explicit argument converters are meant to be implemented by test and extension authors.
Thus, `junit-jupiter-params` only provides a single explicit argument converter that may
also serve as a reference implementation: `JavaTimeArgumentConverter`. It is used via the
composed annotation `JavaTimeConversionPattern`.

[source,java,indent=0]
----
include::{testDir}/example/ParameterizedTestDemo.java[tags=explicit_java_time_converter]
----


[[writing-tests-parameterized-tests-display-names]]
==== Customizing Display Names

By default, the display name of a parameterized test invocation contains the invocation
index and the `String` representation of all arguments for that specific invocation.
However, you can customize invocation display names via the `name` attribute of the
`@ParameterizedTest` annotation like in the following example.

[source,java,indent=0]
----
include::{testDir}/example/ParameterizedTestDemo.java[tags=custom_display_names]
----

When executing the above method using the `ConsoleLauncher` you will see output similar to the following.

....
Display name of container ✔
├─ 1 ==> first='foo', second=1 ✔
├─ 2 ==> first='bar', second=2 ✔
└─ 3 ==> first='baz, qux', second=3 ✔
....

The following placeholders are supported within custom display names.

[cols="20,80"]
|===
| Placeholder       | Description

| `{index}`         | the current invocation index (1-based)
| `{arguments}`     | the complete, comma-separated arguments list
| `{0}`, `{1}`, ... | an individual argument
|===


[[writing-tests-parameterized-tests-lifecycle-interop]]
==== Lifecycle and Interoperability

Each invocation of a parameterized test has the same lifecycle as a regular `@Test`
method. For example, `@BeforeEach` methods will be executed before each invocation.
Similar to <<writing-tests-dynamic-tests>>, invocations will appear one by one in the
test tree of an IDE. You may at will mix regular `@Test` methods and `@ParameterizedTest`
methods within the same test class.

You may use `ParameterResolver` extensions with `@ParameterizedTest` methods. However,
method parameters that are resolved by argument sources need to come first in the
argument list. Since a test class may contain regular tests as well as parameterized
tests with different parameter lists, values from argument sources are not resolved for
lifecycle methods (e.g. `@BeforeEach`) and test class constructors.

[source,java,indent=0]
----
include::{testDir}/example/ParameterizedTestDemo.java[tags=ParameterResolver_example]
----


[[writing-tests-test-templates]]
=== Test Templates

A `{TestTemplate}` method is not a regular test case but rather a template for test
cases. As such, it is designed to be invoked multiple times depending on the number of
invocation contexts returned by the registered providers. Thus, it must be used in
conjunction with a registered `{TestTemplateInvocationContextProvider}` extension. Each
invocation of a test template method behaves like the execution of a regular `@Test`
method with full support for the same lifecycle callbacks and extensions. Please refer to
<<extensions-test-templates>> for usage examples.


[[writing-tests-dynamic-tests]]
=== Dynamic Tests

The standard `@Test` annotation in JUnit Jupiter described in
<<writing-tests-annotations>> is very similar to the `@Test` annotation in JUnit 4. Both
describe methods that implement test cases. These test cases are static in the sense that
they are fully specified at compile time, and their behavior cannot be changed by
anything happening at runtime. _Assumptions provide a basic form of dynamic behavior but
are intentionally rather limited in their expressiveness._

In addition to these standard tests a completely new kind of test programming model has
been introduced in JUnit Jupiter. This new kind of test is a _dynamic test_ which is
generated at runtime by a factory method that is annotated with `@TestFactory`.

In contrast to `@Test` methods, a `@TestFactory` method is not itself a test case but
rather a factory for test cases. Thus, a dynamic test is the product of a factory.
Technically speaking, a `@TestFactory` method must return a `Stream`, `Collection`,
`Iterable`, or `Iterator` of `DynamicNode` instances. Instantiable subclasses of
`DynamicNode` are `DynamicContainer` and `DynamicTest`. `DynamicContainer` instances are
composed of a _display name_ and a list of dynamic child nodes, enabling the creation of
arbitrarily nested hierarchies of dynamic nodes. `DynamicTest` instances will then be
executed lazily, enabling dynamic and even non-deterministic generation of test cases.

Any `Stream` returned by a `@TestFactory` will be properly closed by calling
`stream.close()`, making it safe to use a resource such as `Files.lines()`.

As with `@Test` methods, `@TestFactory` methods must not be `private` or `static` and may
optionally declare parameters to be resolved by `ParameterResolvers`.

A `DynamicTest` is a test case generated at runtime. It is composed of a _display name_
and an `Executable`. `Executable` is a `@FunctionalInterface` which means that the
implementations of dynamic tests can be provided as _lambda expressions_ or _method
references_.

.Dynamic Test Lifecycle
WARNING: The execution lifecycle of a dynamic test is quite different than it is for a
standard `@Test` case. Specifically, there are no lifecycle callbacks for individual
dynamic tests. This means that `@BeforeEach` and `@AfterEach` methods and their
corresponding extension callbacks are executed for the `@TestFactory` method but not for
each _dynamic test_. In other words, if you access fields from the test instance within a
lambda expression for a dynamic test, those fields will not be reset by callback methods
or extensions between the execution of individual dynamic tests generated by the same
`@TestFactory` method.

As of JUnit Jupiter {jupiter-version}, dynamic tests must always be created by factory
methods; however, this might be complemented by a registration facility in a later
release.

WARNING: Dynamic tests are currently an _experimental_ feature. Consult the table in
<<api-evolution-experimental-apis>> for details.

[[writing-tests-dynamic-tests-examples]]
==== Dynamic Test Examples

The following `DynamicTestsDemo` class demonstrates several examples of test factories
and dynamic tests.

The first method returns an invalid return type. Since an invalid return type cannot be
detected at compile time, a `JUnitException` is thrown when it is detected at runtime.

The next five methods are very simple examples that demonstrate the generation of a
`Collection`, `Iterable`, `Iterator`, or `Stream` of `DynamicTest` instances. Most of
these examples do not really exhibit dynamic behavior but merely demonstrate the
supported return types in principle. However, `dynamicTestsFromStream()` and
`dynamicTestsFromIntStream()` demonstrate how easy it is to generate dynamic tests for a
given set of strings or a range of input numbers.

The next method is truly dynamic in nature. `generateRandomNumberOfTests()` implements an
`Iterator` that generates random numbers, a display name generator, and a test executor
and then provides all three to `DynamicTest.stream()`. Although the non-deterministic
behavior of `generateRandomNumberOfTests()` is of course in conflict with test
repeatability and should thus be used with care, it serves to demonstrate the
expressiveness and power of dynamic tests.

The last method generates a nested hierarchy of dynamic tests utilizing
`DynamicContainer`.

[source,java]
----
include::{testDir}/example/DynamicTestsDemo.java[tags=user_guide]
----
