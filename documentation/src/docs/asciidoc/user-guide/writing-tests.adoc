[[writing-tests]]
== テストを書く

次の例では、JUnit Jupiter でテストを書くための最小の要件をうかがうことができます。
この章の後続の節では、利用可能なすべての機能をさらに詳しく説明します。

[source,java,indent=0]
.最初のテストケース
----
include::{testDir}/example/MyFirstJUnitJupiterTests.java[tags=user_guide]
----

[[writing-tests-annotations]]
=== アノテーション

JUnit Jupiterは、テストを構成し、フレームワークを拡張するために、次のアノテーションをサポートします。

特に断りがない限り、中心となるすべてのアノテーションは、 `junit-jupiter-api` モジュールの `{api-package}` パッケージに含まれます。

[cols="20,80"]
|===
| アノテーション             | 説明

| `@Test`                  | このメソッドが、テストメソッドであることを示します。JUnit 4 の `@Test` アノテーションとは異なり、このアノテーションはどんな属性も宣言しません。というのも、JUnit Jupiter のテスト拡張は、それ専用のアノテーションベースで行われるからです。このメソッドは、_オーバーライド_ されない限り、_継承_ されます。
| `@ParameterizedTest`     | このメソッドが、<<writing-tests-parameterized-tests, パラメーター化テスト>> であることを示します。このメソッドは、_オーバーライド_ されない限り、_継承_ されます。
| `@RepeatedTest`          | このメソッドが、<<writing-tests-repeated-tests, 繰り返しテスト>> のためのテストテンプレートであることを示します。このメソッドは、_オーバーライド_ されない限り、_継承_ されます。
| `@TestFactory`           | このメソッドが、<<writing-tests-dynamic-tests, 動的テスト>> のためのテストファクトリであることを示します。このメソッドは、_オーバーライド_ されない限り、_継承_ されます。
| `@TestTemplate`          | このメソッドが、<<writing-tests-test-templates, テストケースのテンプレート>> であることを示します。このメソッドは、登録した <<extensions-test-templates, プロバイダ>> が返す実行コンテキストの数に応じて、複数回呼び出されます。このメソッドは、_オーバーライド_ されない限り、_継承_ されます。
| `@TestMethodOrder`       | アノテーションを付与したテストクラスに対して、<<writing-tests-test-execution-order, テストメソッドの実行順序>> を設定するために使われます。JUnit 4　の `@FixMethodOrder` に似ています。このアノテーションは、_継承_ されます。
| `@TestInstance`          | アノテーションを付与したテストクラスに対して、<<writing-tests-test-instance-lifecycle, テストインスタンスのライフサイクル>> を設定するために使われます。このアノテーションは、_継承_ されます。
| `@DisplayName`           | テストクラスやテストメソッドにカスタムの <<writing-tests-display-names, 表示名>> を指定します。このアノテーションは、_継承_ されません。
| `@DisplayNameGeneration` | テストクラスにカスタムの <<writing-tests-display-name-generator, 表示名ジェネレーター>> を指定します。このアノテーションは、_継承_ されます。
| `@BeforeEach`            | このメソッドが、現在のクラスの `@Test`, `@RepeatedTest`, `@ParameterizedTest`, `@TestFactory` メソッドの _前に毎回_ 実行されるよう指定します。JUnit 4の `@Before` と同じです。このメソッドは、_オーバーライド_ されない限り、_継承_ されます。
| `@AfterEach`             | このメソッドが、現在のクラスの `@Test`, `@RepeatedTest`, `@ParameterizedTest`, `@TestFactory` メソッドの _後に毎回_ 実行されるよう指定します。JUnit 4の `@After` と同じです。このメソッドは、_オーバーライド_ されない限り、_継承_ されます。
| `@BeforeAll`             | このメソッドが、現在のクラスの *すべての* `@Test`, `@RepeatedTest`, `@ParameterizedTest`, `@TestFactory` メソッドの _前に一度だけ_ 実行されるよう指定します。JUnit 4 の `@BeforeClass` と同じです。 このメソッドは、（_隠す_ か _オーバーライドする_ かしない限り）_継承_ されますが、（<<writing-tests-test-instance-lifecycle, テストインスタンスのライフサイクル>> に "per-class" が使われない限り）`static` でなければいけません。
| `@AfterAll`              | このメソッドが、現在のクラスの *すべての* `@Test`, `@RepeatedTest`, `@ParameterizedTest`, `@TestFactory` メソッドの _後に一度だけ_ 実行されるよう指定します。JUnit 4 の `@AfterClass` と同じです。このメソッドは、（_隠す_ か _オーバーライドする_ かしない限り）_継承_ されますが、（<<writing-tests-test-instance-lifecycle, テストインスタンスのライフサイクル>> に "per-class" が使われない限り）`static` でなければいけません。
| `@Nested`                | このクラスが、非 static の <<writing-tests-nested, ネストしたテストクラス>> であることを示します。 `@BeforeAll` および `@AfterAll` メソッドは、<<writing-tests-test-instance-lifecycle, テストインスタンスのライフサイクル>> に "per-class" が使われない限り、`@Nested` テストクラスの中で直接使うことはできません。このアノテーションは、_継承_ されません。
| `@Tag`                   | クラスまたはメソッドレベルで <<writing-tests-tagging-and-filtering, テストをフィルタリングするためのタグ>> を宣言するのに使われます。TestNG のテストグループや JUnit 4 の Category と同じです。このアノテーションは、クラスレベルでは _継承_ されますが、メソッドレベルでは _継承_ されません。
| `@Disabled`              | テストクラスやテストメソッドを <<writing-tests-disabling, 無効化>> するのに使われます。JUnit 4 の `@Ignore` と同じです。このアノテーションは、_継承_ されません。
| `@ExtendWith`            | <<extensions-registration-declarative, 拡張機能を宣言的に登録する>> ために使われます。このアノテーションは、_継承_ されます。
| `@RegisterExtension`     | フィールド経由で <<extensions-registration-programmatic, 拡張機能を手続き的に登録する>> ために使われます。このフィールドは、_隠さ_ れない限り、_継承_ されます。
| `@TempDir`               | ライフサイクルメソッドまたはテストメソッドでフィールド注入またはパラメーター注入を使って <<writing-tests-built-in-extensions-TempDirectory, 一時ディレクトリ>> を提供するために使われます。`org.junit.jupiter.api.io` パッケージにあります。
|===

WARNING: いくつかのアノテーションは現在 _実験中_ です。詳細は、
<<api-evolution-experimental-apis>> のテーブルを参照してください。

[[writing-tests-meta-annotations]]
==== メタアノテーションと合成アノテーション

JUnit Jupiterアノテーションは、_メタアノテーション_ として使うことができます。つまり、
メタアノテーションの意味を自動的に _継承_ した独自の _合成アノテーション_ を作れるということです。

例えば、`@Tag("fast")` をコードベース全体にコピー＆ペーストする代わりに
（<<writing-tests-tagging-and-filtering>> 参照）、以下の `@Fast`
のような名前のカスタム _合成アノテーション_ を作ることができます。
`@Fast` は、`@Tag("fast")` の代わりに使うことができます。

[source,java,indent=0]
----
include::{testDir}/example/Fast.java[tags=user_guide]
----

次の `@Test` メソッドは、`@Fast` アノテーションの使い方を示しています。

[source,java,indent=0]
----
@Fast
@Test
void myFastTest() {
    // ...
}
----

さらに一歩進めて、 `@Tag("fast")` _かつ_ `@Test` の代わりに使える `@FastTest`
アノテーションを導入することもできます。

[source,java,indent=0]
----
include::{testDir}/example/FastTest.java[tags=user_guide]
----

JUnit は、以下を "fast" でタグ付けされた `@Test` メソッドであると自動的に認識します。

[source,java,indent=0]
----
@FastTest
void myFastTest() {
    // ...
}
----

[[writing-tests-classes-and-methods]]
=== テストクラスとテストメソッド

**テストクラス**: _テストメソッド_ を少なくとも1つもつ、トップレベルのクラスや `static` な内部クラス、
<<writing-tests-nested, `@Nested` クラス>> です。

テストクラスは `abstract` ではなく、単一のコンストラクタをもつ必要があります。

**テストメソッド**: `@Test`, `@RepeatedTest`, `@ParameterizedTest`, `@TestFactory`, `@TestTemplate`
のいずれかが直接またはメタアノテーションとして付与されたインスタンスメソッドです。

**ライフサイクルメソッド**: `@BeforeAll`, `@AfterAll`, `@BeforeEach`, `@AfterEach`
のいずれかが直接またはメタアノテーションとして付与されたインスタンスメソッドです。

テストメソッドとライフサイクルメソッドは、テストクラス内で宣言されることも、親クラスから継承されることも、
インタフェースから継承される (<<writing-tests-test-interfaces-and-default-methods>> 参照) こともあります。
また、テストメソッドとライフサイクルメソッドは `abstract` であってはならず、値を返してもいけません。

NOTE: テストクラスやテストメソッド、ライフサイクルメソッドは、`public` である必要がありません。
ただし、`private` では _いけません_。

次のテストクラスは、`@Test` メソッドとサポートされているライフサイクルメソッドの使い方を示します。
実行時のセマンティクスに関するさらなる情報は、<<writing-tests-test-execution-order>> と
<<extensions-execution-order-wrapping-behavior>> を参照してください。

[source,java,indent=0]
.標準的なテストクラス
----
include::{testDir}/example/StandardTests.java[tags=user_guide]
----

[[writing-tests-display-names]]
=== 表示名

テストクラスやテストメソッドは、`@DisplayName` を使ってカスタムの表示名を宣言できます。
空白や特殊文字だけでなく絵文字も含めることができ、テストレポートやテストランナー、IDEに表示されます。

[source,java,indent=0]
----
include::{testDir}/example/DisplayNameDemo.java[tags=user_guide]
----

[[writing-tests-display-name-generator]]
==== 表示名ジェネレーター

JUnit Jupiter は、`@DisplayNameGeneration` アノテーションで設定できる、
カスタムの表示名ジェネレーターをサポートしています。`@DisplayName` アノテーション経由で
与えられる値は、`DisplayNameGenerator` に生成される表示名よりも常に優先されます。

[source,java,indent=0]
----
include::{testDir}/example/DisplayNameGeneratorDemo.java[tags=user_guide]
----

```
+-- DisplayNameGeneratorDemo [OK]
  +-- A year is not supported [OK]
  | +-- A negative value for year is not supported by the leap year computation. [OK]
  | | +-- For example, year -1 is not supported. [OK]
  | | '-- For example, year -4 is not supported. [OK]
  | '-- if it is zero() [OK]
  '-- A year is a leap year... [OK]
    +-- A year is a leap year if it is divisible by 4 but not by 100. [OK]
    '-- A year is a leap year if it is one of the following years. [OK]
      +-- Year 2016 is a leap year. [OK]
      +-- Year 2020 is a leap year. [OK]
      '-- Year 2048 is a leap year. [OK]
```

[[writing-tests-assertions]]
=== アサーション

JUnit Jupiterは、JUnit 4にあった多くのアサーションメソッドをもち、
Java 8のラムダ式と一緒に使いやすいものもいくつか追加しています。
すべてのJUnit Jupiterアサーションは、 `{Assertions}` クラスの `static` メソッドです。

[source,java,indent=0]
----
include::{testDir}/example/AssertionsDemo.java[tags=user_guide]
----

[[writing-tests-assertions-preemptive-timeouts]]
[WARNING]
.プリエンプティブなタイムアウト
====
`Assertions` クラスの `assertTimeoutPreemptively()` メソッドは、与えられた
`executable` や `supplier` を呼び出し元のコードとは異なるスレッドで実行します。
これは、`executable` や `supplier` 内で実行されるコードが `java.lang.ThreadLocal`
ストレージに依存していると、望ましくない副作用を引き起こす可能性があります。

よくある例の1つに Spring Framework のトランザクションテストのサポートがあります。
Spring のテストサポートは、テストメソッドが呼び出される前に、トランザクションの状態を
カレントスレッドに (`ThreadLocal` 経由で) バインドします。そのため、
`assertTimeoutPreemptively()` に与えられる `executable` や `supplier`
がトランザクションに関わる Spring 管理のコンポーネントを呼び出すと、それらのコンポーネントで
実行されたアクションはテストが管理するトランザクションでロールバックされません。
それどころか、そのようなアクションは、テストが管理するトランザクションがロールバックされても、
永続ストア (例えば、リレーショナル・データベース) にコミットされてしまいます。

同様の副作用は、`ThreadLocal` ストレージに依存するほかのフレームワークでも起こりえます。
====

[[writing-tests-assertions-kotlin]]
==== Kotlin のアサーションサポート

JUnit Jupiterは、 https://kotlinlang.org/[Kotlin]
と一緒に使いやすいアサーションもいくつか含んでいます。すべてのJUnit Jupiter Kotlinアサーションは、
`org.junit.jupiter.api` パッケージのトップレベル関数です。

// TODO: Change to using kotlin language highlighting after switch to rouge syntax highlighter
[source,groovy,indent=0]
----
include::{kotlinTestDir}/example/KotlinAssertionsDemo.kt[tags=user_guide]
----

[[writing-tests-assertions-third-party]]
==== サードパーティーのアサーションライブラリ

多くのテストシナリオではJUnit Jupiterが提供するアサーション機能だけで十分ですが、
時にはさらなるパワーや _マッチャー_ のような追加機能が必要になることもあります。
そのような場合には、 {AssertJ} や {Hamcrest}、 {Truth} のようなサードパーティーの
アサーションライブラリを使うことをJUnitチームはお勧めします。
開発者は、好みに応じてアサーションライブラリを自由に選択することができます。

例えば、 _マッチャー_ と流れるようなAPIを組み合わせれば、アサーションをもっと説明的で
読みやすくすることができます。しかし、JUnit Jupiterの `{Assertions}` クラスは、
JUnit 4の `org.junit.Assert` クラスのようにHamcrestの
http://junit.org/junit4/javadoc/latest/org/hamcrest/Matcher.html[`Matcher`]
を受け付ける
http://junit.org/junit4/javadoc/latest/org/junit/Assert.html#assertThat[`assertThat()`]
メソッドを提供していません。代わりに、開発者はサードパーティーのアサーションライブラリが
提供するマッチャーを利用することが推奨されます。

次の例は、JUnit JupiterテストでHamcrestの `assertThat()` を使う方法を示しています。
Hamcrestライブラリをクラスパスに追加しさえすれば、 `assertThat()` や `is()`、 `equalTo()`
のようなメソッドをstatic importして、下の `assertWithHamcrestMatcher()` メソッドのように
テストの中で使うことができます。

[source,java,indent=0]
----
include::{testDir}/example/HamcrestAssertionsDemo.java[tags=user_guide]
----

当然ながら、JUnit 4のプログラミングモデルに基づくレガシーなテストでは、引き続き
`org.junit.Assert#assertThat` を使い続けることができます。

[[writing-tests-assumptions]]
=== 前提条件

JUnit Jupiter は、JUnit 4 が提供している前提条件用メソッドのサブセットを備え、
Java 8 のラムダ式やメソッド参照と一緒に使いやすくするものをいくつか追加しています。
JUnit Jupiter の前提条件メソッドは、すべて `{Assumptions}` クラスの static メソッドです。

[source,java,indent=0]
----
include::{testDir}/example/AssumptionsDemo.java[tags=user_guide]
----

NOTE: JUnit Jupiter 5.4 から、前提条件のために JUnit 4 の `org.junit.Assume`
クラスにあるメソッドを使うことも可能になりました。厳密に言うと、JUnit Jupiter
は JUnit 4 がテストを失敗とマークするのではなく中断すべきと知らせるための
`AssumptionViolatedException` をサポートします。

[[writing-tests-disabling]]
=== テストの無効化

テストクラス全体または個々のテストメソッドは、 `{Disabled}` アノテーションや
<<writing-tests-conditional-execution>> で説明するアノテーション、
あるいはカスタムの <<extensions-conditions, `ExecutionCondition`>>
によって _無効化_ することができます。

次の例は、`@Disabled` されたテストクラスです。

[source,java,indent=0]
----
include::{testDir}/example/DisabledClassDemo.java[tags=user_guide]
----

そして次の例は、`@Disabled` されたテストメソッドをもつテストクラスです。

[source,java,indent=0]
----
include::{testDir}/example/DisabledTestsDemo.java[tags=user_guide]
----

NOTE: `@Disabled` は、_理由_ を指定せずに宣言することができます; しかし、JUnit
チームは、開発者がテストクラスやテストメソッドが無効になっている短い説明の記述を推奨します。
そのため、上の例では -- 例えば、`@Disabled("Disabled until bug #42 has been resolved")`
のように、理由を記述する方法を示しています。開発チームによっては、自動的な追跡を可能にするために
Issue 番号の指定を要求することさえあります。

[[writing-tests-conditional-execution]]
=== 条件付きテスト実行

JUnit Jupiterの <<extensions-conditions, `ExecutionCondition`>> 拡張APIは、
開発者がある一定の条件にもとづいて _手続き的に_  コンテナやテストを有効化したり、
無効化したりすることができるようにします。
簡単な例は、`{Disabled}` アノテーションをサポートする `{DisabledCondition}` です
（<<writing-tests-disabling>> 参照）。

JUnit Jupiterは、`org.junit.jupiter.api.condition` パッケージで `@Disabled`
以外にもアノテーションベースの条件をサポートしています。これにより、開発者は _宣言的に_
コンテナやテストを有効化したり、無効化したりすることができます。
詳細は、以降の節を参照してください。

[TIP]
.合成アノテーション
====
以降で説明するいずれの _条件_ アノテーションも、カスタムの _合成アノテーション_
を作るためのメタアノテーションとして使われうる点に注意してください。例えば、
<<writing-tests-conditional-execution-os-demo, @EnabledOnOsデモ>> の `@TestOnMac`
アノテーションは、`@Test` と `@EnabledOnOs` を1つの再利用可能なアノテーションとして
組み合わせる方法を示しています。
====

[WARNING]
====
以降の節で取り上げられる _条件_ アノテーションは、あるテストインターフェースやテストクラス、
テストメソッドに対して一度しか宣言できません。条件アノテーションがある要素に対して直接、
間接、あるいはメタアノテーションで複数回指定されたとしても、JUnitが最初に見つけた
アノテーションだけが使われます。その他のアノテーションは、黙って無視されます。ただし、
`org.junit.jupiter.api.condition` パッケージのそれぞれの条件アノテーションは、
組み合わせて使うことができる点に注意してください。
====

[[writing-tests-conditional-execution-os]]
==== オペレーティングシステム条件

`{EnabledOnOs}` および `{DisabledOnOs}` アノテーションを使うと、
コンテナやテストを特定のオペレーティングシステムで有効にしたり無効にしたりできます。

[[writing-tests-conditional-execution-os-demo]]
[source,java,indent=0]
----
include::{testDir}/example/ConditionalTestExecutionDemo.java[tags=user_guide_os]
----

[[writing-tests-conditional-execution-jre]]
==== Javaランタイム環境条件

`{EnabledOnJre}` および `{DisabledOnJre}` アノテーションを使うと、
コンテナやテストを特定のバージョンのJavaランタイム環境（JRE）で有効にしたり無効にしたりできます。

[source,java,indent=0]
----
include::{testDir}/example/ConditionalTestExecutionDemo.java[tags=user_guide_jre]
----

[[writing-tests-conditional-execution-system-properties]]
==== システムプロパティ条件

`{EnabledIfSystemProperty}` および `{DisabledIfSystemProperty}` アノテーションを使うと、
指定した名前をもつJVMシステムプロパティの値に応じて、コンテナやテストを有効にしたり
無効にしたりできます。 `matches` 属性で指定する値は、正規表現として解釈されます。

[source,java,indent=0]
----
include::{testDir}/example/ConditionalTestExecutionDemo.java[tags=user_guide_system_property]
----

[[writing-tests-conditional-execution-environment-variables]]
==== 環境変数条件

`{EnabledIfEnvironmentVariable}` および `{DisabledIfEnvironmentVariable}`
アノテーションを使うと、指定した名前をもつ環境変数の値に応じて、コンテナやテストを
有効にしたり無効にしたりできます。`matches` 属性で指定する値は、正規表現として解釈されます。

[source,java,indent=0]
----
include::{testDir}/example/ConditionalTestExecutionDemo.java[tags=user_guide_environment_variable]
----

[[writing-tests-conditional-execution-scripts]]
==== スクリプトベースの条件

JUnit Jupiterは、`{EnabledIf}` または `{DisabledIf}` アノテーションで設定された
スクリプトの実行結果に応じて、コンテナやテストを有効にしたり無効にしたりする機能を提供します。
スクリプトは、JavaScript、Groovy、あるいはJSR 223で定義されたJava Scripting API
をサポートする任意の言語で記述することができます。

WARNING: `{EnabledIf}` および `{DisabledIf}` を使った条件付きテスト実行は、
現在 _試験的な_ 機能です。詳細は、<<api-evolution-experimental-apis>>
のテーブルを参考にしてください。

TIP: もしスクリプトのロジックが現在のオペレーティングシステムやJavaランタイム環境の
バージョン、特定のJVMシステムプロパティや環境変数だけに依存するなら、その目的専用の
組み込みアノテーションの使用を検討すべきです。詳細は、この章の前の節を参照してください。

NOTE: もし同じようなスクリプトベースの条件を何回も使っていると感じたら、
高速かつタイプセーフで、よりメンテナンスしやすい方法で実装するために、専用の
<<extensions-conditions, ExecutionCondition>> 拡張を書くことを検討してください。

[source,java,indent=0]
----
include::{testDir}/example/ConditionalTestExecutionDemo.java[tags=user_guide_scripts]
----

[[writing-tests-conditional-execution-scripts-bindings]]
===== スクリプトバインディング

以下の名前は、スクリプトのコンテキストに束縛されるため、スクリプト内で使うことができます。
_accessor_ は、単純な `String get(String name)` メソッドを介したマップ構造への
アクセスを提供します。

[cols="25,25,75"]
|===
| Name                          | Type          | Description

| `systemEnvironment`           | _accessor_    | オペレーティングシステムの環境変数へのアクセッサ
| `systemProperty`              | _accessor_    | JVMのシステムプロパティへのアクセッサ
| `junitConfigurationParameter` | _accessor_    | 設定パラメーターへのアクセッサ
| `junitDisplayName`            | `String`      | テストやコンテナの表示名
| `junitTags`                   | `Set<String>` | テストやコンテナにアサインされたすべてのタグ
| `junitUniqueId`               | `String`      | テストやコンテナの一意なID
|===


[[writing-tests-tagging-and-filtering]]
=== タグとフィルタリング

テストクラスとテストメソッドには、`@Tag` アノテーションでタグを付与することができます。
これらのタグはあとで <<running-tests, テストを発見・実行>> するときのフィルタリングに
使うことができます。

TIP: See also: <<running-tests-tag-expressions>>

==== タグの構文規則

* タグは、`null` または _空_ であってはならない
* _トリミングした_ タグは、空白文字を含んではならない
* _トリミングした_ タグは、ISO制御文字を含んではならない
* _トリミングした_ タグは、次の _予約済み文字_ を含んではならない
  - `,`: _カンマ_
  - `(`: _左括弧_
  - `)`: _右括弧_
  - `&`: _アンパサンド_
  - `|`: _縦棒_
  - `!`: _感嘆符_

NOTE: 上のコンテキストで "トリミングした" とは、先頭および末尾の空白文字が
取り除かれていることを意味する。

[source,java,indent=0]
----
include::{testDir}/example/TaggingDemo.java[tags=user_guide]
----

TIP: タグに対する独自アノテーションの作り方は、<<writing-tests-meta-annotations>>
を参照してください。

[[writing-tests-test-execution-order]]
=== テストの実行順序

デフォルトでは、テストメソッドは決定的だが（意図的に）明白ではないアルゴリズムを使って
順序付けられます。これにより、後続のテストスイートではテストメソッドが同じ順序で実行されるため、
再現可能なビルドになります。

NOTE: _テストメソッド_ の定義は、<<writing-tests-classes-and-methods>> を参照してください。

理想的な _ユニットテスト_ では実行される順序に依存すべきではありませんが、テストメソッドを
特定の実行順序に強制する必要がある場合もあります。例えば、テストの順番が重要となる
_統合テスト_ や _機能テスト_ を書くときです。`@TestInstance(Lifecycle.PER_CLASS)`
と組み合わせる場合は、特にそうです。

テストメソッドが実行される順序を制御するには、テストクラスやテストインターフェースに
`{TestMethodOrder}` アノテーションを付与し、期待する `{MethodOrderer}` 実装を指定してください。
独自の `MethodOrderer` を実装することも、以下の組み込み `MethodOrderer` 実装を使うこともできます。

* `{Alphanumeric}`: テストメソッドを名前と引数リストに基づいて _辞書順で_ ソートします。
* `{OrderAnnotation}`: テストメソッドを `{Order}` アノテーションで指定した値に基づいて、
  _数値順に_ ソートします。
* `{Random}`: テストメソッドを _疑似的なランダム順に_ 並べます。独自の _シード (seed)_
  の設定もサポートします。

NOTE: 参照: <<extensions-execution-order-wrapping-behavior>>

次の例は、テストメソッドが `@Order` アノテーションで指定した順序どおりに実行されることを
保証する方法を示しています。

[source,java,indent=0]
----
include::{testDir}/example/OrderedTestsDemo.java[tags=user_guide]
----

[[writing-tests-test-instance-lifecycle]]
=== テストインスタンスのライフサイクル

個々のテストメソッドを隔離された環境で実行し、
テストインスタンスをミュータブルにすると起こりうる意図しない副作用を避けるため、
JUnitは _テストメソッド_ （<<writing-tests-classes-and-methods>> 参照）
毎にそのテストクラスの新しいインスタンスを生成して実行します。
この "per-method（メソッド毎）" のテストインスタンスライフサイクルは、JUnit Jupiter
のデフォルトの挙動で、過去のJUnitのバージョンと同じです。

NOTE: "per-method" のテストインスタンスライフサイクルモードが有効であったとしても、
<<writing-tests-conditional-execution, 条件>> (例えば、`@Disabled` や
`@DisabledOnOs` など)によって _テストメソッド_ が _無効化_ されている場合は、
テストクラスのインスタンスが作り直されない点に注意してください。

もしすべてのテストメソッドを同じテストインスタンスで実行させたい場合は、テストクラスに
`@TestInstance(Lifecycle.PER_CLASS)` アノテーションを付与してください。
このモードを使うと、新しいテストインスタンスはテストクラス毎に1回だけ生成されます。
そのため、もしテストメソッドがインスタンス変数の状態に依存するのであれば、
`@BeforeEach` や `@AfterEach` メソッドで状態をリセットする必要があります。

"per-class（クラス毎）" モードは、デフォルトの "per-method（メソッド毎）" モードに比べて
追加のメリットがあります。具体的には、"per-class" モードでは `@BeforeAll` および
`@AfterAll` をインターフェースの `default` メソッドやクラスの非staticなメソッドに
対して宣言できるようになります。そのため、"per-class" モードでは `@BeforeAll` や
`@AfterAll` メソッドを `@Nested` テストクラスでも使えます。

もしプログラミング言語Kotlinでテストを書く場合は、テストインスタンスのライフサイクルを
"per-class" モードに切り替えると、`@BeforeAll` および `@AfterAll` メソッドを
より実装しやすいでしょう。

[[writing-tests-test-instance-lifecycle-changing-default]]
==== テストインスタンスのデフォルトのライフサイクルの変更

テストクラスやテストインターフェースに `@TestInstance` アノテーションを付与すると、
JUnit Jupiterは _デフォルト_ のライフサイクルモードを使います。標準の _デフォルト_
モードは `PER_METHOD` ですが、テストプラン全体で _デフォルト_ を変更することもできます。
テストインスタンスのデフォルトのライフサイクルモードを変更するには、
`junit.jupiter.testinstance.lifecycle.default` _設定パラメーター_ に
`TestInstance.Lifecycle` で定義された列挙定数を指定するだけです。
これは、JVMシステムプロパティや `Launcher` に渡される `LauncherDiscoveryRequest`
の _設定パラメーター_ 、あるいはJUnit Platform設定ファイルなどで指定できます
（詳細は、<<running-tests-config-params>> 参照）。

例えば、デフォルトのライフサイクルモードを `Lifecycle.PER_CLASS` に設定するには、
次のシステムプロパティを指定してJVMを起動します。

`-Djunit.jupiter.testinstance.lifecycle.default=per_class`

ただし、デフォルトのライフサイクルモードをJUnit Platform設定ファイルで指定する方が、
よりロバストである点に注意してください。というのも、設定ファイルならプロジェクトの
バージョン管理システムにチェックインでき、IDEやビルドツールからも使えるからです。

JUnit Platform設定ファイルを使ってデフォルトのライフサイクルモードを `Lifecycle.PER_CLASS`
にするには、クラスパスのルート（例えば、`src/test/resources`）に `junit-platform.properties`
という名前で次のファイルを作ります。

`junit.jupiter.testinstance.lifecycle.default = per_class`

WARNING: テストインスタンスの _デフォルト_ のライフサイクルモードを変更する場合は、
一貫性のある方法で適用しないと予測できない結果や不安定なビルドにつながる可能性があります。
例えば、ビルドでは "per-class" をデフォルトとして設定していても、IDEが "per-method"
でテストを実行していると、ビルドサーバーで起きたエラーをデバッグするのが難しくなります。
そのため、JVMシステムプロパティの代わりにJUnit Platform設定ファイルを使って
デフォルトを変更することをお勧めします。

[[writing-tests-nested]]
=== ネストしたテスト

`@Nested` テストは、テスト作成者がテストのグループ関係を表現しやすくします。
詳しい例は次の通りです。

[source,java,indent=0]
.スタックをテストするためのネストしたテストスイート
----
include::{testDir}/example/TestingAStackDemo.java[tags=user_guide]
----

NOTE: _非staticなネストクラス_（すなわち、_内部クラス_）だけが、`@Nested`
テストクラスとして使えます。ネストの深さは自由で、すべての内部クラスがテストクラスの
一部とみなされます。ただし、1つだけ例外があり、`@BeforeAll` および `@AfterAll`
メソッドは、_デフォルトでは_ 機能しません。というのも、Javaでは内部クラスで
`static` メンバーを使用できないからです。しかし、この制限は `@Nested` テストクラスに
`@TestInstance(Lifecycle.PER_CLASS)` アノテーションを付与することで回避できます
（ <<writing-tests-test-instance-lifecycle>> 参照）。

[[writing-tests-dependency-injection]]
=== コンストラクタとメソッドへの依存性注入

これまでのバージョンのJUnitでは、テストクラスのコンストラクタとメソッドは
（少なくとも標準の `Runner` 実装では）引数をもつことができませんでした。
JUnit Jupiterの大きな変更点の1つは、テストのコンストラクタやメソッドが
引数をもてるようになったことです。これは大きな柔軟性をもたらし、
_依存性注入_ を可能にします。

`{ParameterResolver}` は、実行時に _動的に_ 引数を解決したいテスト拡張のための
APIを定義しています。もし _テストクラスの_ コンストラクタや _テストメソッド_、
_ライフサイクルメソッド_ (<<writing-tests-classes-and-methods>> 参照) が引数をもつ場合、
その引数は登録済みの `ParameterResolver` によって実行時に解決されなければなりません。

現状、自動的に登録される組み込みのResolverが3つあります。

* `{TestInfoParameterResolver}`: もしコンストラクタやメソッドの引数の型が `{TestInfo}` の場合、
  `TestInfoParameterResolver` が現在のテストに応じた `TestInfo` をその引数の値として与えます。
  `{TestInfo}` は、テストの表示名やテストクラス、テストメソッド、付与されたタグなど、
  現在のコンテナやテストに関する情報を取得するために使用できます。表示名は、テストクラスやテストメソッドの名前か、
  `@DisplayName` で設定されたカスタムの名前か、どちらかになります。
+
`{TestInfo}` は、JUnit 4の `TestName` ルールの代替として使えます。
次の例は、`TestInfo` をテストのコンストラクタ、`@BeforeEach` メソッド、および
`@Test` メソッドに注入する方法を示しています。

[source,java,indent=0]
----
include::{testDir}/example/TestInfoDemo.java[tags=user_guide]
----

* `{RepetitionInfoParameterResolver}`: もし `@RepeatedTest`, `@BeforeEach`,
  `@AfterEach` メソッドの引数の型が `{RepetitionInfo}` の場合、
  `RepetitionInfoParameterResolver` が `RepetitionInfo` インスタンスを与えます。
  `RepetitionInfo` は、`@RepeatedTest` の現在の繰り返し回数や合計回数の情報を
  取得するために使用できます。ただし、`RepetitionInfoParameterResolver` は
  `@RepeatedTest` 以外では登録されないことに注意してください。
  <<writing-tests-repeated-tests-examples>> を参照。

* `{TestReporterParameterResolver}`: もしコンストラクタやメソッドの引数の型が `{TestReporter}`
  の場合、`TestReporterParameterResolver` が `TestReporter` インスタンスを与えます。
  `TestReporter` は、現在のテスト実行に関する追加のデータを出力するために使用できます。
  このデータは、`{TestExecutionListener}` の `reportingEntryPublished()`
  メソッドを通して取得できるので、IDEで参照したり、レポートに含めたりできます。
+
JUnit 4 では `stdout` や `stderr` に情報を出力していましたが、JUnit Jupiter では
`TestReporter` を使うべきです。`@RunWith(JUnitPlatform.class)` を使うときも、
すべてのレポート情報が `stdout` に出力されます。加えて、いくつかの IDE では、
レポート情報を `stdout` に表示したり、テスト結果のためのユーザーインターフェースに表示したりします。

[source,java,indent=0]
----
include::{testDir}/example/TestReporterDemo.java[tags=user_guide]
----

NOTE: そのほかの `ParameterResolver` は、`@ExtendWith` を使って適切な
<<extensions, 拡張機能>> を登録することで、明示的に有効にしなければなりません。

カスタムの `{ParameterResolver}` のサンプルとしては、`{RandomParametersExtension}`
を参照してください。本番利用を想定したものではありませんが、
拡張モデルとパラメーター解決処理のシンプルさや高い表現力を示しています。
`MyRandomParametersTest` は、乱数を `@Test` メソッドに注入する例になっています。

[source,java,indent=0]
----
@ExtendWith(RandomParametersExtension.class)
class MyRandomParametersTest {

	@Test
	void injectsInteger(@Random int i, @Random int j) {
		assertNotEquals(i, j);
	}

	@Test
	void injectsDouble(@Random double d) {
		assertEquals(0.0, d, 1.0);
	}

}
----

実世界のユースケースとしては、`{MockitoExtension}` や `{SpringExtension}`
のソースコードを確認してください。

[[writing-tests-test-interfaces-and-default-methods]]
=== テストインターフェースとデフォルトメソッド

JUnit Jupiterでは、`@Test`, `@RepeatedTest`, `@ParameterizedTest`, `@TestFactory`,
`@TestTemplate`, `@BeforeEach`, `@AfterEach` アノテーションをインターフェースの
`default` メソッドに対して宣言することもできます。 `@BeforeAll` と `@AfterAll`
はテストインターフェースの `static` メソッドにしか宣言できませんが、
`@TestInstance(Lifecycle.PER_CLASS)` がテストインターフェースまたはテストクラスに
付与されていればインターフェースの `default` メソッドに宣言することもできます
（<<writing-tests-test-instance-lifecycle>> 参照）。以下はサンプルです。

[source,java]
----
include::{testDir}/example/testinterface/TestLifecycleLogger.java[tags=user_guide]
----

[source,java]
----
include::{testDir}/example/testinterface/TestInterfaceDynamicTestsDemo.java[tags=user_guide]
----

`@ExtendWith` と `@Tag` はテストインターフェースに宣言することで、
そのインタフェースを実装したクラスにタグと拡張機能を自動的に継承させることができます。
<<extensions-lifecycle-callbacks-before-after-execution>> にある
<<extensions-lifecycle-callbacks-timing-extension, TimingExtension>>
のソースコードを参照してください。

[source,java]
----
include::{testDir}/example/testinterface/TimeExecutionLogger.java[tags=user_guide]
----

これらのインタフェースを実装することでテストクラスに適用することができます。

[source,java]
----
include::{testDir}/example/testinterface/TestInterfaceDemo.java[tags=user_guide]
----

`TestInterfaceDemo` を実行すると、次のような出力となります。

....
INFO  example.TestLifecycleLogger - Before all tests
INFO  example.TestLifecycleLogger - About to execute [dynamicTestsForPalindromes()]
INFO  example.TimingExtension - Method [dynamicTestsForPalindromes] took 19 ms.
INFO  example.TestLifecycleLogger - Finished executing [dynamicTestsForPalindromes()]
INFO  example.TestLifecycleLogger - About to execute [isEqualValue()]
INFO  example.TimingExtension - Method [isEqualValue] took 1 ms.
INFO  example.TestLifecycleLogger - Finished executing [isEqualValue()]
INFO  example.TestLifecycleLogger - After all tests
....

この機能の別の適用例としては、インタフェース契約に対するテストが考えられます。
例えば、`Object.equals` や `Comparable.compareTo` の実装クラスが
どう振る舞うべきかのテストを次のように書くことができます。

[source,java]
----
include::{testDir}/example/defaultmethods/Testable.java[tags=user_guide]
----

[source,java]
----
include::{testDir}/example/defaultmethods/EqualsContract.java[tags=user_guide]
----

[source,java]
----
include::{testDir}/example/defaultmethods/ComparableContract.java[tags=user_guide]
----

テストクラスでこれらの契約インターフェースを実装することで、対応するテストケースを
継承することができます。もちろん、抽象メソッドは自分で実装する必要があります。

[source,java]
----
include::{testDir}/example/defaultmethods/StringTests.java[tags=user_guide]
----

NOTE: 前述のテストはサンプル目的であり、完全なものではありません。


[[writing-tests-repeated-tests]]
=== 繰り返しテスト

JUnit Jupiterは、`@RepeatedTest` アノテーションを使って指定した回数だけ
繰り返しテストを実行する機能を提供しています。
繰り返しテストの1回毎の呼び出しは、ライフサイクルコールバックや拡張機能など、通常の
`@Test` メソッドの実行と同じように振る舞います。

次の例は、自動的に10回繰り返す `repeatedTest()` を宣言する方法を示しています。

[source,java]
----
@RepeatedTest(10)
void repeatedTest() {
	// ...
}
----

繰り返し回数を指定するだけでなく、`@RepeatedTest` アノテーションの `name`
属性を使って、繰り返し実行毎の表示名を変更することもできます。表示名は、
静的なテキストと動的なプレースホルダーを組み合わせたパターンにできます。
以下が、現在サポートされているプレースホルダーです。

- `{displayName}`: `@RepeatedTest` メソッドの表示名
- `{currentRepetition}`: 現在の実行回数
- `{totalRepetitions}`: トータルの実行回数

デフォルトの表示名は、`"repetition {currentRepetition} of {totalRepetitions}"`
というパターンに従います。そのため、前述の `repeatedTest()` に対する表示名は、
`repetition 1 of 10`, `repetition 2 of 10` のようになります。
もし `@RepeatedTest` メソッドの名前を含めたい場合は、カスタムのパターンを指定するか、
定義済みの `RepeatedTest.LONG_DISPLAY_NAME` パターンを指定できます。
後者は、`"{displayName} :: repetition {currentRepetition} of {totalRepetitions}"`
というパターンと同等で、`repeatedTest() :: repetition 1 of 10`,
`repeatedTest() :: repetition 2 of 10` のようになります。

現在の繰り返し回数やトータルの繰り返し回数をプログラムから取得するためには、
`RepetitionInfo` インスタンスを `@RepeatedTest`, `@BeforeEach`, `@AfterEach`
メソッドのいずれかに注入させることができます。

[[writing-tests-repeated-tests-examples]]
==== 繰り返しテストの例

この節の最後の `RepeatedTestsDemo` クラスは、繰り返しテストの様々な例を示しています。

`repeatedTest()` メソッドは、前の節で紹介した例と同じです。一方、
`repeatedTestWithRepetitionInfo()` は、トータルの繰り返し回数を取得するために
`RepetitionInfo` インスタンスをテストに注入させる方法を示しています。

その次の2つのメソッドは、`@RepeatedTest` メソッドに対するカスタムの `@DisplayName`
を各繰り返しの表示名に含める方法を示しています。`customDisplayName()` は、
カスタムの表示名とパターンを組み合わせて指定し、生成された表示名を検証するのに
`TestInfo` を使っています。
`{displayName}` が `@DisplayName` の宣言から `Repeat!` となり、
`{currentRepetition}/{totalRepetitions}` が `1/1` となります。
一方、`customDisplayNameWithLongPattern()` は前述の定義済みパターン
`RepeatedTest.LONG_DISPLAY_NAME` を使っています。

`repeatedTestInGerman()` は、繰り返しテストの表示名を外国語（この場合、ドイツ語）
に翻訳する方法を示しています。各繰り返しの表示名は、`Wiederholung 1 von 5`,
`Wiederholung 2 von 5` のようになります。

`beforeEach()` メソッドは `@BeforeEach` アノテーションが付与されているため、
繰り返しテストの個々の繰り返し実行の度に実行されます。`TestInfo` と
`RepetitionInfo` をメソッドに注入させることで、現在実行中の繰り返しテストに
関する情報を取得できることが分かります。`INFO` レベルのログを有効にして
`RepeatedTestsDemo` を実行すると、次のような出力となります。

....
INFO: About to execute repetition 1 of 10 for repeatedTest
INFO: About to execute repetition 2 of 10 for repeatedTest
INFO: About to execute repetition 3 of 10 for repeatedTest
INFO: About to execute repetition 4 of 10 for repeatedTest
INFO: About to execute repetition 5 of 10 for repeatedTest
INFO: About to execute repetition 6 of 10 for repeatedTest
INFO: About to execute repetition 7 of 10 for repeatedTest
INFO: About to execute repetition 8 of 10 for repeatedTest
INFO: About to execute repetition 9 of 10 for repeatedTest
INFO: About to execute repetition 10 of 10 for repeatedTest
INFO: About to execute repetition 1 of 5 for repeatedTestWithRepetitionInfo
INFO: About to execute repetition 2 of 5 for repeatedTestWithRepetitionInfo
INFO: About to execute repetition 3 of 5 for repeatedTestWithRepetitionInfo
INFO: About to execute repetition 4 of 5 for repeatedTestWithRepetitionInfo
INFO: About to execute repetition 5 of 5 for repeatedTestWithRepetitionInfo
INFO: About to execute repetition 1 of 1 for customDisplayName
INFO: About to execute repetition 1 of 1 for customDisplayNameWithLongPattern
INFO: About to execute repetition 1 of 5 for repeatedTestInGerman
INFO: About to execute repetition 2 of 5 for repeatedTestInGerman
INFO: About to execute repetition 3 of 5 for repeatedTestInGerman
INFO: About to execute repetition 4 of 5 for repeatedTestInGerman
INFO: About to execute repetition 5 of 5 for repeatedTestInGerman
....

[source,java]
----
include::{testDir}/example/RepeatedTestsDemo.java[tags=user_guide]
----

Unicodeテーマを有効にした `ConsoleLauncher` で `RepeatedTestsDemo` を実行すると、
コンソールには以下のように出力されます。

....
├─ RepeatedTestsDemo ✔
│  ├─ repeatedTest() ✔
│  │  ├─ repetition 1 of 10 ✔
│  │  ├─ repetition 2 of 10 ✔
│  │  ├─ repetition 3 of 10 ✔
│  │  ├─ repetition 4 of 10 ✔
│  │  ├─ repetition 5 of 10 ✔
│  │  ├─ repetition 6 of 10 ✔
│  │  ├─ repetition 7 of 10 ✔
│  │  ├─ repetition 8 of 10 ✔
│  │  ├─ repetition 9 of 10 ✔
│  │  └─ repetition 10 of 10 ✔
│  ├─ repeatedTestWithRepetitionInfo(RepetitionInfo) ✔
│  │  ├─ repetition 1 of 5 ✔
│  │  ├─ repetition 2 of 5 ✔
│  │  ├─ repetition 3 of 5 ✔
│  │  ├─ repetition 4 of 5 ✔
│  │  └─ repetition 5 of 5 ✔
│  ├─ Repeat! ✔
│  │  └─ Repeat! 1/1 ✔
│  ├─ Details... ✔
│  │  └─ Details... :: repetition 1 of 1 ✔
│  └─ repeatedTestInGerman() ✔
│     ├─ Wiederholung 1 von 5 ✔
│     ├─ Wiederholung 2 von 5 ✔
│     ├─ Wiederholung 3 von 5 ✔
│     ├─ Wiederholung 4 von 5 ✔
│     └─ Wiederholung 5 von 5 ✔
....


[[writing-tests-parameterized-tests]]
=== パラメーター化テスト

[TIP]
====
訳注：計算機科学の用語に従うのであれば、
_argument_ を _実引数（メソッドを呼び出す側から見た引数）_、
_parameter_ を _仮引数（メソッドを呼ばれる側から見た引数）_
と区別して訳すべきだが、パラメーター化テストの説明では前者の
_argument_ を _パラメーター_ と訳してしまった方が
直感的にイメージしやすいと訳者は考える。
原文でも両者の区別があいまいな箇所があるため、以降では
訳者の解釈に従って意訳している。気になる場合は、原文をあたること。
====

パラメーター化テストは、異なる実引数でテストを複数回実行できるようにします。
通常の `@Test` メソッドに似ていますが、`{ParameterizedTest}` アノテーションを
使って宣言します。各呼び出しに対するパラメーターを生成するための _ソース (source)_
を少なくとも1つは宣言し、そのパラメーターはテストメソッドで _消費 (consume)_
する必要があります。

以下は、パラメーターのソースとして `String` 配列を指定するために `@ValueSource`
アノテーションを使用した例を示しています。

[source,java,indent=0]
----
include::{testDir}/example/ParameterizedTestDemo.java[tags=first_example]
----

上のパラメーター化テストメソッドを実行すると、各実行が別々にレポートされます。
例えば、`ConsoleLauncher` を使うと次のように出力されます。

....
palindromes(String) ✔
├─ [1] racecar ✔
├─ [2] radar ✔
└─ [3] able was I ere I saw elba ✔
....

WARNING: パラーメーター化テストは、現在 _実験中_ の機能です。
詳細は、<<api-evolution-experimental-apis>> の表を確認してください。

[[writing-tests-parameterized-tests-setup]]
==== 必要なセットアップ

パラメーター化テストを使うには、`junit-jupiter-params` への依存を追加する必要があります。
詳細は、<<dependency-metadata>> を参照してください。

[[writing-tests-parameterized-tests-consuming-arguments]]
==== パラメーターの消費

パラメーター化テストのメソッドは、通常は設定されたソース
(<<writing-tests-parameterized-tests-sources>> 参照)
からパラメーターのインデックスとメソッドの仮引数のインデックスが1対1となるように
パラメーターを _消費_ します
(<<writing-tests-parameterized-tests-sources-CsvSource>> の例を参照)。
しかし、ソースのすべてのパラメーターを単一のオブジェクトに _集約_
してメソッドに渡すこともできます
(<<writing-tests-parameterized-tests-argument-aggregation>> 参照)。
また、`ParameterResolver` を使って追加の引数を渡すこともできます
(例えば、`TestInfo` や `TestReporter` のインスタンスなど)。
パラメーター化テストメソッドは、次のルールに従って仮引数を宣言しなければなりません。

* 最初に、_インデックス付き引数 (indexed argument)_ を0個以上宣言します
* その次に、_アグリゲーター (aggregator)_ を0個以上宣言します
* 最後に、`ParameterResolver` によって渡される引数を0個以上宣言します

ここで、_インデックス付き引数 (indexed argument)_ は、`ArgumentsProvider`
が生成した `Arguments` 中の指定されたインデックスに対するパラメーターです。
このパラメーターは、パラメーター化テストメソッドの仮引数リストで
同じインデックスに実引数として渡されます。
_アグリゲーター (aggregator)_ は、`ArgumentsAccessor` 型または `@AggregateWith`
アノテーションが付与された仮引数です。

[[writing-tests-parameterized-tests-sources]]
==== パラメーターのソース

JUnit Jupiterは、あらかじめいくつかの _ソース_ アノテーションを提供しています。
以降では、これらのアノテーションについて簡単な説明とサンプルを示します。
より詳細な情報は、`{params-provider-package}` パッケージのJavadocを参照してください。

[[writing-tests-parameterized-tests-sources-ValueSource]]
===== @ValueSource

`@ValueSource` は、最もシンプルなソースの1つです。リテラル値の配列を指定できますが、
パラメーター化テストの1回の実行につき1つのパラメーターしか与えることができません。

`@ValueSource` では、以下の型のリテラル値がサポートされています。

- `short`
- `byte`
- `int`
- `long`
- `float`
- `double`
- `char`
- `java.lang.String`
- `java.lang.Class`

例えば、次の `@ParameterizedTest` メソッドは、値 `1`, `2`, `3` をパラメーターとして
3回呼び出されます。

[source,java,indent=0]
----
include::{testDir}/example/ParameterizedTestDemo.java[tags=ValueSource_example]
----

[[writing-tests-parameterized-tests-sources-null-and-empty]]
===== null と空のソース

エッジケースを確認し、_まずい入力_ が与えられたときのソフトウェアの正しい振る舞いを検証するために、
パラメーター化テストに `null` や _空の_ 値を与えることは役に立ちます。
以下のアノテーションは、1 引数のパラメーター化テストに `null` や空値を与える
ソースになります。

* `{NullSource}`: 単一の `null` パラメーターを `@ParameterizedTest` メソッドに与えます。
   - `@NullSource` は、プリミティブ型のパラメーターとしては使うことができません。
* `{EmptySource}`: 単一の _空値_ を次の型のパラメーターとして `@ParameterizedTest`
  メソッドに与えます: `java.lang.String`, `java.util.List`,
  `java.util.Set`, `java.util.Map`, プリミティブ型の配列 (例えば、`int[]`, `char[][]` など),
  オブジェクトの配列 (例えば、`String[]`, `Integer[][]` など)
   - これらのサブタイプはサポートされません。
* `{NullAndEmptySource}`: `@NullSource` と `@EmptySource` の機能を組み合わせた
  _合成アノテーション_ です。

パラメーター化テストに複数の _空文字列_ や _空白文字列_ を与える必要がある場合、
<<writing-tests-parameterized-tests-sources-ValueSource>> を使って実現できます。
-- 例えば、`@ValueSource(strings = {" ", " ", "\t", "\n"})` のようにです。

`null` と _空文字列_、_空白文字列_ などより広い範囲の入力をテストするためには、
`@NullSource` と `@EmptySource`、`@ValueSource` を組み合わせることもできます。
次の例は、その実現方法を示しています。

[source,java,indent=0]
----
include::{testDir}/example/ParameterizedTestDemo.java[tags=NullAndEmptySource_example1]
----

合成アノテーションの `@NullAndEmptySource` を使えば、上の例は次のようにシンプルにできます。

[source,java,indent=0]
----
include::{testDir}/example/ParameterizedTestDemo.java[tags=NullAndEmptySource_example2]
----

NOTE: どちらの `nullEmptyAndBlankStrings(String)` パラメーター化テストメソッドも、
6 回呼び出されます: 1 回は `null` に対して、1 回は空文字列に対して、4 回は
`@ValueSource` で明示的に与えられた空白文字列に対してです。

[[writing-tests-parameterized-tests-sources-EnumSource]]
===== @EnumSource

`@EnumSource` は、`Enum` 定数を指定する便利な方法を提供します。このアノテーションでは、
省略可能な `names` 属性を指定すると、その列挙定数だけが使われます。
省略すると、次の例のようにすべての列挙定数が使われます。

[source,java,indent=0]
----
include::{testDir}/example/ParameterizedTestDemo.java[tags=EnumSource_example]
----

[source,java,indent=0]
----
include::{testDir}/example/ParameterizedTestDemo.java[tags=EnumSource_include_example]
----

`@EnumSource` アノテーションは、テストメソッドに渡される列挙定数をさらに細かく制御するために、
省略可能な `mode` 属性も提供しています。例えば、一部の名前をもつ列挙定数だけ除外したり、
正規表現で列挙定数を指定したりすることができます。

[source,java,indent=0]
----
include::{testDir}/example/ParameterizedTestDemo.java[tags=EnumSource_exclude_example]
----

[source,java,indent=0]
----
include::{testDir}/example/ParameterizedTestDemo.java[tags=EnumSource_regex_example]
----

[[writing-tests-parameterized-tests-sources-MethodSource]]
===== @MethodSource

`{MethodSource}` は、テストクラスまたは外部のクラスの _ファクトリ_
メソッドによるパラメーターの指定を可能にします。

テストクラス内のファクトリメソッドは、`@TestInstance(Lifecycle.PER_CLASS)`
アノテーションが付与されていない限り、`static` でなければいけません。
一方、外部クラスのファクトリメソッドは、常に `static` でなければいけません。
これらのファクトリメソッドは、引数を受け取ることもできません。

ファクトリメソッドは、 `@ParameterizedTest` メソッドの各呼び出しに対して
実際の引数として渡される _パラメーター_ の _ストリーム_ を生成しなければなりません。
一般的に言えば、これは `Arguments` の `Stream` (つまり、`Stream<Arguments>`)
となりますが、実際の戻り値は様々な型をとりえます。ここでいう "ストリーム" とは、
JUnitが確実に `Stream` へ変換できるものであれば何でも構いません。例えば、
`Stream`, `DoubleStream`, `LongStream`, `IntStream`, `Collection`,
`Iterator`, `Iterable`, オブジェクト配列, プリミティブ型の配列などです。
ストリームの "パラメーター" は、 `Arguments` のインスタンス、オブジェクト配列
(つまり、`Object[]`)、あるいはパラメーター化テストメソッドが1つだけしか
パラメーターを受け取らない場合には単一の値となります。

パラメーターが1つしか必要なければ、次の例のようにパラメーターのインスタンスを
`Stream` で返すことができます。

[source,java,indent=0]
----
include::{testDir}/example/ParameterizedTestDemo.java[tags=simple_MethodSource_example]
----

もし `@MethodSource` でファクトリメソッドの名前を明示的に指定しなかった場合、JUnit Jupiter
は `@ParameterizedTest` メソッドと同じ名前をもつファクトリメソッドを自動的に探します。

[source,java,indent=0]
----
include::{testDir}/example/ParameterizedTestDemo.java[tags=simple_MethodSource_without_value_example]
----

プリミティブ型のストリーム (`DoubleStream`, `IntStream`, `LongStream`)
もサポートされています。

[source,java,indent=0]
----
include::{testDir}/example/ParameterizedTestDemo.java[tags=primitive_MethodSource_example]
----

パラメーター化テストメソッドが複数の仮引数を宣言している場合、以下で示すように `Arguments`
インスタンスかオブジェクト配列を要素とするコレクション、ストリーム、配列のいずれかを返す必要があります
（サポートされる戻り値型のさらなる詳細は、`{MethodSource}` のJavadocを参照）。
`arguments(Object...)` は `Arguments` インターフェースで定義されるstaticファクトリメソッドである
点に注意してください。また、`Arguments.of(Object...)` を `arguments(Object...)`
の代わりに使用することもできます。

[source,java,indent=0]
----
include::{testDir}/example/ParameterizedTestDemo.java[tags=multi_arg_MethodSource_example]
----

次の例で示すように、_メソッドの完全修飾名_ を指定することで、外部の `static` な
_ファクトリ_ メソッドを参照することもできます。

[source,java,indent=0]
----
package example;

include::{testDir}/example/ExternalMethodSourceDemo.java[tags=external_MethodSource_example]
----

[[writing-tests-parameterized-tests-sources-CsvSource]]
===== @CsvSource

`@CsvSource` は、パラメーターのリストをカンマ区切りの値（`String` リテラル）
で指定できるようにします。

[source,java,indent=0]
----
include::{testDir}/example/ParameterizedTestDemo.java[tags=CsvSource_example]
----

`@CsvSource` は、シングルクォート `'` を引用符として使います。
上の例の `'lemon, lime'` と、以下のテーブルを参照してください。
引用符で囲まれた空の値 `''` は空の `String` になりますが、
（引用符で囲まれない）完全に _空_ の値は `null` と解釈されます。
`null` の代入先の型がプリミティブ型の場合は、
`ArgumentConversionException` が発生します。

[cols="50,50"]
|===
| Example Input                            | Resulting Argument List

| `@CsvSource({ "apple, banana" })`        | `"apple"`, `"banana"`
| `@CsvSource({ "apple, 'lemon, lime'" })` | `"apple"`, `"lemon, lime"`
| `@CsvSource({ "apple, ''" })`            | `"apple"`, `""`
| `@CsvSource({ "apple, " })`              | `"apple"`, `null`
|===

[[writing-tests-parameterized-tests-sources-CsvFileSource]]
===== @CsvFileSource

`@CsvFileSource` は、クラスパスにあるCSVファイルを使えるようにします。
CSVファイルの各行は、パラメーター化テストの1回の実行になります。

[source,java,indent=0]
----
include::{testDir}/example/ParameterizedTestDemo.java[tags=CsvFileSource_example]
----

[source,csv,indent=0]
.two-column.csv
----
include::{testResourcesDir}/two-column.csv[]
----

NOTE: `@CsvSource` のシンタックスとは異なり、`@CsvFileSource` はダブルクォート `"`
を引用符として使います。上の例の、`"United States of America"` を参考にしてください。
引用符で囲まれた空の値 `""` は空の `String` になりますが、
（引用符で囲まれない）完全に _空_ の値は `null` と解釈されます。
`null` の代入先の型がプリミティブ型の場合は、
`ArgumentConversionException` が発生します。

[[writing-tests-parameterized-tests-sources-ArgumentsSource]]
===== @ArgumentsSource

`@ArgumentsSource` は、カスタムの再利用可能な `ArgumentsProvider`
を指定する場合に使えます。Note
that an implementation of `ArgumentsProvider` must be declared as either a top-level
class or as a `static` nested class.

[source,java,indent=0]
----
include::{testDir}/example/ParameterizedTestDemo.java[tags=ArgumentsSource_example]
----

[source,java,indent=0]
----
include::{testDir}/example/ParameterizedTestDemo.java[tags=ArgumentsProvider_example]
----


[[writing-tests-parameterized-tests-argument-conversion]]
==== パラメーターの変換

[[writing-tests-parameterized-tests-argument-conversion-widening]]
===== 拡大変換

JUnit Jupiterは、`@ParameterizedTest` に与えられたパラメーターに対して、
https://docs.oracle.com/javase/specs/jls/se8/html/jls-5.html#jls-5.1.2[プリミティブ型の
拡大変換] をサポートしています。例えば、`@ValueSource(ints = { 1, 2, 3 })`
アノテーションが付与されたパラメーター化テストでは、テストメソッドの仮引数を
`int` 型だけでなく `long` や `float`、`double` 型でも宣言することができます。

[[writing-tests-parameterized-tests-argument-conversion-implicit]]
===== 暗黙的な変換

`@CsvSource` のようなユースケースをサポートするために、JUnit Jupiter
は多くの組み込みの型変換を提供しています。
変換処理は、メソッドの仮引数の型に依存します。

例えば、`@ParameterizedTest` が `TimeUnit` 型の仮引数を宣言し、
ソースから実際に渡される型が `String` の場合、その文字列は対応する
`TimeUnit` 列挙定数に自動的に変換されます。

[source,java,indent=0]
----
include::{testDir}/example/ParameterizedTestDemo.java[tags=implicit_conversion_example]
----

`String` インスタンスは、次のようなターゲット型に暗黙的に変換されます。

NOTE: Decimal, hexadecimal, and octal `String` literals will be converted to their
integral types: `byte`, `short`, `int`, `long`, and their boxed counterparts.

[[writing-tests-parameterized-tests-argument-conversion-implicit-table]]
[cols="10,90"]
|===
| Target Type | Example

| `boolean`/`Boolean`        | `"true"`                                 -> `true`
| `byte`/`Byte`              | `"15"`, `"0xF"`, or `"017"`              -> `(byte) 15`
| `char`/`Character`         | `"o"`                                    -> `'o'`
| `short`/`Short`            | `"15"`, `"0xF"`, or `"017"`              -> `(short) 15`
| `int`/`Integer`            | `"15"`, `"0xF"`, or `"017"`              -> `15`
| `long`/`Long`              | `"15"`, `"0xF"`, or `"017"`              -> `15L`
| `float`/`Float`            | `"1.0"`                                  -> `1.0f`
| `double`/`Double`          | `"1.0"`                                  -> `1.0d`
| `Enum` subclass            | `"SECONDS"`                              -> `TimeUnit.SECONDS`
| `java.io.File`             | `"/path/to/file"`                        -> `new File("/path/to/file")`
| `java.lang.Class`          | `"java.lang.Integer"`                    -> `java.lang.Integer.class` _(use `$` for nested classes, e.g. `"java.lang.Thread$State"`)_
| `java.lang.Class`          | `"byte"`                                 -> `byte.class` _(primitive types are supported)_
| `java.lang.Class`          | `"char[]"`                               -> `char[].class` _(array types are supported)_
| `java.math.BigDecimal`     | `"123.456e789"`                          -> `new BigDecimal("123.456e789")`
| `java.math.BigInteger`     | `"1234567890123456789"`                  -> `new BigInteger("1234567890123456789")`
| `java.net.URI`             | `"http://junit.org/"`                    -> `URI.create("http://junit.org/")`
| `java.net.URL`             | `"http://junit.org/"`                    -> `new URL("http://junit.org/")`
| `java.nio.charset.Charset` | `"UTF-8"`                                -> `Charset.forName("UTF-8")`
| `java.nio.file.Path`       | `"/path/to/file"`                        -> `Paths.get("/path/to/file")`
| `java.time.Instant`        | `"1970-01-01T00:00:00Z"`                 -> `Instant.ofEpochMilli(0)`
| `java.time.LocalDateTime`  | `"2017-03-14T12:34:56.789"`              -> `LocalDateTime.of(2017, 3, 14, 12, 34, 56, 789_000_000)`
| `java.time.LocalDate`      | `"2017-03-14"`                           -> `LocalDate.of(2017, 3, 14)`
| `java.time.LocalTime`      | `"12:34:56.789"`                         -> `LocalTime.of(12, 34, 56, 789_000_000)`
| `java.time.OffsetDateTime` | `"2017-03-14T12:34:56.789Z"`             -> `OffsetDateTime.of(2017, 3, 14, 12, 34, 56, 789_000_000, ZoneOffset.UTC)`
| `java.time.OffsetTime`     | `"12:34:56.789Z"`                        -> `OffsetTime.of(12, 34, 56, 789_000_000, ZoneOffset.UTC)`
| `java.time.YearMonth`      | `"2017-03"`                              -> `YearMonth.of(2017, 3)`
| `java.time.Year`           | `"2017"`                                 -> `Year.of(2017)`
| `java.time.ZonedDateTime`  | `"2017-03-14T12:34:56.789Z"`             -> `ZonedDateTime.of(2017, 3, 14, 12, 34, 56, 789_000_000, ZoneOffset.UTC)`
| `java.util.Currency`       | `"JPY"`                                  -> `Currency.getInstance("JPY")`
| `java.util.Locale`         | `"en"`                                   -> `new Locale("en")`
| `java.util.UUID`           | `"d043e930-7b3b-48e3-bdbe-5a3ccfb833db"` -> `UUID.fromString("d043e930-7b3b-48e3-bdbe-5a3ccfb833db")`
|===

[[writing-tests-parameterized-tests-argument-conversion-implicit-fallback]]
====== String → Object変換のフォールバック

上の表で示した文字列からターゲット型への暗黙的な変換に加えて、JUnit Jupiter
は `String` 型からターゲット型に自動変換するフォールバックの仕組みも提供しています。
この変換は、ターゲット型が以下に示す _ファクトリメソッド_ か _ファクトリコンストラクタ_
を1つだけ宣言している場合に機能します。

- __factory method__: a non-private, `static` method declared in the target type that
  accepts a single `String` argument and returns an instance of the target type. The name
  of the method can be arbitrary and need not follow any particular convention.
- __factory constructor__: a non-private constructor in the target type that accepts a
  single `String` argument. Note that the target type must be declared as either a
  top-level class or as a `static` nested class.

NOTE: 複数の _ファクトリメソッド_ が見つかった場合、それらは無視されます。
_ファクトリメソッド_ と _ファクトリコンストラクタ_ が両方見つかった場合は、
ファクトリメソッドの方が使われます。

例えば、次の `@ParameterizedTest` メソッドでは、`Book` 型の引数は
`Book.fromTitle(String)` ファクトリメソッドに本のタイトルとして `"42 Cats"`
を渡して実行することで作られます。

[source,java,indent=0]
----
include::{testDir}/example/ParameterizedTestDemo.java[tags=implicit_fallback_conversion_example]
----

[source,java,indent=0]
----
include::{testDir}/example/ParameterizedTestDemo.java[tags=implicit_fallback_conversion_example_Book]
----

[[writing-tests-parameterized-tests-argument-conversion-explicit]]
===== 明示的な変換

Instead of relying on implicit argument conversion you may explicitly specify an
`ArgumentConverter` to use for a certain parameter using the `@ConvertWith` annotation
like in the following example. Note that an implementation of `ArgumentConverter` must be
declared as either a top-level class or as a `static` nested class.

[source,java,indent=0]
----
include::{testDir}/example/ParameterizedTestDemo.java[tags=explicit_conversion_example]
----

[source,java,indent=0]
----
include::{testDir}/example/ParameterizedTestDemo.java[tags=explicit_conversion_example_ToStringArgumentConverter]
----

明示的な型変換器はテストまたは拡張機能の作者に実装されることを想定しています。
そのため、`junit-jupiter-params` モジュールは参照実装として `JavaTimeArgumentConverter`
の1つだけしか提供していません。これは、合成アノテーション `JavaTimeConversionPattern`
経由で使用できます。

[source,java,indent=0]
----
include::{testDir}/example/ParameterizedTestDemo.java[tags=explicit_java_time_converter]
----

[[writing-tests-parameterized-tests-argument-aggregation]]
==== パラメーターの集約

デフォルトでは、`@ParameterizedTest` のメソッドに与えられる各パラメーター
は、1つの仮引数に対応します。結果として、ソースが多数のパラメーターを生成する場合、
メソッドシグネチャが大きく（仮引数が多く）なります。

そのような場合には、複数の仮引数を定義する代わりに `{ArgumentsAccessor}`
を使うことができます。このAPIを使うと、テストメソッドに渡した単一の
`{ArgumentsAccessor}` 経由ですべてのパラメーターにアクセスすることができます。
加えて、
<<writing-tests-parameterized-tests-argument-conversion-implicit>>
で説明した型変換もサポートされます。

[source,java,indent=0]
----
include::{testDir}/example/ParameterizedTestDemo.java[tags=ArgumentsAccessor_example]
----

`ArgumentsAccessor` 型の仮引数には、自動的に `ArgumentsAccessor` のインスタンスが注入されます。

[[writing-tests-parameterized-tests-argument-aggregation-custom]]
===== カスタムアグリゲーター

`ArgumentsAccessor` を使って `@ParameterizedTest` メソッドのパラメーターに
直接アクセスする以外に、JUnit Jupiterはカスタムの再利用可能な
_アグリゲーター (aggregator)_ もサポートしています。

カスタムアグリゲーターを使うには、`{ArgumentsAggregator}` インターフェースを実装し、
`@ParameterizedTest` メソッドの仮引数に `@AggregateWith`
アノテーションを使って登録します。集約した結果は、
パラメーター化テストが実行されるときに
対象の仮引数に対する実引数として渡されます。
Note
that an implementation of `ArgumentsAggregator` must be declared as either a top-level
class or as a `static` nested class.

[source,java,indent=0]
----
include::{testDir}/example/ParameterizedTestDemo.java[tags=ArgumentsAggregator_example]
----

[source,java,indent=0]
----
include::{testDir}/example/ParameterizedTestDemo.java[tags=ArgumentsAggregator_example_PersonAggregator]
----

複数のパラメーター化テストメソッドに対して何回も `@AggregateWith(MyTypeAggregator.class)`
を宣言していることに気付いたら、`@AggregateWith(MyTypeAggregator.class)`
をメタアノテーションとして付与した `@CsvToMyType` のようなカスタム _合成アノテーション_
を作りたくなるでしょう。
次の例は、実際にカスタムの `@CsvToPerson` アノテーションを作る例を示しています。

[source,java,indent=0]
----
include::{testDir}/example/ParameterizedTestDemo.java[tags=ArgumentsAggregator_with_custom_annotation_example]
----

[source,java,indent=0]
----
include::{testDir}/example/ParameterizedTestDemo.java[tags=ArgumentsAggregator_with_custom_annotation_example_CsvToPerson]
----


[[writing-tests-parameterized-tests-display-names]]
==== 表示名のカスタマイズ

デフォルトでは、パラメーター化テストの表示名には、呼び出しインデックスとすべてのパラメーターの
`String` 表現が含まれます。ただし、`@ParameterizedTest` アノテーションの `name`
属性を指定すれば、次の例のようにカスタマイズすることもできます。

[source,java,indent=0]
----
include::{testDir}/example/ParameterizedTestDemo.java[tags=custom_display_names]
----

上のメソッドを `ConsoleLauncher` で実行すると、以下のような出力となります。

....
Display name of container ✔
├─ 1 ==> fruit='apple', rank=1 ✔
├─ 2 ==> fruit='banana', rank=2 ✔
└─ 3 ==> fruit='lemon, lime', rank=3 ✔
....

次のプレースホルダーがサポートされています。

[cols="20,80"]
|===
| Placeholder       | Description

| `{index}`         | 現在の呼び出しインデックス（1始まり）
| `{arguments}`     | カンマ区切りの完全なパラメーターのリスト
| `{0}`, `{1}`, ... | 個々のパラメーター
|===


[[writing-tests-parameterized-tests-lifecycle-interop]]
==== ライフサイクルと相互運用性

パラメーター化テストの各呼び出しは、通常の `@Test` メソッドと同じライフサイクルをもちます。
例えば、`@BeforeEach` メソッドが各呼び出しの前に実行されます。
<<writing-tests-dynamic-tests>> と同様に、パラメーター化テストの各呼び出しは、
IDEのテストツリーの中に1つずつ表示されます。同じテストクラスの中で、
`@Test` メソッドと `@ParameterizedTest` メソッドを混在させるのも自由です。

`ParameterResolver` 拡張を `@ParameterizedTest` メソッドと使いたいかもしれません。
その場合は、パラメーターのソースから渡される引数を先に宣言する必要があります。
テストクラスは、パラメーター化テストだけでなく通常のテストを含んでいる可能性もあるので、
パラメーターをライフサイクルメソッド (例えば、`@BeforeEach`)
やテストコンストラクタに渡すことができません。

[source,java,indent=0]
----
include::{testDir}/example/ParameterizedTestDemo.java[tags=ParameterResolver_example]
----


[[writing-tests-test-templates]]
=== テストテンプレート

`{TestTemplate}` メソッドは、通常のテストケースではなく、テストケースのテンプレートです。
登録したプロバイダが返す実行コンテキストの数に応じて、複数回呼び出されるよう設計されています。
そのため、テストテンプレートは `{TestTemplateInvocationContextProvider}`
と一緒に使う必要があります。
テストテンプレートメソッドの各呼び出しは、ライフサイクルコールバックや拡張機能など、
通常の `@Test` メソッドの実行と同じように振る舞います。使用例については、
<<extensions-test-templates>> を参照してください。

NOTE: <<writing-tests-repeated-tests>> and <<writing-tests-parameterized-tests>> are
built-in specializations of test templates.

[[writing-tests-dynamic-tests]]
=== 動的テスト

<<writing-tests-annotations>> で説明したJUnit Jupiterの標準の `@Test`
アノテーションは、JUnit 4の `@Test` アノテーションととてもよく似ています。
どちらもテストケースを実装するメソッドを示します。これらのテストケースは、
完全にコンパイル時に指定され、その振る舞いが実行時には変えられないという意味で、
静的なものです。 _前提条件 (Assumption) の機能は、動的な振る舞いの基本を
提供しますが、表現力は意図的に限定されています。_

JUnit Jupiterでは、これらの標準的なテストに加えて、完全に新しいプログラミング
モデルが導入されました。それは、_動的テスト_ です。動的テストは、
`@TestFactory` アノテーションを付与したファクトリメソッドによって、
実行時に生成されます。

In contrast to `@Test` methods, a `@TestFactory` method is not itself a test case but
rather a factory for test cases. Thus, a dynamic test is the product of a factory.
Technically speaking, a `@TestFactory` method must return a single `DynamicNode` or a
`Stream`, `Collection`, `Iterable`, `Iterator`, or array of `DynamicNode` instances.
Instantiable subclasses of `DynamicNode` are `DynamicContainer` and `DynamicTest`.
`DynamicContainer` instances are composed of a _display name_ and a list of dynamic child
nodes, enabling the creation of arbitrarily nested hierarchies of dynamic nodes.
`DynamicTest` instances will be executed lazily, enabling dynamic and even
non-deterministic generation of test cases.

`@TestFactory` が返した `Stream` は、`stream.close()` 呼び出しによって
適切にクローズされます。これにより、`Files.lines()` などのリソースを
安全に使うことができます。

`@Test` メソッドと同じように、`@TestFactory` メソッドも `private` または
`static` であってはいけません。また、`ParameterResolvers` で解決される
パラメーターを宣言することもできます。

`DynamicTest` は、実行時に生成されるテストケースで、_表示名_ と `Executable`
で構成されます。`Executable` は、`@FunctionalInterface` であり、
動的テストの実装が _ラムダ式_ または _メソッド参照_ で与えられることを意味します。

.動的テストのライフサイクル
WARNING: 動的テストの実行ライフサイクルは、通常の `@Test` とはかなり違います。
特に、個々の動的テストに対しては、ライフサイクルコールバックはありません。
これは、`@BeforeEach` や `@AfterEach` メソッドとその拡張コールバックが、
`@TestFactory` メソッドに対して実行され、個々の _動的テスト_
に対しては実行されないことを意味しています。言い換えれば、動的テストのラムダ式から
テストインスタンスのフィールドにアクセスしていたとしても、同じ `@TestFactory`
メソッドから生成された個々の動的テストを実行する間は、コールバックメソッドにも
拡張機能にもそのフィールドはリセットされないのです。


JUnit Jupiter {jupiter-version} の時点では、動的テストは常にファクトリメソッドで
生成しなければなりません。ただし、将来のリリースで、登録の仕組みが追加されるかもしれません。

WARNING: 動的テストは現在 _実験中_ の機能です。詳細は、
<<api-evolution-experimental-apis>> の表を参照してください。

[[writing-tests-dynamic-tests-examples]]
==== 動的テストの例

次の `DynamicTestsDemo` クラスは、テストファクトリと動的テストの例を示しています。

最初のメソッドは、不正な戻り値型を返しています。不正な戻り値型はコンパイル時には
検出できないため、実行時に検出されて `JUnitException` がスローされます。

その次の5つのメソッドは、`DynamicTest` インスタンスの `Collection`, `Iterable`,
`Iterator`, `Stream` を生成するとてもシンプルな例です。ほとんどの例は、
動的な振る舞いではなく、単にサポートされている戻り値の型をデモしています。
しかし、`dynamicTestsFromStream()` と `dynamicTestsFromIntStream()` は、
与えられた文字列リストや数値の範囲に対して簡単に動的なテストを生成できることを
示しています。

その次のメソッドは、真に動的な性質のものです。`generateRandomNumberOfTests()`
は、乱数を生成する `Iterator`、表示名ジェネレーター、テストの実行器の3つを実装し、
これらを `DynamicTest.stream()` に渡しています。
`generateRandomNumberOfTests()` の非決定的な振る舞いは、
もちろんテストの再現性に反するため注意して使うべきですが、
動的テストの高い表現力とパワーを示すのに役立っています。

最後のメソッドは、`DynamicContainer` を使って動的テストを入れ子階層にする例を示しています。

[source,java]
----
include::{testDir}/example/DynamicTestsDemo.java[tags=user_guide]
----


[[writing-tests-parallel-execution]]
=== 並列実行

.Parallel test execution is an experimental feature
WARNING: You're invited to give it a try and provide feedback to the JUnit team so they
can improve and eventually <<api-evolution, promote>> this feature.

By default, JUnit Jupiter tests are run sequentially in a single thread. Running tests in
parallel -- for example, to speed up execution -- is available as an opt-in feature since
version 5.3. To enable parallel execution, set the
`junit.jupiter.execution.parallel.enabled` configuration parameter to `true` -- for
example, in `junit-platform.properties` (see <<running-tests-config-params>> for other
options).

Please note that enabling this property is only the first step required to execute tests
in parallel. If enabled, test classes and methods will still be executed sequentially by
default. Whether or not a node in the test tree is executed concurrently is controlled by
its execution mode. The following two modes are available.

`SAME_THREAD`::
  Force execution in the same thread used by the parent. For example, when used on a test
  method, the test method will be executed in the same thread as any `@BeforeAll` or
  `@AfterAll` methods of the containing test class.

`CONCURRENT`::
  Execute concurrently unless a resource lock forces execution in the same thread.

By default, nodes in the test tree use the `SAME_THREAD` execution mode. You can change
the default by setting the `junit.jupiter.execution.parallel.mode.default` configuration
parameter. Alternatively, you can use the `{Execution}` annotation to change the
execution mode for the annotated element and its subelements (if any) which allows you to
activate parallel execution for individual test classes, one by one.

[source,properties]
.Configuration parameters to execute all tests in parallel
----
junit.jupiter.execution.parallel.enabled = true
junit.jupiter.execution.parallel.mode.default = concurrent
----

The default execution mode is applied to all nodes of the test tree with a few notable
exceptions, namely test classes that use the `Lifecycle.PER_CLASS` mode or a
`{MethodOrderer}` (except for `{Random}`). In the former case, test authors have to
ensure that the test class is thread-safe; in the latter, concurrent execution might
conflict with the configured execution order. Thus, in both cases, test methods in such
test classes are only executed concurrently if the `@Execution(CONCURRENT)` annotation is
present on the test class or method.

All nodes of the test tree that are configured with the `CONCURRENT` execution mode will
be executed fully in parallel according to the provided
<<writing-tests-parallel-execution-config, configuration>> while observing the
declarative <<writing-tests-parallel-execution-synchronization, synchronization>>
mechanism. Please note that <<running-tests-capturing-output>> needs to be enabled
separately.

[[writing-tests-parallel-execution-config]]
==== 設定

Properties such as the desired parallelism and the maximum pool size can be configured
using a `{ParallelExecutionConfigurationStrategy}`. The JUnit Platform provides two
implementations out of the box: `dynamic` and `fixed`. Alternatively, you may implement a
`custom` strategy.

To select a strategy, set the `junit.jupiter.execution.parallel.config.strategy`
configuration parameter to one of the following options.

`dynamic`::
  利用可能なプロセッサ／コア数に、設定パラメーター
  `junit.jupiter.execution.parallel.config.dynamic.factor` の値
  （デフォルトは `1`）を掛けた数に基づいて並列数を計算します。

`fixed`::
  Uses the mandatory `junit.jupiter.execution.parallel.config.fixed.parallelism`
  configuration parameter as the desired parallelism.

`custom`::
  Allows you to specify a custom `{ParallelExecutionConfigurationStrategy}`
  implementation via the mandatory `junit.jupiter.execution.parallel.config.custom.class`
  configuration parameter to determine the desired configuration.

If no configuration strategy is set, JUnit Jupiter uses the `dynamic` configuration
strategy with a factor of `1`. Consequently, the desired parallelism will be equal to the
number of available processors/cores.

.Parallelism does not imply maximum number of concurrent threads
NOTE: JUnit Jupiter does not guarantee that the number of concurrently executing tests
will not exceed the configured parallelism. For example, when using one of the
synchronization mechanisms described in the next section, the `ForkJoinPool` that is used
behind the scenes may spawn additional threads to ensure execution continues with
sufficient parallelism. Thus, if you require such guarantees in a test class, please use
your own means of controlling concurrency.

[[writing-tests-parallel-execution-synchronization]]
==== 同期化

In addition to controlling the execution mode using the `{Execution}` annotation, JUnit
Jupiter provides another annotation-based declarative synchronization mechanism. The
`{ResourceLock}` annotation allows you to declare that a test class or method uses a
specific shared resource that requires synchronized access to ensure reliable test
execution. The shared resource is identified by a unique name which is a `String`. The
name can be user-defined or one of the predefined constants in `{Resources}`:
`SYSTEM_PROPERTIES`, `SYSTEM_OUT`, `SYSTEM_ERR`, `LOCALE`, or `TIME_ZONE`.

If the tests in the following example were run in parallel _without_ the use of
{ResourceLock}, they would be _flaky_. Sometimes they would pass, and at other times they
would fail due to the inherent race condition of writing and then reading the same JVM
System Property.

When access to shared resources is declared using the {ResourceLock} annotation, the
JUnit Jupiter engine uses this information to ensure that no conflicting tests are run in
parallel.

In addition to the `String` that uniquely identifies the shared resource, you may specify
an access mode. Two tests that require `READ` access to a shared resource may run in
parallel with each other but not while any other test that requires `READ_WRITE` access
to the same shared resource is running.

[source,java]
----
include::{testDir}/example/SharedResourcesDemo.java[tags=user_guide]
----


[[writing-tests-built-in-extensions]]
=== Built-in Extensions

While the JUnit team encourages reusable extensions to be packaged and maintained in
separate libraries, the JUnit Jupiter API artifact includes a few user-facing extension
implementations that are considered so generally useful that users shouldn't have to add
another dependency.

[[writing-tests-built-in-extensions-TempDirectory]]
==== The TempDirectory Extension

.`@TempDir` is an experimental feature
WARNING: You're invited to give it a try and provide feedback to the JUnit team so they
can improve and eventually <<api-evolution, promote>> this feature.

The built-in `{TempDirectory}` extension is used to create and clean up a temporary
directory for an individual test or all tests in a test class. It is registered by
default. To use it, annotate a field of type `java.nio.file.Path` or `java.io.File` with
`{TempDir}` or add a parameter of type `java.nio.file.Path` or `java.io.File` annotated
with `@TempDir` to a lifecycle method or test method.

For example, the following test declares a parameter annotated with `@TempDir` for a
single test method, creates and writes to a file in the temporary directory, and checks
its content.

[source,java,indent=0]
.A test method that requires a temporary directory
----
include::{testDir}/example/TempDirectoryDemo.java[tags=user_guide_parameter_injection]
----

WARNING: `@TempDir` is not supported on constructor parameters. If you wish to retain a
single reference to a temp directory across lifecycle methods and the current test method,
please use field injection, by annotating an instance field with `@TempDir`.

The following example stores a _shared_ temporary directory in a `static` field. This
allows the same `sharedTempDir` to be used in all lifecycle methods and test methods of
the test class.

[source,java,indent=0]
.A test class that shares a temporary directory across test methods
----
include::{testDir}/example/TempDirectoryDemo.java[tags=user_guide_field_injection]
----
