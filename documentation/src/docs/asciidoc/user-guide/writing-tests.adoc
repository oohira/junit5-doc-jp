[[writing-tests]]
== テストを書く

[source,java,indent=0]
.最初のテストケース
----
include::{testDir}/example/FirstJUnit5Tests.java[tags=user_guide]
----

[[writing-tests-annotations]]
=== アノテーション

JUnit Jupiterは、テストを構成し、フレームワークを拡張するために、次のアノテーションをサポートします。

中心となるすべてのアノテーションは、 `junit-jupiter-api` モジュールの `{api-package}` パッケージに含まれます。

[cols="20,80"]
|===
| アノテーション         | 説明

| `@Test`              | このメソッドが、テストメソッドであることを示します。JUnit 4の `@Test` アノテーションとは異なり、このアノテーションはどんな属性も宣言しません。というのも、JUnit Jupiterのテスト拡張は、それ専用のアノテーションベースで行われるからです。このメソッドは、_オーバーライド_ されない限り、_継承_ されます。
| `@ParameterizedTest` | このメソッドが、<<writing-tests-parameterized-tests, パラメーター化テスト>> であることを示します。このメソッドは、_オーバーライド_ されない限り、_継承_ されます。
| `@RepeatedTest`      | このメソッドが、<<writing-tests-repeated-tests, 繰り返しテスト>> のためのテストテンプレートであることを示します。このメソッドは、_オーバーライド_ されない限り、_継承_ されます。
| `@TestFactory`       | このメソッドが、<<writing-tests-dynamic-tests, 動的テスト>> のためのテストファクトリであることを示します。このメソッドは、_オーバーライド_ されない限り、_継承_ されます。
| `@TestInstance`      | アノテーションを付与したテストクラスに対して、<<writing-tests-test-instance-lifecycle, テストインスタンスのライフサイクル>> を設定するために使われます。このアノテーションは、_継承_ されます。
| `@TestTemplate`      | このメソッドが、<<writing-tests-test-templates, テストケースのテンプレート>> であることを示します。このメソッドは、登録した <<extensions-test-templates, プロバイダ>> が返す実行コンテキストの数に応じて、複数回呼び出されます。このメソッドは、_オーバーライド_ されない限り、_継承_ されます。
| `@DisplayName`       | テストクラスやテストメソッドにカスタムの表示名を指定します。このアノテーションは、_継承_ されません。
| `@BeforeEach`        | このメソッドが、現在のクラスの `@Test`, `@RepeatedTest`, `@ParameterizedTest`, `@TestFactory` メソッドの _前に毎回_ 実行されるよう指定します。JUnit 4の `@Before` と同じです。このメソッドは、_オーバーライド_ されない限り、_継承_ されます。
| `@AfterEach`         | このメソッドが、現在のクラスの `@Test`, `@RepeatedTest`, `@ParameterizedTest`, `@TestFactory` メソッドの _後に毎回_ 実行されるよう指定します。JUnit 4の `@After` と同じです。このメソッドは、_オーバーライド_ されない限り、_継承_ されます。
| `@BeforeAll`         | このメソッドが、現在のクラスの *すべての* `@Test`, `@RepeatedTest`, `@ParameterizedTest`, `@TestFactory` メソッドの _前に一度だけ_ 実行されるよう指定します。JUnit 4の `@BeforeClass` と同じです。 このメソッドは、（_隠す_ か _オーバーライドする_ かしない限り）_継承_ されますが、（<<writing-tests-test-instance-lifecycle, テストインスタンスのライフサイクル>> に "per-class" が使われない限り）`static` でなければいけません。
| `@AfterAll`          | このメソッドが、現在のクラスの *すべての* `@Test`, `@RepeatedTest`, `@ParameterizedTest`, `@TestFactory` メソッドの _後に一度だけ_ 実行されるよう指定します。JUnit 4の `@AfterClass` と同じです。このメソッドは、（_隠す_ か _オーバーライドする_ かしない限り）_継承_ されますが、（<<writing-tests-test-instance-lifecycle, テストインスタンスのライフサイクル>> に "per-class" が使われない限り）`static` でなければいけません。
| `@Nested`            | このクラスが、ネストした非staticのテストクラスであることを示します。 `@BeforeAll` および `@AfterAll` メソッドは、<<writing-tests-test-instance-lifecycle, テストインスタンスのライフサイクル>> に "per-class" が使われない限り、`@Nested` テストクラスの中で直接使うことはできません。このアノテーションは、_継承_ されません。
| `@Tag`               | クラスまたはメソッドレベルでテストをフィルタリングするための _タグ_ を宣言するのに使われます。TestNGのテストグループやJUnit 4のCategoryと同じです。このアノテーションは、クラスレベルでは _継承_ されますが、メソッドレベルでは _継承_ されません。
| `@Disabled`          | テストクラスやテストメソッドを _無効化_ するのに使われます。JUnit 4の `@Ignore` と同じです。このアノテーションは、_継承_ されません。
| `@ExtendWith`        | カスタムの <<extensions, 拡張機能>> を登録するために使われます。このアノテーションは、_継承_ されます。
|===

`@Test`, `@TestTemplate`, `@RepeatedTest`, `@BeforeAll`, `@AfterAll`, `@BeforeEach`, `@AfterEach`
アノテーションの付与されたメソッドは、戻り値を返してはいけません。

WARNING: いくつかのアノテーションは現在 _実験中_ です。詳細は、
<<api-evolution-experimental-apis>> のテーブルを参照してください。

[[writing-tests-meta-annotations]]
==== メタアノテーションと合成アノテーション

JUnit Jupiterアノテーションは、_メタアノテーション_ として使うことができます。つまり、
メタアノテーションの意味を自動的に _継承_ した独自の _合成アノテーション_ を作れるということです。

例えば、`@Tag("fast")` をコードベース全体にコピー＆ペーストする代わりに
（<<writing-tests-tagging-and-filtering>> 参照）、以下の `@Fast`
のような名前のカスタム _合成アノテーション_ を作ることができます。
`@Fast` は、`@Tag("fast")` の代わりに使うことができます。

[source,java,indent=0]
----
include::{testDir}/example/Fast.java[tags=user_guide]
----

[[writing-tests-classes-and-methods]]
=== テストクラスとテストメソッド

_テストメソッド (test method)_ とは、`@Test`, `@RepeatedTest`, `@ParameterizedTest`,
`@TestFactory`, `@TestTemplate` のいずれかが直接またはメタアノテーションとして付与された
インスタンスメソッドです。_テストクラス (test class)_ とは、テストメソッドを少なくとも1つもつ
トップレベルまたはstaticな内部クラスです。

[source,java,indent=0]
.標準的なテストクラス
----
include::{testDir}/example/StandardTests.java[tags=user_guide]
----

NOTE: テストクラスやテストメソッドは、 `public` である必要がありません。

[[writing-tests-display-names]]
=== 表示名

テストクラスやテストメソッドは、カスタムの表示名を宣言できます。
空白や特殊文字だけでなく絵文字も含めることができ、テストランナーやテストレポートに表示されます。

[source,java,indent=0]
----
include::{testDir}/example/DisplayNameDemo.java[tags=user_guide]
----

[[writing-tests-assertions]]
=== アサーション

JUnit Jupiterは、JUnit 4にあった多くのアサーションメソッドをもち、
Java 8のラムダ式と一緒に使いやすいものもいくつか追加しています。
すべてのJUnit Jupiterアサーションは、 `{Assertions}` クラスの `static` メソッドです。

[source,java,indent=0]
----
include::{testDir}/example/AssertionsDemo.java[tags=user_guide]
----

JUnit Jupiterは、 https://kotlinlang.org/[Kotlin]
と一緒に使いやすいアサーションもいくつか含んでいます。すべてのJUnit Jupiter Kotlinアサーションは、
`org.junit.jupiter.api` パッケージのトップレベル関数です。

// TODO: Change to using kotlin language highlighting after switch to rouge syntax highlighter
[source,groovy,indent=0]
----
include::{kotlinTestDir}/example/AssertionsKotlinDemo.kt[tags=user_guide]
----

[[writing-tests-assertions-third-party]]
==== サードパーティーのアサーションライブラリ

多くのテストシナリオではJUnit Jupiterが提供するアサーション機能だけで十分ですが、
時にはさらなるパワーや _マッチャー_ のような追加機能が必要になることもあります。
そのような場合には、 {AssertJ} や {Hamcrest}、 {Truth} のようなサードパーティーの
アサーションライブラリを使うことをJUnitチームはお勧めします。
開発者は、好みに応じてアサーションライブラリを自由に選択することができます。

例えば、 _マッチャー_ と流れるようなAPIを組み合わせれば、アサーションをもっと説明的で
読みやすくすることができます。しかし、JUnit Jupiterの `{Assertions}` クラスは、
JUnit 4の `org.junit.Assert` クラスのようにHamcrestの
http://junit.org/junit4/javadoc/latest/org/hamcrest/Matcher.html[`Matcher`]
を受け付ける
http://junit.org/junit4/javadoc/latest/org/junit/Assert.html#assertThat[`assertThat()`]
メソッドを提供していません。代わりに、開発者はサードパーティーのアサーションライブラリが
提供するマッチャーを利用することが推奨されます。

次の例は、JUnit JupiterテストでHamcrestの `assertThat()` を使う方法を示しています。
Hamcrestライブラリをクラスパスに追加しさえすれば、 `assertThat()` や `is()`、 `equalTo()`
のようなメソッドをstatic importして、下の `assertWithHamcrestMatcher()` メソッドのように
テストの中で使うことができます。

[source,java,indent=0]
----
include::{testDir}/example/HamcrestAssertionDemo.java[tags=user_guide]
----

当然ながら、JUnit 4のプログラミングモデルに基づくレガシーなテストでは、引き続き
`org.junit.Assert#assertThat` を使い続けることができます。

[[writing-tests-assumptions]]
=== 前提条件

JUnit Jupiterは、JUnit 4が提供する前提条件用メソッドの一部を備え、
Java 8のラムダ式と一緒に使いやすいものをいくつか追加しています。
JUnit Jupiterの前提条件メソッドは、すべて `{Assumptions}` クラスのstaticメソッドです。

[source,java,indent=0]
----
include::{testDir}/example/AssumptionsDemo.java[tags=user_guide]
----

[[writing-tests-disabling]]
=== テストの無効化

テストクラス全体または個々のテストメソッドは、 `{Disabled}` アノテーションや
<<writing-tests-conditional-execution>> で説明するアノテーション、
あるいはカスタムの <<extensions-conditions, `ExecutionCondition`>>
によって _無効化_ することができます。

次の例は、`@Disabled` されたテストクラスです。

[source,java,indent=0]
----
include::{testDir}/example/DisabledClassDemo.java[tags=user_guide]
----

そして次の例は、`@Disabled` されたテストメソッドをもつテストクラスです。

[source,java,indent=0]
----
include::{testDir}/example/DisabledTestsDemo.java[tags=user_guide]
----

[[writing-tests-conditional-execution]]
=== 条件付きテスト実行

JUnit Jupiterの <<extensions-conditions, `ExecutionCondition`>> 拡張APIは、
開発者がある一定の条件にもとづいて _手続き的に_  コンテナやテストを有効化したり、
無効化したりすることができるようにします。
簡単な例は、`{Disabled}` アノテーションをサポートする `{DisabledCondition}` です
（<<writing-tests-disabling>> 参照）。

JUnit Jupiterは、`org.junit.jupiter.api.condition` パッケージで `@Disabled`
以外にもアノテーションベースの条件をサポートしています。これにより、開発者は _宣言的に_
コンテナやテストを有効化したり、無効化したりすることができます。
詳細は、以降の節を参照してください。

[TIP]
.合成アノテーション
====
以降で説明するいずれの _条件_ アノテーションも、カスタムの _合成アノテーション_
を作るためのメタアノテーションとして使われうる点に注意してください。例えば、
<<writing-tests-conditional-execution-os-demo, @EnabledOnOsデモ>> の `@TestOnMac`
アノテーションは、`@Test` と `@EnabledOnOs` を1つの再利用可能なアノテーションとして
組み合わせる方法を示しています。
====

[WARNING]
====
以降の節で取り上げられる _条件_ アノテーションは、あるテストインターフェースやテストクラス、
テストメソッドに対して一度しか宣言できません。条件アノテーションがある要素に対して直接、
間接、あるいはメタアノテーションで複数回指定されたとしても、JUnitが最初に見つけた
アノテーションだけが使われます。その他のアノテーションは、黙って無視されます。ただし、
`org.junit.jupiter.api.condition` パッケージのそれぞれの条件アノテーションは、
組み合わせて使うことができる点に注意してください。
====

[[writing-tests-conditional-execution-os]]
==== オペレーティングシステム条件

`{EnabledOnOs}` および `{DisabledOnOs}` アノテーションを使うと、
コンテナやテストを特定のオペレーティングシステムで有効にしたり無効にしたりできます。

[[writing-tests-conditional-execution-os-demo]]
[source,java,indent=0]
----
include::{testDir}/example/ConditionalTestExecutionDemo.java[tags=user_guide_os]
----

[[writing-tests-conditional-execution-jre]]
==== Javaランタイム環境条件

`{EnabledOnJre}` および `{DisabledOnJre}` アノテーションを使うと、
コンテナやテストを特定のバージョンのJavaランタイム環境（JRE）で有効にしたり無効にしたりできます。

[source,java,indent=0]
----
include::{testDir}/example/ConditionalTestExecutionDemo.java[tags=user_guide_jre]
----

[[writing-tests-conditional-execution-system-properties]]
==== システムプロパティ条件

`{EnabledIfSystemProperty}` および `{DisabledIfSystemProperty}` アノテーションを使うと、
指定した名前をもつJVMシステムプロパティの値に応じて、コンテナやテストを有効にしたり
無効にしたりできます。 `matches` 属性で指定する値は、正規表現として解釈されます。

[source,java,indent=0]
----
include::{testDir}/example/ConditionalTestExecutionDemo.java[tags=user_guide_system_property]
----

[[writing-tests-conditional-execution-environment-variables]]
==== 環境変数条件

`{EnabledIfEnvironmentVariable}` および `{DisabledIfEnvironmentVariable}`
アノテーションを使うと、指定した名前をもつ環境変数の値に応じて、コンテナやテストを
有効にしたり無効にしたりできます。`matches` 属性で指定する値は、正規表現として解釈されます。

[source,java,indent=0]
----
include::{testDir}/example/ConditionalTestExecutionDemo.java[tags=user_guide_environment_variable]
----

[[writing-tests-conditional-execution-scripts]]
==== スクリプトベースの条件

JUnit Jupiterは、`{EnabledIf}` または `{DisabledIf}` アノテーションで設定された
スクリプトの実行結果に応じて、コンテナやテストを有効にしたり無効にしたりする機能を提供します。
スクリプトは、JavaScript、Groovy、あるいはJSR 223で定義されたJava Scripting API
をサポートする任意の言語で記述することができます。

WARNING: `{EnabledIf}` および `{DisabledIf}` を使った条件付きテスト実行は、
現在 _試験的な_ 機能です。詳細は、<<api-evolution-experimental-apis>>
のテーブルを参考にしてください。

TIP: もしスクリプトのロジックが現在のオペレーティングシステムやJavaランタイム環境の
バージョン、特定のJVMシステムプロパティや環境変数だけに依存するなら、その目的専用の
組み込みアノテーションの使用を検討すべきです。詳細は、この章の前の節を参照してください。

NOTE: もし同じようなスクリプトベースの条件を何回も使っていると感じたら、
高速かつタイプセーフで、よりメンテナンスしやすい方法で実装するために、専用の
<<extensions-conditions, ExecutionCondition>> 拡張を書くことを検討してください。

[source,java,indent=0]
----
include::{testDir}/example/ConditionalTestExecutionDemo.java[tags=user_guide_scripts]
----

[[writing-tests-conditional-execution-scripts-bindings]]
===== スクリプトバインディング

以下の名前は、スクリプトのコンテキストに束縛されるため、スクリプト内で使うことができます。
_accessor_ は、単純な `String get(String name)` メソッドを介したマップ構造への
アクセスを提供します。

[cols="25,25,75"]
|===
| Name                          | Type          | Description

| `systemEnvironment`           | _accessor_    | オペレーティングシステムの環境変数へのアクセッサ
| `systemProperty`              | _accessor_    | JVMのシステムプロパティへのアクセッサ
| `junitConfigurationParameter` | _accessor_    | 設定パラメーターへのアクセッサ
| `junitDisplayName`            | `String`      | テストやコンテナの表示名
| `junitTags`                   | `Set<String>` | テストやコンテナにアサインされたすべてのタグ
| `junitUniqueId`               | `String`      | テストやコンテナの一意なID
|===


[[writing-tests-tagging-and-filtering]]
=== タグとフィルタリング

テストクラスとテストメソッドには、`@Tag` アノテーションでタグを付与することができます。
これらのタグはあとで <<running-tests, テストを発見・実行>> するときのフィルタリングに
使うことができます。

==== タグの構文規則

* タグは、`null` または _空_ であってはならない
* _トリミングした_ タグは、空白文字を含んではならない
* _トリミングした_ タグは、ISO制御文字を含んではならない
* _トリミングした_ タグは、次の _予約済み文字_ を含んではならない
  - `,`: _カンマ_
  - `(`: _左括弧_
  - `)`: _右括弧_
  - `&`: _アンパサンド_
  - `|`: _縦棒_
  - `!`: _感嘆符_

NOTE: 上のコンテキストで "トリミングした" とは、先頭および末尾の空白文字が
取り除かれていることを意味する。

[source,java,indent=0]
----
include::{testDir}/example/TaggingDemo.java[tags=user_guide]
----

[[writing-tests-test-instance-lifecycle]]
=== テストインスタンスのライフサイクル

個々のテストメソッドを隔離された環境で実行し、
テストインスタンスをミュータブルにすると起こりうる意図しない副作用を避けるため、
JUnitは _テストメソッド_ （<<writing-tests-classes-and-methods>> 参照）
毎にそのテストクラスの新しいインスタンスを生成して実行します。
この "per-method（メソッド毎）" のテストインスタンスライフサイクルは、JUnit Jupiter
のデフォルトの挙動で、過去のJUnitのバージョンと同じです。

NOTE: "per-method" のテストインスタンスライフサイクルモードが有効であったとしても、
<<writing-tests-conditional-execution, 条件>> (例えば、`@Disabled` や
`@DisabledOnOs` など)によって _テストメソッド_ が _無効化_ されている場合は、
テストクラスのインスタンスが作り直されない点に注意してください。

もしすべてのテストメソッドを同じテストインスタンスで実行させたい場合は、テストクラスに
`@TestInstance(Lifecycle.PER_CLASS)` アノテーションを付与してください。
このモードを使うと、新しいテストインスタンスはテストクラス毎に1回だけ生成されます。
そのため、もしテストメソッドがインスタンス変数の状態に依存するのであれば、
`@BeforeEach` や `@AfterEach` メソッドで状態をリセットする必要があります。

"per-class（クラス毎）" モードは、デフォルトの "per-method（メソッド毎）" モードに比べて
追加のメリットがあります。具体的には、"per-class" モードでは `@BeforeAll` および
`@AfterAll` をインターフェースの `default` メソッドやクラスの非staticなメソッドに
対して宣言できるようになります。そのため、"per-class" モードでは `@BeforeAll` や
`@AfterAll` メソッドを `@Nested` テストクラスでも使えます。

もしプログラミング言語Kotlinでテストを書く場合は、テストインスタンスのライフサイクルを
"per-class" モードに切り替えると、`@BeforeAll` および `@AfterAll` メソッドを
より実装しやすいでしょう。

[[writing-tests-test-instance-lifecycle-changing-default]]
==== テストインスタンスのデフォルトのライフサイクルの変更

テストクラスやテストインターフェースに `@TestInstance` アノテーションを付与すると、
JUnit Jupiterは _デフォルト_ のライフサイクルモードを使います。標準の _デフォルト_
モードは `PER_METHOD` ですが、テストプラン全体で _デフォルト_ を変更することもできます。
テストインスタンスのデフォルトのライフサイクルモードを変更するには、単に
`junit.jupiter.testinstance.lifecycle.default` _設定パラメーター_ に
`TestInstance.Lifecycle` で定義された列挙定数を指定するだけです。
これは、JVMシステムプロパティや `Launcher` に渡される `LauncherDiscoveryRequest`
の _設定パラメーター_ 、あるいはJUnit Platform設定ファイルなどで指定できます
（詳細は、<<running-tests-config-params>> 参照）。

例えば、デフォルトのライフサイクルモードを `Lifecycle.PER_CLASS` に設定するには、
次のシステムプロパティを指定してJVMを起動します。

`-Djunit.jupiter.testinstance.lifecycle.default=per_class`

ただし、デフォルトのライフサイクルモードをJUnit Platform設定ファイルで指定する方が、
よりロバストである点に注意してください。というのも、設定ファイルならプロジェクトの
バージョン管理システムにチェックインでき、IDEやビルドツールからも使えるからです。

JUnit Platform設定ファイルを使ってデフォルトのライフサイクルモードを `Lifecycle.PER_CLASS`
にするには、クラスパスのルート（例えば、`src/test/resources`）に `junit-platform.properties`
という名前で次のファイルを作ります。

`junit.jupiter.testinstance.lifecycle.default = per_class`

WARNING: テストインスタンスの _デフォルト_ のライフサイクルモードを変更する場合は、
一貫性のある方法で適用しないと予測できない結果や不安定なビルドにつながる可能性があります。
例えば、ビルドでは "per-class" をデフォルトとして設定していても、IDEが "per-method"
でテストを実行していると、ビルドサーバーで起きたエラーをデバッグするのが難しくなります。
そのため、JVMシステムプロパティの代わりにJUnit Platform設定ファイルを使って
デフォルトを変更することをお勧めします。

[[writing-tests-nested]]
=== ネストしたテスト

ネストしたテストは、テスト作成者がテストのグループ関係を表現しやすくします。
詳しい例は次の通りです。

[source,java,indent=0]
.スタックをテストするためのネストしたテストスイート
----
include::{testDir}/example/TestingAStackDemo.java[tags=user_guide]
----

NOTE: _非staticなネストクラス_（すなわち、_内部クラス_）だけが、`@Nested`
テストクラスとして使えます。ネストの深さは自由で、すべての内部クラスがテストクラスの
一部とみなされます。ただし、1つだけ例外があり、`@BeforeAll` および `@AfterAll`
メソッドは、_デフォルトでは_ 機能しません。というのも、Javaでは内部クラスで
`static` メンバーを使用できないからです。しかし、この制限は `@Nested` テストクラスに
`@TestInstance(Lifecycle.PER_CLASS)` アノテーションを付与することで回避できます
（ <<writing-tests-test-instance-lifecycle>> 参照）。

[[writing-tests-dependency-injection]]
=== コンストラクタとメソッドへの依存性注入

これまでのバージョンのJUnitでは、テストクラスのコンストラクタとメソッドは
（少なくとも標準の `Runner` 実装では）引数をもつことができませんでした。
JUnit Jupiterの大きな変更点の1つは、テストのコンストラクタやメソッドが
引数をもてるようになったことです。これは大きな柔軟性をもたらし、
_依存性注入_ を可能にします。

`{ParameterResolver}` は、実行時に _動的に_ 引数を解決したいテスト拡張のための
APIを定義しています。もしテストコンストラクタや `@Test`, `@TestFactory`,
`@BeforeEach`, `@AfterEach`, `@BeforeAll`, `@AfterAll` メソッドが引数をもつ場合、
その引数は登録済みの `ParameterResolver` によって解決されます。

現状、自動的に登録される組み込みのResolverが3つあります。

* `{TestInfoParameterResolver}`: もしメソッドの引数の型が `{TestInfo}` の場合、
  `TestInfoParameterResolver` が現在のテストに応じた `TestInfo` をその引数の値として
  与えます。 `TestInfo` は、テストの表示名やテストクラス、テストメソッド、付与されたタグなど、
  現在のテストに関する情報を取得するために使用できます。表示名は、テストクラスやテストメソッド
  の名前か、`@DisplayName` で設定されたカスタムの名前か、どちらかになります。
+
`{TestInfo}` は、JUnit 4の `TestName` ルールの代替として使えます。
次の例は、`TestInfo` をテストのコンストラクタ、`@BeforeEach` メソッド、および
`@Test` メソッドに注入する方法を示しています。

[source,java,indent=0]
----
include::{testDir}/example/TestInfoDemo.java[tags=user_guide]
----

* `{RepetitionInfoParameterResolver}`: もし `@RepeatedTest`, `@BeforeEach`,
  `@AfterEach` メソッドの引数の型が `{RepetitionInfo}` の場合、
  `RepetitionInfoParameterResolver` が `RepetitionInfo` インスタンスを与えます。
  `RepetitionInfo` は、`@RepeatedTest` の現在の繰り返し回数や合計回数の情報を
  取得するために使用できます。ただし、`RepetitionInfoParameterResolver` は
  `@RepeatedTest` 以外では登録されないことに注意してください。
  <<writing-tests-repeated-tests-examples>> を参照。

* `{TestReporterParameterResolver}`: もしメソッドの引数の型が `{TestReporter}`
  の場合、`TestReporterParameterResolver` が `TestReporter` インスタンスを与えます。
  `TestReporter` は、現在のテスト実行に関する追加のデータを出力するために使用できます。
  このデータは、`{TestExecutionListener}.reportingEntryPublished()`
  を通して取得できるので、IDEで参照したり、レポートに含めたりできます。
+
JUnit Jupiterでは、JUnit 4で `stdout` や `stderr` に情報を出力していた代わりに、
`TestReporter` を使うべきです。 `@RunWith(JUnitPlatform.class)` を使うときも、
すべてのレポート情報が `stdout` に出力されます。

[source,java,indent=0]
----
include::{testDir}/example/TestReporterDemo.java[tags=user_guide]
----

NOTE: そのほかの `ParameterResolver` は、`@ExtendWith` を使って適切な
<<extensions, 拡張機能>> を登録することで、明示的に有効にしなければなりません。

カスタムの `{ParameterResolver}` のサンプルとしては、`{RandomParametersExtension}`
を参照してください。本番利用を想定したものではありませんが、
拡張モデルとパラメーター解決処理のシンプルさや高い表現力を示しています。
`MyRandomParametersTest` は、乱数を `@Test` メソッドに注入する例になっています。

[source,java,indent=0]
----
@ExtendWith(RandomParametersExtension.class)
class MyRandomParametersTest {

	@Test
	void injectsInteger(@Random int i, @Random int j) {
		assertNotEquals(i, j);
	}

	@Test
	void injectsDouble(@Random double d) {
		assertEquals(0.0, d, 1.0);
	}

}
----

実世界のユースケースとしては、`{MockitoExtension}` や `{SpringExtension}`
のソースコードを確認してください。

[[writing-tests-test-interfaces-and-default-methods]]
=== テストインターフェースとデフォルトメソッド

JUnit Jupiterでは、`@Test`, `@RepeatedTest`, `@ParameterizedTest`, `@TestFactory`,
`@TestTemplate`, `@BeforeEach`, `@AfterEach` アノテーションをインターフェースの
`default` メソッドに対して宣言することもできます。 `@BeforeAll` と `@AfterAll`
はテストインターフェースの `static` メソッドにしか宣言できませんが、
`@TestInstance(Lifecycle.PER_CLASS)` がテストインターフェースまたはテストクラスに
付与されていればインターフェースの `default` メソッドに宣言することもできます
（<<writing-tests-test-instance-lifecycle>> 参照）。以下はサンプルです。

[source,java]
----
include::{testDir}/example/testinterface/TestLifecycleLogger.java[tags=user_guide]
----

[source,java]
----
include::{testDir}/example/testinterface/TestInterfaceDynamicTestsDemo.java[tags=user_guide]
----

`@ExtendWith` と `@Tag` はテストインターフェースに宣言することで、
そのインタフェースを実装したクラスにタグと拡張機能を自動的に継承させることができます。
<<extensions-lifecycle-callbacks-before-after-execution>> にある
<<extensions-lifecycle-callbacks-timing-extension, TimingExtension>>
のソースコードを参照してください。

[source,java]
----
include::{testDir}/example/testinterface/TimeExecutionLogger.java[tags=user_guide]
----

これらのインタフェースを実装することでテストクラスに適用することができます。

[source,java]
----
include::{testDir}/example/testinterface/TestInterfaceDemo.java[tags=user_guide]
----

`TestInterfaceDemo` を実行すると、次のような出力となります。

....
:junitPlatformTest
INFO  example.TestLifecycleLogger - Before all tests
INFO  example.TestLifecycleLogger - About to execute [dynamicTestsFromCollection()]
INFO  example.TimingExtension - Method [dynamicTestsFromCollection] took 13 ms.
INFO  example.TestLifecycleLogger - Finished executing [dynamicTestsFromCollection()]
INFO  example.TestLifecycleLogger - About to execute [isEqualValue()]
INFO  example.TimingExtension - Method [isEqualValue] took 1 ms.
INFO  example.TestLifecycleLogger - Finished executing [isEqualValue()]
INFO  example.TestLifecycleLogger - After all tests

Test run finished after 190 ms
[         3 containers found      ]
[         0 containers skipped    ]
[         3 containers started    ]
[         0 containers aborted    ]
[         3 containers successful ]
[         0 containers failed     ]
[         3 tests found           ]
[         0 tests skipped         ]
[         3 tests started         ]
[         0 tests aborted         ]
[         3 tests successful      ]
[         0 tests failed          ]

BUILD SUCCESSFUL
....

この機能の別の適用例としては、インタフェース契約に対するテストが考えられます。
例えば、`Object.equals` や `Comparable.compareTo` の実装クラスが
どう振る舞うべきかのテストを次のように書くことができます。

[source,java]
----
include::{testDir}/example/defaultmethods/Testable.java[tags=user_guide]
----

[source,java]
----
include::{testDir}/example/defaultmethods/EqualsContract.java[tags=user_guide]
----

[source,java]
----
include::{testDir}/example/defaultmethods/ComparableContract.java[tags=user_guide]
----

テストクラスでこれらの契約インターフェースを実装することで、対応するテストケースを
継承することができます。もちろん、抽象メソッドは自分で実装する必要があります。

[source,java]
----
include::{testDir}/example/defaultmethods/StringTests.java[tags=user_guide]
----

NOTE: 前述のテストはサンプル目的であり、完全なものではありません。


[[writing-tests-repeated-tests]]
=== 繰り返しテスト

JUnit Jupiterは、`@RepeatedTest` アノテーションを使って指定した回数だけ
繰り返しテストを実行する機能を提供しています。
繰り返しテストの1回毎の呼び出しは、ライフサイクルコールバックや拡張機能など、通常の
`@Test` メソッドの実行と同じように振る舞います。

次の例は、自動的に10回繰り返す `repeatedTest()` を宣言する方法を示しています。

[source,java]
----
@RepeatedTest(10)
void repeatedTest() {
	// ...
}
----

繰り返し回数を指定するだけでなく、`@RepeatedTest` アノテーションの `name`
属性を使って、繰り返し実行毎の表示名を変更することもできます。表示名は、
静的なテキストと動的なプレースホルダーを組み合わせたパターンにできます。
以下が、現在サポートされているプレースホルダーです。

- `{displayName}`: `@RepeatedTest` メソッドの表示名
- `{currentRepetition}`: 現在の実行回数
- `{totalRepetitions}`: トータルの実行回数

デフォルトの表示名は、`"repetition {currentRepetition} of {totalRepetitions}"`
というパターンに従います。そのため、前述の `repeatedTest()` に対する表示名は、
`repetition 1 of 10`, `repetition 2 of 10` のようになります。
もし `@RepeatedTest` メソッドの名前を含めたい場合は、カスタムのパターンを指定するか、
定義済みの `RepeatedTest.LONG_DISPLAY_NAME` パターンを指定できます。
後者は、`"{displayName} :: repetition {currentRepetition} of {totalRepetitions}"`
というパターンと同等で、`repeatedTest() :: repetition 1 of 10`,
`repeatedTest() :: repetition 2 of 10` のようになります。

現在の繰り返し回数やトータルの繰り返し回数をプログラムから取得するためには、
`RepetitionInfo` インスタンスを `@RepeatedTest`, `@BeforeEach`, `@AfterEach`
メソッドのいずれかに注入させることができます。

[[writing-tests-repeated-tests-examples]]
==== 繰り返しテストの例

この節の最後の `RepeatedTestsDemo` クラスは、繰り返しテストの様々な例を示しています。

`repeatedTest()` メソッドは、前の節で紹介した例と同じです。一方、
`repeatedTestWithRepetitionInfo()` は、トータルの繰り返し回数を取得するために
`RepetitionInfo` インスタンスをテストに注入させる方法を示しています。

その次の2つのメソッドは、`@RepeatedTest` メソッドに対するカスタムの `@DisplayName`
を各繰り返しの表示名に含める方法を示しています。`customDisplayName()` は、
カスタムの表示名とパターンを組み合わせて指定し、生成された表示名を検証するのに
`TestInfo` を使っています。
`{displayName}` が `@DisplayName` の宣言から `Repeat!` となり、
`{currentRepetition}/{totalRepetitions}` が `1/1` となります。
一方、`customDisplayNameWithLongPattern()` は前述の定義済みパターン
`RepeatedTest.LONG_DISPLAY_NAME` を使っています。

`repeatedTestInGerman()` は、繰り返しテストの表示名を外国語（この場合、ドイツ語）
に翻訳する方法を示しています。各繰り返しの表示名は、`Wiederholung 1 von 5`,
`Wiederholung 2 von 5` のようになります。

`beforeEach()` メソッドは `@BeforeEach` アノテーションが付与されているため、
繰り返しテストの個々の繰り返し実行の度に実行されます。`TestInfo` と
`RepetitionInfo` をメソッドに注入させることで、現在実行中の繰り返しテストに
関する情報を取得できることが分かります。`INFO` レベルのログを有効にして
`RepeatedTestsDemo` を実行すると、次のような出力となります。

....
INFO: About to execute repetition 1 of 10 for repeatedTest
INFO: About to execute repetition 2 of 10 for repeatedTest
INFO: About to execute repetition 3 of 10 for repeatedTest
INFO: About to execute repetition 4 of 10 for repeatedTest
INFO: About to execute repetition 5 of 10 for repeatedTest
INFO: About to execute repetition 6 of 10 for repeatedTest
INFO: About to execute repetition 7 of 10 for repeatedTest
INFO: About to execute repetition 8 of 10 for repeatedTest
INFO: About to execute repetition 9 of 10 for repeatedTest
INFO: About to execute repetition 10 of 10 for repeatedTest
INFO: About to execute repetition 1 of 5 for repeatedTestWithRepetitionInfo
INFO: About to execute repetition 2 of 5 for repeatedTestWithRepetitionInfo
INFO: About to execute repetition 3 of 5 for repeatedTestWithRepetitionInfo
INFO: About to execute repetition 4 of 5 for repeatedTestWithRepetitionInfo
INFO: About to execute repetition 5 of 5 for repeatedTestWithRepetitionInfo
INFO: About to execute repetition 1 of 1 for customDisplayName
INFO: About to execute repetition 1 of 1 for customDisplayNameWithLongPattern
INFO: About to execute repetition 1 of 5 for repeatedTestInGerman
INFO: About to execute repetition 2 of 5 for repeatedTestInGerman
INFO: About to execute repetition 3 of 5 for repeatedTestInGerman
INFO: About to execute repetition 4 of 5 for repeatedTestInGerman
INFO: About to execute repetition 5 of 5 for repeatedTestInGerman
....

[source,java]
----
include::{testDir}/example/RepeatedTestsDemo.java[tags=user_guide]
----

Unicodeテーマを有効にした `ConsoleLauncher` で `RepeatedTestsDemo` を実行すると、
コンソールには以下のように出力されます。

....
├─ RepeatedTestsDemo ✔
│  ├─ repeatedTest() ✔
│  │  ├─ repetition 1 of 10 ✔
│  │  ├─ repetition 2 of 10 ✔
│  │  ├─ repetition 3 of 10 ✔
│  │  ├─ repetition 4 of 10 ✔
│  │  ├─ repetition 5 of 10 ✔
│  │  ├─ repetition 6 of 10 ✔
│  │  ├─ repetition 7 of 10 ✔
│  │  ├─ repetition 8 of 10 ✔
│  │  ├─ repetition 9 of 10 ✔
│  │  └─ repetition 10 of 10 ✔
│  ├─ repeatedTestWithRepetitionInfo(RepetitionInfo) ✔
│  │  ├─ repetition 1 of 5 ✔
│  │  ├─ repetition 2 of 5 ✔
│  │  ├─ repetition 3 of 5 ✔
│  │  ├─ repetition 4 of 5 ✔
│  │  └─ repetition 5 of 5 ✔
│  ├─ Repeat! ✔
│  │  └─ Repeat! 1/1 ✔
│  ├─ Details... ✔
│  │  └─ Details... :: repetition 1 of 1 ✔
│  └─ repeatedTestInGerman() ✔
│     ├─ Wiederholung 1 von 5 ✔
│     ├─ Wiederholung 2 von 5 ✔
│     ├─ Wiederholung 3 von 5 ✔
│     ├─ Wiederholung 4 von 5 ✔
│     └─ Wiederholung 5 von 5 ✔
....


[[writing-tests-parameterized-tests]]
=== パラメーター化テスト

[TIP]
====
訳注：計算機科学の用語に従うのであれば、
_argument_ を _実引数（メソッドを呼び出す側から見た引数）_、
_parameter_ を _仮引数（メソッドを呼ばれる側から見た引数）_
と区別して訳すべきだが、パラメーター化テストの説明では前者の
_argument_ を _パラメーター_ と訳してしまった方が
直感的にイメージしやすいと訳者は考える。
原文でも両者の区別があいまいな箇所があるため、以降では
訳者の解釈に従って意訳している。気になる場合は、原文をあたること。
====

パラメーター化テストは、異なる実引数でテストを複数回実行できるようにします。
通常の `@Test` メソッドに似ていますが、`{ParameterizedTest}` アノテーションを
使って宣言します。各呼び出しに対するパラメーターを生成するための _ソース (source)_
を少なくとも1つは宣言し、そのパラメーターはテストメソッドで _消費 (consume)_
する必要があります。

以下は、パラメーターのソースとして `String` 配列を指定するために `@ValueSource`
アノテーションを使用した例を示しています。

[source,java,indent=0]
----
include::{testDir}/example/ParameterizedTestDemo.java[tags=first_example]
----

上のパラメーター化テストメソッドを実行すると、各実行が別々にレポートされます。
例えば、`ConsoleLauncher` を使うと次のように出力されます。

....
palindromes(String) ✔
├─ [1] racecar ✔
├─ [2] radar ✔
└─ [3] able was I ere I saw elba ✔
....

WARNING: パラーメーター化テストは、現在 _実験中_ の機能です。
詳細は、<<api-evolution-experimental-apis>> の表を確認してください。

[[writing-tests-parameterized-tests-setup]]
==== 必要なセットアップ

パラメーター化テストを使うには、`junit-jupiter-params` への依存を追加する必要があります。
詳細は、<<dependency-metadata>> を参照してください。

[[writing-tests-parameterized-tests-consuming-arguments]]
==== パラメーターの消費

パラメーター化テストのメソッドは、通常は設定されたソース
(<<writing-tests-parameterized-tests-sources>> 参照)
からパラメーターのインデックスとメソッドの仮引数のインデックスが1対1となるように
パラメーターを _消費_ します
(<<writing-tests-parameterized-tests-sources-CsvSource>> の例を参照)。
しかし、ソースのすべてのパラメーターを単一のオブジェクトに _集約_
してメソッドに渡すこともできます
(<<writing-tests-parameterized-tests-argument-aggregation>> 参照)。
また、`ParameterResolver` を使って追加の引数を渡すこともできます
(例えば、`TestInfo` や `TestReporter` のインスタンスなど)。
パラメーター化テストメソッドは、次のルールに従って仮引数を宣言しなければなりません。

* 最初に、_インデックス付き引数 (indexed argument)_ を0個以上宣言します
* その次に、_アグリゲーター (aggregator)_ を0個以上宣言します
* 最後に、`ParameterResolver` によって渡される引数を0個以上宣言します

ここで、_インデックス付き引数 (indexed argument)_ は、`ArgumentsProvider`
が生成した `Arguments` 中の指定されたインデックスに対するパラメーターです。
このパラメーターは、パラメーター化テストメソッドの仮引数リストで
同じインデックスに実引数として渡されます。
_アグリゲーター (aggregator)_ は、`ArgumentsAccessor` 型または `@AggregateWith`
アノテーションが付与された仮引数です。

[[writing-tests-parameterized-tests-sources]]
==== パラメーターのソース

JUnit Jupiterは、あらかじめいくつかの _ソース_ アノテーションを提供しています。
以降では、これらのアノテーションについて簡単な説明とサンプルを示します。
より詳細な情報は、`{params-provider-package}` パッケージのJavaDocを参照してください。

[[writing-tests-parameterized-tests-sources-ValueSource]]
===== @ValueSource

`@ValueSource` は、最もシンプルなソースの1つです。リテラル値の配列を指定できますが、
パラメーター化テストの1回の実行につき1つのパラメーターしか与えることができません。

`@ValueSource` では、以下の型のリテラル値がサポートされています。

- `short`
- `byte`
- `int`
- `long`
- `float`
- `double`
- `char`
- `java.lang.String`
- `java.lang.Class`

例えば、次の `@ParameterizedTest` メソッドは、値 `1`, `2`, `3` をパラメーターとして
3回呼び出されます。

[source,java,indent=0]
----
include::{testDir}/example/ParameterizedTestDemo.java[tags=ValueSource_example]
----

[[writing-tests-parameterized-tests-sources-EnumSource]]
===== @EnumSource

`@EnumSource` は、`Enum` 定数を指定する便利な方法を提供します。このアノテーションでは、
省略可能な `names` 属性を指定すると、その列挙定数だけが使われます。
省略すると、次の例のようにすべての列挙定数が使われます。

[source,java,indent=0]
----
include::{testDir}/example/ParameterizedTestDemo.java[tags=EnumSource_example]
----

[source,java,indent=0]
----
include::{testDir}/example/ParameterizedTestDemo.java[tags=EnumSource_include_example]
----

`@EnumSource` アノテーションは、テストメソッドに渡される列挙定数をさらに細かく制御するために、
省略可能な `mode` 属性も提供しています。例えば、一部の名前をもつ列挙定数だけ除外したり、
正規表現で列挙定数を指定したりすることができます。

[source,java,indent=0]
----
include::{testDir}/example/ParameterizedTestDemo.java[tags=EnumSource_exclude_example]
----

[source,java,indent=0]
----
include::{testDir}/example/ParameterizedTestDemo.java[tags=EnumSource_regex_example]
----

[[writing-tests-parameterized-tests-sources-MethodSource]]
===== @MethodSource

`{MethodSource}` は、テストクラスまたは外部のクラスの _ファクトリ_
メソッドによるパラメーターの指定を可能にします。

テストクラス内のファクトリメソッドは、`@TestInstance(Lifecycle.PER_CLASS)`
アノテーションが付与されていない限り、`static` でなければいけません。
一方、外部クラスのファクトリメソッドは、常に `static` でなければいけません。
これらのファクトリメソッドは、引数を受け取ることもできません。

ファクトリメソッドは、 `@ParameterizedTest` メソッドの各呼び出しに対して
実際の引数として渡される _パラメーター_ の _ストリーム_ を生成しなければなりません。
一般的に言えば、これは `Arguments` の `Stream` (つまり、`Stream<Arguments>`)
となりますが、実際の戻り値は様々な型をとりえます。ここでいう "ストリーム" とは、
JUnitが確実に `Stream` へ変換できるものであれば何でも構いません。例えば、
`Stream`, `DoubleStream`, `LongStream`, `IntStream`, `Collection`,
`Iterator`, `Iterable`, オブジェクト配列, プリミティブ型の配列などです。
ストリームの "パラメーター" は、 `Arguments` のインスタンス、オブジェクト配列
(つまり、`Object[]`)、あるいはパラメーター化テストメソッドが1つだけしか
パラメーターを受け取らない場合には単一の値となります。

パラメーターが1つしか必要なければ、次の例のようにパラメーターのインスタンスを
`Stream` で返すことができます。

[source,java,indent=0]
----
include::{testDir}/example/ParameterizedTestDemo.java[tags=simple_MethodSource_example]
----

もし `@MethodSource` でファクトリメソッドの名前を明示的に指定しなかった場合、JUnit Jupiter
は `@ParameterizedTest` メソッドと同じ名前をもつファクトリメソッドを自動的に探します。

[source,java,indent=0]
----
include::{testDir}/example/ParameterizedTestDemo.java[tags=simple_MethodSource_without_value_example]
----

プリミティブ型のストリーム (`DoubleStream`, `IntStream`, `LongStream`)
もサポートされています。

[source,java,indent=0]
----
include::{testDir}/example/ParameterizedTestDemo.java[tags=primitive_MethodSource_example]
----

パラメーター化テストメソッドが複数の仮引数を宣言している場合、以下で示すように `Arguments`
インスタンスかオブジェクト配列を要素とするコレクション、ストリーム、配列のいずれかを返す必要があります
（サポートされる戻り値型のさらなる詳細は、`{MethodSource}` のJavadocを参照）。
`arguments(Object...)` は `Arguments` インターフェースで定義されるstaticファクトリメソッドである
点に注意してください。また、`Arguments.of(Object...)` を `arguments(Object...)`
の代わりに使用することもできます。

[source,java,indent=0]
----
include::{testDir}/example/ParameterizedTestDemo.java[tags=multi_arg_MethodSource_example]
----

次の例で示すように、_メソッドの完全修飾名_ を指定することで、外部の `static` な
_ファクトリ_ メソッドを参照することもできます。

[source,java,indent=0]
----
package example;

include::{testDir}/example/ExternalMethodSourceDemo.java[tags=external_MethodSource_example]
----

[[writing-tests-parameterized-tests-sources-CsvSource]]
===== @CsvSource

`@CsvSource` は、パラメーターのリストをカンマ区切りの値（`String` リテラル）
で指定できるようにします。

[source,java,indent=0]
----
include::{testDir}/example/ParameterizedTestDemo.java[tags=CsvSource_example]
----

`@CsvSource` は、シングルクォート `'` を引用符として使います。
上の例の `'baz, qux'` と、以下のテーブルを参照してください。
引用符で囲まれた空の値 `''` は空の `String` になりますが、
（引用符で囲まれない）完全に _空_ の値は `null` と解釈されます。
`null` の代入先の型がプリミティブ型の場合は、
`ArgumentConversionException` が発生します。

[cols="50,50"]
|===
| Example Input                        | Resulting Argument List

| `@CsvSource({ "foo, bar" })`         | `"foo"`, `"bar"`
| `@CsvSource({ "foo, 'baz, qux'" })`  | `"foo"`, `"baz, qux"`
| `@CsvSource({ "foo, ''" })`          | `"foo"`, `""`
| `@CsvSource({ "foo, " })`            | `"foo"`, `null`
|===

[[writing-tests-parameterized-tests-sources-CsvFileSource]]
===== @CsvFileSource

`@CsvFileSource` は、クラスパスにあるCSVファイルを使えるようにします。
CSVファイルの各行は、パラメーター化テストの1回の実行になります。

[source,java,indent=0]
----
include::{testDir}/example/ParameterizedTestDemo.java[tags=CsvFileSource_example]
----

[source,csv,indent=0]
.two-column.csv
----
include::{testResourcesDir}/two-column.csv[]
----

NOTE: `@CsvSource` のシンタックスとは異なり、`@CsvFileSource` はダブルクォート `"`
を引用符として使います。上の例の、`"United States of America"` を参考にしてください。
引用符で囲まれた空の値 `""` は空の `String` になりますが、
（引用符で囲まれない）完全に _空_ の値は `null` と解釈されます。
`null` の代入先の型がプリミティブ型の場合は、
`ArgumentConversionException` が発生します。

[[writing-tests-parameterized-tests-sources-ArgumentsSource]]
===== @ArgumentsSource

`@ArgumentsSource` は、カスタムの再利用可能な `ArgumentsProvider`
を指定する場合に使えます。

[source,java,indent=0]
----
include::{testDir}/example/ParameterizedTestDemo.java[tags=ArgumentsSource_example]
----


[[writing-tests-parameterized-tests-argument-conversion]]
==== パラメーターの変換

[[writing-tests-parameterized-tests-argument-conversion-widening]]
===== 拡大変換

JUnit Jupiterは、`@ParameterizedTest` に与えられたパラメーターに対して、
https://docs.oracle.com/javase/specs/jls/se8/html/jls-5.html#jls-5.1.2[プリミティブ型の
拡大変換] をサポートしています。例えば、`@ValueSource(ints = { 1, 2, 3 })`
アノテーションが付与されたパラメーター化テストでは、テストメソッドの仮引数を
`int` 型だけでなく `long` や `float`、`double` 型でも宣言することができます。

[[writing-tests-parameterized-tests-argument-conversion-implicit]]
===== 暗黙的な変換

`@CsvSource` のようなユースケースをサポートするために、JUnit Jupiter
は多くの組み込みの型変換を提供しています。
変換処理は、メソッドの仮引数の型に依存します。

例えば、`@ParameterizedTest` が `TimeUnit` 型の仮引数を宣言し、
ソースから実際に渡される型が `String` の場合、その文字列は対応する
`TimeUnit` 列挙定数に自動的に変換されます。

[source,java,indent=0]
----
include::{testDir}/example/ParameterizedTestDemo.java[tags=implicit_conversion_example]
----

`String` インスタンスは、今のところ次のようなターゲット型に暗黙的に変換されます。

[[writing-tests-parameterized-tests-argument-conversion-implicit-table]]
[cols="10,90"]
|===
| Target Type | Example

| `boolean`/`Boolean`        | `"true"`                                 -> `true`
| `byte`/`Byte`              | `"1"`                                    -> `(byte) 1`
| `char`/`Character`         | `"o"`                                    -> `'o'`
| `short`/`Short`            | `"1"`                                    -> `(short) 1`
| `int`/`Integer`            | `"1"`                                    -> `1`
| `long`/`Long`              | `"1"`                                    -> `1L`
| `float`/`Float`            | `"1.0"`                                  -> `1.0f`
| `double`/`Double`          | `"1.0"`                                  -> `1.0d`
| `Enum` subclass            | `"SECONDS"`                              -> `TimeUnit.SECONDS`
| `java.io.File`             | `"/path/to/file"`                        -> `new File("/path/to/file")`
| `java.math.BigDecimal`     | `"123.456e789"`                          -> `new BigDecimal("123.456e789")`
| `java.math.BigInteger`     | `"1234567890123456789"`                  -> `new BigInteger("1234567890123456789")`
| `java.net.URI`             | `"http://junit.org/"`                    -> `URI.create("http://junit.org/")`
| `java.net.URL`             | `"http://junit.org/"`                    -> `new URL("http://junit.org/")`
| `java.nio.charset.Charset` | `"UTF-8"`                                -> `Charset.forName("UTF-8")`
| `java.nio.file.Path`       | `"/path/to/file"`                        -> `Paths.get("/path/to/file")`
| `java.time.Instant`        | `"1970-01-01T00:00:00Z"`                 -> `Instant.ofEpochMilli(0)`
| `java.time.LocalDateTime`  | `"2017-03-14T12:34:56.789"`              -> `LocalDateTime.of(2017, 3, 14, 12, 34, 56, 789_000_000)`
| `java.time.LocalDate`      | `"2017-03-14"`                           -> `LocalDate.of(2017, 3, 14)`
| `java.time.LocalTime`      | `"12:34:56.789"`                         -> `LocalTime.of(12, 34, 56, 789_000_000)`
| `java.time.OffsetDateTime` | `"2017-03-14T12:34:56.789Z"`             -> `OffsetDateTime.of(2017, 3, 14, 12, 34, 56, 789_000_000, ZoneOffset.UTC)`
| `java.time.OffsetTime`     | `"12:34:56.789Z"`                        -> `OffsetTime.of(12, 34, 56, 789_000_000, ZoneOffset.UTC)`
| `java.time.YearMonth`      | `"2017-03"`                              -> `YearMonth.of(2017, 3)`
| `java.time.Year`           | `"2017"`                                 -> `Year.of(2017)`
| `java.time.ZonedDateTime`  | `"2017-03-14T12:34:56.789Z"`             -> `ZonedDateTime.of(2017, 3, 14, 12, 34, 56, 789_000_000, ZoneOffset.UTC)`
| `java.util.Currency`       | `"JPY"`                                  -> `Currency.getInstance("JPY")`
| `java.util.Locale`         | `"en"`                                   -> `new Locale("en")`
| `java.util.UUID`           | `"d043e930-7b3b-48e3-bdbe-5a3ccfb833db"` -> `UUID.fromString("d043e930-7b3b-48e3-bdbe-5a3ccfb833db")`
|===

[[writing-tests-parameterized-tests-argument-conversion-implicit-fallback]]
====== String → Object変換のフォールバック

上の表で示した文字列からターゲット型への暗黙的な変換に加えて、JUnit Jupiter
は `String` 型からターゲット型に自動変換するフォールバックの仕組みも提供しています。
この変換は、ターゲット型が以下に示す _ファクトリメソッド_ か _ファクトリコンストラクタ_
を1つだけ宣言している場合に機能します。

- __ファクトリメソッド__: ターゲット型に宣言された非privateの `static` メソッドで、
  `String` 型の引数を1つだけ受け取ってターゲット型のインスタンスを返す。
  メソッドの名前は任意であり、特定のルールに従う必要はない。
- __ファクトリコンストラクタ__: ターゲット型に宣言された非privateのコンストラクタで、
  `String` 型の引数を1つだけ受け取ってインスタンスを作る。

NOTE: 複数の _ファクトリメソッド_ が見つかった場合、それらは無視されます。
_ファクトリメソッド_ と _ファクトリコンストラクタ_ が両方見つかった場合は、
ファクトリメソッドの方が使われます。

例えば、次の `@ParameterizedTest` メソッドでは、`Book` 型の引数は
`Book.fromTitle(String)` ファクトリメソッドに本のタイトルとして `"42 Cats"`
を渡して実行することで作られます。

[source,java,indent=0]
----
include::{testDir}/example/ParameterizedTestDemo.java[tags=implicit_fallback_conversion_example]
----

[[writing-tests-parameterized-tests-argument-conversion-explicit]]
===== 明示的な変換

暗黙的な変換を使う代わりに、`@ConvertWith` アノテーションで
仮引数の変換に使う `ArgumentConverter` を明示的に指定することもできます。

[source,java,indent=0]
----
include::{testDir}/example/ParameterizedTestDemo.java[tags=explicit_conversion_example]
----

明示的な型変換器はテストまたは拡張機能の作者に実装されることを想定しています。
そのため、`junit-jupiter-params` モジュールは参照実装として `JavaTimeArgumentConverter`
の1つだけしか提供していません。これは、合成アノテーション `JavaTimeConversionPattern`
経由で使用できます。

[source,java,indent=0]
----
include::{testDir}/example/ParameterizedTestDemo.java[tags=explicit_java_time_converter]
----

[[writing-tests-parameterized-tests-argument-aggregation]]
==== パラメーターの集約

デフォルトでは、`@ParameterizedTest` のメソッドに与えられる各パラメーター
は、1つの仮引数に対応します。結果として、ソースが多数のパラメーターを生成する場合、
メソッドシグネチャが大きく（仮引数が多く）なります。

そのような場合には、複数の仮引数を定義する代わりに `{ArgumentsAccessor}`
を使うことができます。このAPIを使うと、テストメソッドに渡した単一の
`{ArgumentsAccessor}` 経由ですべてのパラメーターにアクセスすることができます。
加えて、
<<writing-tests-parameterized-tests-argument-conversion-implicit>>
で説明した型変換もサポートされます。

[source,java,indent=0]
----
include::{testDir}/example/ParameterizedTestDemo.java[tags=ArgumentsAccessor_example]
----

`ArgumentsAccessor` 型の仮引数には、自動的に `ArgumentsAccessor` のインスタンスが注入されます。

[[writing-tests-parameterized-tests-argument-aggregation-custom]]
===== カスタムアグリゲーター

`ArgumentsAccessor` を使って `@ParameterizedTest` メソッドのパラメーターに
直接アクセスする以外に、JUnit Jupiterはカスタムの再利用可能な
_アグリゲーター (aggregator)_ もサポートしています。

カスタムアグリゲーターを使うには、`{ArgumentsAggregator}` インターフェースを実装し、
`@ParameterizedTest` メソッドの仮引数に `@AggregateWith`
アノテーションを使って登録します。集約した結果は、
パラメーター化テストが実行されるときに
対象の仮引数に対する実引数として渡されます。

[source,java,indent=0]
----
include::{testDir}/example/ParameterizedTestDemo.java[tags=ArgumentsAggregator_example]
----

複数のパラメーター化テストメソッドに対して何回も `@AggregateWith(MyTypeAggregator.class)`
を宣言していることに気付いたら、`@AggregateWith(MyTypeAggregator.class)`
をメタアノテーションとして付与した `@CsvToMyType` のようなカスタム _合成アノテーション_
を作りたくなるでしょう。
次の例は、実際にカスタムの `@CsvToPerson` アノテーションを作る例を示しています。

[source,java,indent=0]
----
include::{testDir}/example/ParameterizedTestDemo.java[tags=ArgumentsAggregator_with_custom_annotation_example]
----


[[writing-tests-parameterized-tests-display-names]]
==== 表示名のカスタマイズ

デフォルトでは、パラメーター化テストの表示名には、呼び出しインデックスとすべてのパラメーターの
`String` 表現が含まれます。ただし、`@ParameterizedTest` アノテーションの `name`
属性を指定すれば、次の例のようにカスタマイズすることもできます。

[source,java,indent=0]
----
include::{testDir}/example/ParameterizedTestDemo.java[tags=custom_display_names]
----

上のメソッドを `ConsoleLauncher` で実行すると、以下のような出力となります。

....
Display name of container ✔
├─ 1 ==> first='foo', second=1 ✔
├─ 2 ==> first='bar', second=2 ✔
└─ 3 ==> first='baz, qux', second=3 ✔
....

次のプレースホルダーがサポートされています。

[cols="20,80"]
|===
| Placeholder       | Description

| `{index}`         | 現在の呼び出しインデックス（1始まり）
| `{arguments}`     | カンマ区切りの完全なパラメーターのリスト
| `{0}`, `{1}`, ... | 個々のパラメーター
|===


[[writing-tests-parameterized-tests-lifecycle-interop]]
==== ライフサイクルと相互運用性

パラメーター化テストの各呼び出しは、通常の `@Test` メソッドと同じライフサイクルをもちます。
例えば、`@BeforeEach` メソッドが各呼び出しの前に実行されます。
<<writing-tests-dynamic-tests>> と同様に、パラメーター化テストの各呼び出しは、
IDEのテストツリーの中に1つずつ表示されます。同じテストクラスの中で、
`@Test` メソッドと `@ParameterizedTest` メソッドを混在させるのも自由です。

`ParameterResolver` 拡張を `@ParameterizedTest` メソッドと使いたいかもしれません。
その場合は、パラメーターのソースから渡される引数を先に宣言する必要があります。
テストクラスは、パラメーター化テストだけでなく通常のテストを含んでいる可能性もあるので、
パラメーターをライフサイクルメソッド (例えば、`@BeforeEach`)
やテストコンストラクタに渡すことができません。

[source,java,indent=0]
----
include::{testDir}/example/ParameterizedTestDemo.java[tags=ParameterResolver_example]
----


[[writing-tests-test-templates]]
=== テストテンプレート

`{TestTemplate}` メソッドは、通常のテストケースではなく、テストケースのテンプレートです。
登録したプロバイダが返す実行コンテキストの数に応じて、複数回呼び出されるよう設計されています。
そのため、テストテンプレートは `{TestTemplateInvocationContextProvider}`
と一緒に使う必要があります。
テストテンプレートメソッドの各呼び出しは、ライフサイクルコールバックや拡張機能など、
通常の `@Test` メソッドの実行と同じように振る舞います。使用例については、
<<extensions-test-templates>> を参照してください。


[[writing-tests-dynamic-tests]]
=== 動的テスト

<<writing-tests-annotations>> で説明したJUnit Jupiterの標準の `@Test`
アノテーションは、JUnit 4の `@Test` アノテーションととてもよく似ています。
どちらもテストケースを実装するメソッドを示します。これらのテストケースは、
完全にコンパイル時に指定され、その振る舞いが実行時には変えられないという意味で、
静的なものです。 _前提条件 (Assumption) の機能は、動的な振る舞いの基本を
提供しますが、表現力は意図的に限定されています。_

JUnit Jupiterでは、これらの標準的なテストに加えて、完全に新しいプログラミング
モデルが導入されました。それは、_動的テスト_ です。動的テストは、
`@TestFactory` アノテーションを付与したファクトリメソッドによって、
実行時に生成されます。

`@Test` メソッドとは異なり、`@TestFactory` メソッド自身はテストケースではなく、
テストケースのファクトリとなります。ファクトリの出力が動的テストになります。
技術的に言うと、`@TestFactory` メソッドは、`DynamicNode` インスタンスの
`Stream`, `Collection`, `Iterable`, `Iterator`, 配列のいずれかを
返さなければなりません。`DynamicNode` のインスタンス化可能なサブクラスには、
`DynamicContainer` と `DynamicTest` があります。`DynamicContainer`
インスタンスは、_表示名_ と子どもの `DynamicNode` リストで構成され、
入れ子になった `DynamicNode` の階層を作成できるようになっています。
`DynamicTest` インスタンスが遅延実行されることで、動的かつ非決定的な
テストケースの生成を実現します。

`@TestFactory` が返した `Stream` は、`stream.close()` 呼び出しによって
適切にクローズされます。これにより、`Files.lines()` などのリソースを
安全に使うことができます。

`@Test` メソッドと同じように、`@TestFactory` メソッドも `private` または
`static` であってはいけません。また、`ParameterResolvers` で解決される
パラメーターを宣言することもできます。

`DynamicTest` は、実行時に生成されるテストケースで、_表示名_ と `Executable`
で構成されます。`Executable` は、`@FunctionalInterface` であり、
動的テストの実装が _ラムダ式_ または _メソッド参照_ で与えられることを意味します。

.動的テストのライフサイクル
WARNING: 動的テストの実行ライフサイクルは、通常の `@Test` とはかなり違います。
特に、個々の動的テストに対しては、ライフサイクルコールバックはありません。
これは、`@BeforeEach` や `@AfterEach` メソッドとその拡張コールバックが、
`@TestFactory` メソッドに対して実行され、個々の _動的テスト_
に対しては実行されないことを意味しています。言い換えれば、動的テストのラムダ式から
テストインスタンスのフィールドにアクセスしていたとしても、同じ `@TestFactory`
メソッドから生成された個々の動的テストを実行する間は、コールバックメソッドにも
拡張機能にもそのフィールドはリセットされないのです。


JUnit Jupiter {jupiter-version} の時点では、動的テストは常にファクトリメソッドで
生成しなければなりません。ただし、将来のリリースで、登録の仕組みが追加されるかもしれません。

WARNING: 動的テストは現在 _実験中_ の機能です。詳細は、
<<api-evolution-experimental-apis>> の表を参照してください。

[[writing-tests-dynamic-tests-examples]]
==== 動的テストの例

次の `DynamicTestsDemo` クラスは、テストファクトリと動的テストの例を示しています。

最初のメソッドは、不正な戻り値型を返しています。不正な戻り値型はコンパイル時には
検出できないため、実行時に検出されて `JUnitException` がスローされます。

その次の5つのメソッドは、`DynamicTest` インスタンスの `Collection`, `Iterable`,
`Iterator`, `Stream` を生成するとてもシンプルな例です。ほとんどの例は、
動的な振る舞いではなく、単にサポートされている戻り値の型をデモしています。
しかし、`dynamicTestsFromStream()` と `dynamicTestsFromIntStream()` は、
与えられた文字列リストや数値の範囲に対して簡単に動的なテストを生成できることを
示しています。

その次のメソッドは、真に動的な性質のものです。`generateRandomNumberOfTests()`
は、乱数を生成する `Iterator`、表示名の生成器、テストの実行器の3つを実装し、
これらを `DynamicTest.stream()` に渡しています。
`generateRandomNumberOfTests()` の非決定的な振る舞いは、
もちろんテストの再現性に反するため注意して使うべきですが、
動的テストの高い表現力とパワーを示すのに役立っています。

最後のメソッドは、`DynamicContainer` を使って動的テストを入れ子階層にする例を示しています。

[source,java]
----
include::{testDir}/example/DynamicTestsDemo.java[tags=user_guide]
----


[[writing-tests-parallel-execution]]
=== 並列実行

デフォルトでは、JUnit Jupiterのテストはシングルスレッドで逐次実行されます。バージョン
5.3からは、オプトインの機能として（例えば高速化のために）テストの並列実行を利用できます。
並列実行を有効にするには、単に `junit-platform.properties` ファイルで
設定パラメーター `junit.jupiter.execution.parallel.enabled` に `true`
を指定するだけです（その他の選択肢については、<<running-tests-config-params>> を参照）。

有効にすると、JUnit Jupiterエンジンは与えられた
<<writing-tests-parallel-execution-config, 設定>> と宣言的に指定された
<<writing-tests-parallel-execution-synchronization, 同期化>> に従って、
テストツリーのすべてのレベルのテストを並列実行します。なお、
<<running-tests-capturing-output>> 機能は別途有効にする必要がある点に注意してください。

WARNING: テストの並列実行は、今のところ _実験的な_ 機能です。JUnitチームがこの機能を改善し、
最終的には <<api-evolution, 昇格>> できるよう、試しに使ってみてフィードバックをください。

[[writing-tests-parallel-execution-config]]
==== 設定

希望する並列数やプールの最大サイズなどのプロパティは、
`{ParallelExecutionConfigurationStrategy}` を使って設定できます。
JUnit Platformは、すぐに使える2つの実装（`dynamic` と `fixed`）を提供しています。
なお、代わりに独自の `custom` 戦略を実装することもできます。

並列戦略を選択するには、設定パラメーター `junit.jupiter.execution.parallel.config.strategy`
に次のいずれかを指定します。

`dynamic`::
  利用可能なプロセッサ／コア数に、設定パラメーター
  `junit.jupiter.execution.parallel.config.dynamic.factor` の値
  （デフォルトは `1`）を掛けた数に基づいて並列数を計算します。

`fixed`::
  設定パラメーター `junit.jupiter.execution.parallel.config.fixed.parallelism`
  の値を並列数として使用します。

`custom`::
  設定パラメーター `junit.jupiter.execution.parallel.config.custom.class`
  で指定された独自の `{ParallelExecutionConfigurationStrategy}` 実装を使って、
  並列数を決定します。

もし並列戦略が指定されていなかった場合、JUnit Jupiterは `dynamic` 戦略を使います。
つまり、並列数は利用可能なプロセッサ／コア数の数と同じになります。

[[writing-tests-parallel-execution-synchronization]]
==== 同期化

JUnit Jupiterは、異なるテスト間で共有リソースを使うときの実行モデルを変更し、
同期化を可能にするためのアノテーションベースの仕組みを2つ
`org.junit.jupiter.api.parallel` パッケージで提供しています。

並列実行が有効な場合、デフォルトではすべてのクラスとメソッドが同時に実行されます。
`{Execution}` アノテーションを使うことで、アノテーションが付与された要素と
（もしあれば）サブ要素の実行モデルを変更することができます。
次の2つのモードが利用可能です。

`SAME_THREAD`::
  親と同じスレッドで実行することを強制します。例えば、テストメソッドに指定した場合、
  該当メソッドはテストクラスの `@BeforeAll` メソッドや `@AfterAll` メソッドを
  実行するスレッドと同じスレッドで実行されます。

`CONCURRENT`::
  リソース制約で同一スレッドでの実行が強制されない限り、別スレッドで並列実行されます。

加えて、`{ResourceLock}` アノテーションを使うと、テストクラスやテストメソッドが
同期化されたアクセスを必要とする共有リソースを使用していると宣言できます。

仮に次のサンプルのテストが並列実行されたとすると、結果は不安定 (flaky) 、
つまり成功したり失敗したりします。
というのも、同じシステムプロパティを読み書きする競合状態があるからです
（訳注： `@ResourceLock` による同期化がない仮定の話）。

[source,java]
----
include::{testDir}/example/SharedResourcesDemo.java[tags=user_guide]
----

共有リソースへのアクセスが `@ResourceLock` アノテーションで宣言されている場合、
JUnit Jupiterエンジンはこの情報を活用し、互いにコンフリクトするテストが同時に
実行されないよう保証します。

使用されるリソースを一意に特定する文字列に加えて、アクセスモードを指定することもできます。
同じリソースの `READ` アクセスを要求する2つのテストは同時に実行することができますが、
`READ_WRITE` アクセスを要求するテストが実行中の場合は実行できません。
