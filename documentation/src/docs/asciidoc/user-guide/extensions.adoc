[[extensions]]
== 拡張モデル

[[extensions-overview]]
=== 概要

JUnit 4の `Runner`, `@Rule`, `@ClassRule` などの拡張ポイントとは異なり、
JUnit Jupiterの拡張モデルは、単一の一貫したコンセプトである `Extension` API
で構成されます。ただし、`Extension` 自身はただのマーカーインターフェースである点に
注意してください。

[[extensions-registration]]
=== 拡張機能の登録

拡張機能は、 <<extensions-registration-declarative,`@ExtendWith`>>
を使って _宣言的に_ 登録するか、
<<extensions-registration-programmatic,`@RegisterExtension`>>
を使って _手続き的に_ 登録するか、あるいは
Javaの <<extensions-registration-automatic,`ServiceLoader`>>
の仕組みを使って _自動的に_ 登録することができます。

[[extensions-registration-declarative]]
==== 宣言的な登録

開発者は、テストインターフェースやテストクラス、テストメソッド、
_<<writing-tests-meta-annotations, 合成アノテーション>>_ に
`@ExtendWith(...)` アノテーションを付与し、
拡張機能として登録したいクラスの参照を指定することで
1つ以上の拡張機能を _宣言的に_ 登録することができます。

例えば、特定のテストメソッドに `RandomParametersExtension` を登録したい場合は、
テストメソッドに次のようにアノテーションを付与します。

[source,java,indent=0]
----
@ExtendWith(RandomParametersExtension.class)
@Test
void test(@Random int i) {
	// ...
}
----

特定のクラスとそのサブクラスのすべてのテストに `RandomParametersExtension`
を登録したい場合は、テストクラスに次のようにアノテーションを付与します。

[source,java,indent=0]
----
@ExtendWith(RandomParametersExtension.class)
class MyTests {
	// ...
}
----

複数の拡張機能は、次のように同時に登録することができます。

[source,java,indent=0]
----
@ExtendWith({ FooExtension.class, BarExtension.class })
class MyFirstTests {
	// ...
}
----

別の方法としては、次のように個別に登録することができます。

[source,java,indent=0]
----
@ExtendWith(FooExtension.class)
@ExtendWith(BarExtension.class)
class MySecondTests {
	// ...
}
----

.拡張機能の登録順序
NOTE: `@ExtendWith` で宣言的に登録された拡張機能は、ソースコード上での宣言順で実行されます。
例えば、`MyFirstTests` と `MySecondTests` のテスト実行は、`FooExtension` と
`BarExtension` によって **まさにこの順序で** 拡張されます。

[[extensions-registration-programmatic]]
==== 手続き的な登録

開発者は、テストクラスのフィールドに
`{RegisterExtension}` アノテーションを付与することで、
拡張機能を _手続き的に_ 登録することができます。

拡張機能を <<extensions-registration-declarative,`@ExtendWith`>> で
_宣言的に_ 登録する場合、拡張機能の設定はアノテーション経由でしか行なえません。
しかし、拡張機能を `@RegisterExtension` で登録する場合は、
拡張機能のコンストラクタやstaticファクトリメソッド、
ビルダーAPIに引数を渡して _手続き的に_ 設定することができます。

NOTE: `@RegisterExtension` フィールドは、`private` または `null` (評価時)
であってはなりませんが、`static` か非 `static` はどちらでもかまいません。

[[extensions-registration-programmatic-static-fields]]
===== staticフィールド

`@RegisterExtension` フィールドが `static` の場合、その拡張機能は
`@ExtendWith` でクラスレベルに登録される拡張機能の後で登録されます。
そのような _staticな拡張機能_ は、実装する拡張APIに制限がありません。
そのため、staticフィールドとして登録される拡張機能は、
`BeforeAllCallback`, `AfterAllCallback`, `TestInstancePostProcessor`
のようなクラスレベルやインスタンスレベルの拡張APIだけでなく、
`BeforeEachCallback` などのようなメソッドレベルの拡張APIも実装できます。

次の例では、テストクラスの `server` フィールドは `WebServerExtension`
がサポートするビルダーパターンを使って手続き的に初期化されます。設定された
`WebServerExtension` は、クラスレベルの拡張機能として自動的に登録され、
例えば、すべてのテストを開始する前にサーバーを起動したり、
すべてのテストが完了した後でサーバーを停止したりすることができます。
加えて、`@BeforeEach`, `@AfterEach`, `@Test` メソッドだけでなく、
`@BeforeAll` や `@AfterAll` のようなstaticなライフサイクルメソッドも
必要であれば `server` フィールド経由でこの拡張機能のインスタンスにアクセスできます。

[source,java,indent=0]
.staticフィールド経由で登録される拡張機能
----
include::{testDir}/example/registration/WebServerDemo.java[tags=user_guide]
----

[[extensions-registration-programmatic-instance-fields]]
===== インスタンスフィールド

`@RegisterExtension` フィールドが非static (つまり、インスタンスフィールド)
の場合、その拡張機能はテストクラスがインスタンス化され、登録済みの各
`TestInstancePostProcessor` がテストインスタンスの事後処理
(拡張機能のインスタンスをアノテーションの付与されたフィールドに注入するなど)
をした後で登録されます。そのため、_インスタンスフィールドの拡張機能_ が
`BeforeAllCallback`, `AfterAllCallback`, `TestInstancePostProcessor`
のようなクラスレベルやインスタンスレベルの拡張APIを実装しても意味がありません。
デフォルトでは、インスタンスフィールドの拡張機能は `@ExtendWith`
でメソッドレベルに登録される拡張機能より _後で_ 登録されます。しかし、
テストクラスが `@TestInstance(Lifecycle.PER_CLASS)` モードに設定されている場合は、
`@ExtendWith` でメソッドレベルに登録される拡張機能の _前に_ 登録されます。

次の例では、テストクラスの `docs` フィールドは `lookUpDocsDir()`
メソッドを呼び出した結果を `DocumentationExtension` のstaticファクトリメソッド
`forPath()` に渡すことで、手続き的に初期化されます。設定された
`DocumentationExtension` は、メソッドレベルの拡張機能として自動的に登録されます。
加えて、`@BeforeEach`, `@AfterEach`, `@Test` メソッドは
必要であれば `docs` フィールド経由でこの拡張機能のインスタンスにアクセスできます。

[source,java,indent=0]
.インスタンスフィールド経由で登録される拡張機能
----
include::{testDir}/example/registration/DocumentationDemo.java[tags=user_guide]
----

[[extensions-registration-automatic]]
==== 自動的な登録

アノテーションを使った拡張機能の
<<extensions-registration-declarative, 宣言的な登録>> と
<<extensions-registration-programmatic, 手続き的な登録>> に加えて、
JUnit JupiterはJavaの `java.util.ServiceLoader` の仕組みを使った拡張機能の
_グローバルな登録_ もサポートしています。
これにより、クラスパスから利用可能なサードパーティの拡張機能を自動検出し、
自動的に登録させることができます。

具体的には、JARファイルの `/META-INF/services` フォルダの中に
`org.junit.jupiter.api.extension.Extension` という名前のファイルを作成し、
クラスの完全修飾名を指定することで拡張機能を登録できます。

[[extensions-registration-automatic-enabling]]
===== 拡張機能の自動検出を有効にする

自動検出は高度な機能なので、デフォルトでは有効になっていません。有効化するには、
_設定パラメーター_ `junit.jupiter.extensions.autodetection.enabled`
に `true` を指定します。これは、JVMのシステムプロパティか、
`Launcher` に渡される `LauncherDiscoveryRequest` の _設定パラメーター_、
あるいはJUnit Platform 設定ファイルで指定することができます
(詳細は、<<running-tests-config-params>> を参照)。

例えば、拡張機能の自動検出を有効化するには、JVMを次のシステムプロパティ付きで起動します。

`-Djunit.jupiter.extensions.autodetection.enabled=true`

自動検出が有効化されると、`ServiceLoader` の仕組みで検知された拡張機能は、
JUnit Jupiterのグローバルな拡張機能 (例えば、`TestInfo` や `TestReporter`
のサポート) の後で拡張機能レジストリに登録されます。

[[extensions-registration-inheritance]]
==== 拡張機能の継承

登録された拡張機能は、テストクラス階層の中で親から子に継承されます。
同様に、クラスレベルで登録された拡張機能は、メソッドレベルに継承されます。
また、同一の拡張機能実装は、与えられた拡張コンテキストとその親の拡張コンテキストに対して
一回だけしか登録することができません。
結果として、重複して拡張機能実装を登録しようとしても無視されます。

[[extensions-conditions]]
=== 条件付きテスト実行

`{ExecutionCondition}` は、プログラムの _条件付きテスト実行_ のための `Extension` APIを定めています。

`ExecutionCondition` は、コンテナ (例えば、テストクラス) がもつテストを与えられた
`ExtensionContext` で実行すべきか判断するためにコンテナ毎に評価されます。
同様に、`ExecutionCondition` は、個々のテストメソッドを与えられた `ExtensionContext`
で実行すべきか判断するためにテスト毎に評価されます。

複数の `ExecutionCondition` 拡張が登録された場合、_無効_ と判定する拡張機能が1つでもあれば、
コンテナやテストはただちに無効化されます。別の拡張機能がすでにコンテナやテストを無効化していることがあるので、
ある拡張機能が必ず評価されるという保証はありません。言い換えると、論理OR演算子の短絡評価のように評価されます。

具体的な例は、`{DisabledCondition}` と `{Disabled}` のソースコードを参照してください。

[[extensions-conditions-deactivation]]
==== 条件を非アクティブにする

[TIP]
====
訳注：テストの条件 (`ExecutionCondition`) が成立し、該当テストが実行される状態を
_有効_、逆に実行されない状態を _無効_ と訳している。これに対して、
テストの条件自体が評価される状態であることを _アクティブ_、
評価されない状態であることを _非アクティブ_ と区別して訳す。
====

ときには、特定の条件をアクティブにせずにテストスイートを実行できると有用な場合があります。
例えば、`@Disabled` アノテーションが付与されているテストであっても、今もまだ _壊れた_
ままかを確認するために実行したいと思うことがあるかもしれません。そのためには、
_設定パラメーター_ `junit.jupiter.conditions.deactivate` を使って、
現在のテスト実行に対してどの条件を非アクティブ (つまり、評価されない) にするか
パターンを指定するだけです。パターンは、JVMのシステムプロパティか、 `Launcher` に渡される
`LauncherDiscoveryRequest` の _設定パラメーター_、あるいはJUnit Platform
設定ファイルで指定することができます (詳細は、<<running-tests-config-params>> を参照)。

例えば、JUnitの `@Disabled` 条件を非アクティブにするには、
JVMを次のシステムプロパティ付きで起動します。

`-Djunit.jupiter.conditions.deactivate=org.junit.*DisabledCondition`

[[extensions-conditions-deactivation-patterns]]
===== パターンマッチング構文

`junit.jupiter.conditions.deactivate` のパターンがアスタリスク (`+*+`)
のみからなる場合、すべての条件が非アクティブになります。一方、
登録された条件の完全修飾クラス名 (_FQCN_) に対するパターンマッチも使えます。
パターン中のドット (`.`) は、FQCN中のドット (`.`) またはドル記号 (`$`) にマッチします。
アスタリスク (`+*+`) は、FQCN中の1つ以上の文字にマッチします。
ほかのすべての文字は、FQCN中の文字に1対1でマッチします。

例:

- `+*+`: すべての条件を非アクティブにします。
- `+org.junit.*+`: `org.junit` パッケージおよびすべてのサブパッケージにある条件を非アクティブにします。
- `+*.MyCondition+`: 単純クラス名が `MyCondition` である条件をすべて非アクティブにします。
- `+*System*+`: 単純クラス名に `System` を含む条件をすべて非アクティブにします。
- `org.example.MyCondition`: FQCNが `org.example.MyCondition` である条件を非アクティブにします。

[[extensions-test-instance-post-processing]]
=== テストインスタンスの後処理

`{TestInstancePostProcessor}` は、テストインスタンスの _後処理_ をするための `Extension`
APIを定めています。

よくあるユースケースは、テストインスタンスへの依存性注入や、テストインスタンスのカスタムの
初期化メソッド呼び出しなどがあります。

具体例は、`{MockitoExtension}` や `{SpringExtension}` のソースコードを参照してください。

[[extensions-parameter-resolution]]
=== 引数の解決

`{ParameterResolver}` は、実行時に動的に引数を解決するための `Extension` APIを定めています。

テストコンストラクタや `@Test`, `@RepeatedTest`, `@ParameterizedTest`, `@TestFactory`,
`@BeforeEach`, `@AfterEach`, `@BeforeAll`, `@AfterAll` メソッドが引数をもつ場合、
その引数は `ParameterResolver` によって実行時に _解決_ されなければいけません。
`ParameterResolver` は、ビルトインのもの (`{TestInfoParameterResolver}` 参照) または
<<extensions-registration, ユーザーが登録したもの>> のどちらかです。一般的に言うと、
引数は _名前_、_型_、_アノテーション_、あるいはその組み合わせで解決されます。
具体例は、`{CustomTypeParameterResolver}` や `{CustomAnnotationParameterResolver}`
のソースコードを参照してください。

[WARNING]
====
JDK 9以前の `javac` が生成するバイトコードのバグのせいで、_内部クラス_ のコンストラクタ
(例えば、`@Nested` テストクラスのコンストラクタ) に対して引数のアノテーションを
`java.lang.reflect.Parameter` API経由で直接探そうとすると、常に失敗します。

そのため、`ParameterResolver` 実装に与えられる `{ParameterContext}` APIは、
引数のアノテーションを正しく検索するための以下の便利メソッドを含んでいます。
拡張機能の作者は、JDKのバグを回避するために `java.lang.reflect.Parameter` ではなく、
これらのメソッドを使用することが強く推奨されます。

* `boolean isAnnotated(Class<? extends Annotation> annotationType)`
* `Optional<A> findAnnotation(Class<A> annotationType)`
* `List<A> findRepeatableAnnotations(Class<A> annotationType)`
====

[[extensions-lifecycle-callbacks]]
=== テストライフサイクルコールバック

以下のインターフェースは、テスト実行のライフサイクルにおける様々なタイミングでテストを拡張するための
APIを定めています。詳細は、以降の節にあるサンプルと、`{extension-api-package}` パッケージにある
これらのインターフェースのJavadocを参照してください。

* `{BeforeAllCallback}`
** `{BeforeEachCallback}`
*** `{BeforeTestExecutionCallback}`
*** `{AfterTestExecutionCallback}`
** `{AfterEachCallback}`
* `{AfterAllCallback}`

.複数のExtension APIを実装する
NOTE: 拡張機能の開発者は、1つの拡張機能でこれらのインターフェースをいくつでも実装することができます。
具体例は、`{SpringExtension}` のソースコードを参照してください。

[[extensions-lifecycle-callbacks-before-after-execution]]
==== テスト実行前後のコールバック

`{BeforeTestExecutionCallback}` と `{AfterTestExecutionCallback}` は、
テストメソッドが実行される _直前_ と _直後_ に実行されるような振る舞いを追加したい場合の
`Extension` API を定めています。実行時間の計測や、処理のトレースなどのユースケースに適しています。
もしも `@BeforeEach` メソッドや `@AfterEach` メソッドの _前後_ に呼び出されるコールバックが
必要な場合は、代わりに `BeforeEachCallback` や `AfterEachCallback` を実装してください。

次の例は、テストメソッドの実行時間を計測してログ出力するために、
これらのコールバックを利用する方法を示しています。`TimingExtension` は、
`BeforeTestExecutionCallback` と `AfterTestExecutionCallback` の両方を実装しています。

[[extensions-lifecycle-callbacks-timing-extension]]
[source,java,indent=0]
.テストメソッドの実行時間を計測してログ出力する拡張機能
----
include::{testDir}/example/timing/TimingExtension.java[tags=user_guide]
----

`TimingExtensionTests` クラスは `@ExtendWith` を使って `TimingExtension`
を登録しているので、テストを実行すると時間計測が有効になります。

[source,java,indent=0]
.TimingExtensionを使うテストクラス
----
include::{testDir}/example/timing/TimingExtensionTests.java[tags=user_guide]
----

以下は、`TimingExtensionTests` が実行されたときに出力されるログの例です。

....
INFO: Method [sleep20ms] took 24 ms.
INFO: Method [sleep50ms] took 53 ms.
....

[[extensions-exception-handling]]
=== 例外ハンドリング

`{TestExecutionExceptionHandler}` は、テスト実行中に投げられた例外を扱うための
`Extension` API を定めています。

次の例は、`IOException` のすべてのインスタンスをもみ消し、
それ以外の例外は再スローするような拡張機能を示しています。

[source,java,indent=0]
.例外をハンドリングする拡張機能
----
include::{testDir}/example/exception/IgnoreIOExceptionExtension.java[tags=user_guide]
----

[[extensions-test-templates]]
=== Providing Invocation Contexts for Test Templates

A `{TestTemplate}` method can only be executed when at least one
`{TestTemplateInvocationContextProvider}` is registered. Each such provider is responsible
for providing a `Stream` of `{TestTemplateInvocationContext}` instances. Each context may
specify a custom display name and a list of additional extensions that will only be used
for the next invocation of the `{TestTemplate}` method.

The following example shows how to write a test template as well as how to register and
implement a `{TestTemplateInvocationContextProvider}`.

[source,java,indent=0]
.A test template with accompanying extension
----
include::{testDir}/example/TestTemplateDemo.java[tags=user_guide]
----

In this example, the test template will be invoked twice. The display names of the
invocations will be "`foo`" and "`bar`" as specified by the invocation context. Each
invocation registers a custom `{ParameterResolver}` which is used to resolve the method
parameter. The output when using the `ConsoleLauncher` is as follows.

....
└─ testTemplate(String) ✔
   ├─ foo ✔
   └─ bar ✔
....

The `{TestTemplateInvocationContextProvider}` extension API is primarily intended for
implementing different kinds of tests that rely on repetitive invocation of a test-like
method albeit in different contexts — for example, with different parameters, by preparing
the test class instance differently, or multiple times without modifying the context.
Please refer to the implementations of <<writing-tests-repeated-tests>> or
<<writing-tests-parameterized-tests>> which use this extension point to provide their
functionality.


[[extensions-keeping-state]]
=== Keeping State in Extensions

Usually, an extension is instantiated only once. So the question becomes relevant: How do
you keep the state from one invocation of an extension to the next? The
`ExtensionContext` API provides a `Store` exactly for this purpose. Extensions may put
values into a store for later retrieval. See the
`<<extensions-lifecycle-callbacks-timing-extension, TimingExtension>>` for an example of
using the `Store` with a method-level scope. It is important to remember that values
stored in an `ExtensionContext` during test execution will not be available in the
surrounding `ExtensionContext`. Since `ExtensionContexts` may be nested, the scope of
inner contexts may also be limited. Consult the corresponding JavaDoc for details on the
methods available for storing and retrieving values via the `{ExtensionContext_Store}`.

.`ExtensionContext.Store.CloseableResource`
NOTE: An extension context store is bound to its extension context lifecycle. When an
extension context lifecycle ends it closes its associated store. All stored values
that are instances of `CloseableResource` are notified by
an invocation of their `close()` method.

[[extensions-supported-utilities]]
=== Supported Utilities in Extensions

The `junit-platform-commons` artifact exposes a package named
`{junit-platform-support-package}` that contains _maintained_ utility methods for working
with annotations, classes, reflection, and classpath scanning tasks. `TestEngine` and
`Extension` authors are encouraged to use these supported methods in order to align with
the behavior of the JUnit Platform.

[[extensions-supported-utilities-annotations]]
==== Annotation Support

`AnnotationSupport` provides static utility methods that operate on annotated elements
(e.g., packages, annotations, classes, interfaces, constructors, methods, and fields).
These include methods to check whether an element is annotated or meta-annotated with a
particular annotation, to search for specific annotations, and to find annotated methods
and fields in a class or interface. Some of these methods search on implemented
interfaces and within class hierarchies to find annotations. Consult the JavaDoc for
`{AnnotationSupport}` for further details.

[[extensions-supported-utilities-classes]]
==== Class Support

`ClassSupport` provides static utility methods for working with classes (i.e., instances
of `java.lang.Class`). Consult the JavaDoc for `{ClassSupport}` for further details.

[[extensions-supported-utilities-reflection]]
==== Reflection Support

`ReflectionSupport` provides static utility methods that augment the standard JDK
reflection and class-loading mechanisms. These include methods to scan the classpath in
search of classes matching specified predicates, to load and create new instances of a
class, and to find and invoke methods. Some of these methods traverse class hierarchies
to locate matching methods. Consult the JavaDoc for `{ReflectionSupport}` for further
details.

[[extensions-execution-order]]
=== Relative Execution Order of User Code and Extensions

When executing a test class that contains one or more test methods, a number of extension
callbacks are called in addition to the user-provided test and lifecycle methods. The
following diagram illustrates the relative order of user-provided code and extension code.

:figure-caption: User code and extension code

[#extensions-execution-order-diagram,reftext='{figure-caption}']
image::extensions_lifecycle.png[caption='',title='{figure-caption}']

User-provided test and lifecycle methods are shown in orange, with callback code provided
by extensions shown in blue. The grey box denotes the execution of a single test method
and will be repeated for every test method in the test class.

The following table further explains the twelve steps in the
<<extensions-execution-order-diagram>> diagram.

[cols="5,15,80"]
|===
| Step | Interface/Annotation | Description

| 1
| interface `org.junit.jupiter.api.extension.BeforeAllCallback`
| extension code executed before all tests of the container are executed

| 2
| annotation `org.junit.jupiter.api.BeforeAll`
| user code executed before all tests of the container are executed

| 3
| interface `org.junit.jupiter.api.extension.BeforeEachCallback`
| extension code executed before each test is executed

| 4
| annotation `org.junit.jupiter.api.BeforeEach`
| user code executed before each test is executed

| 5
| interface `org.junit.jupiter.api.extension.BeforeTestExecutionCallback`
| extension code executed immediately before a test is executed

| 6
| annotation `org.junit.jupiter.api.Test`
| user code of the actual test method

| 7
| interface `org.junit.jupiter.api.extension.TestExecutionExceptionHandler`
| extension code for handling exceptions thrown during a test

| 8
| interface `org.junit.jupiter.api.extension.AfterTestExecutionCallback`
| extension code executed immediately after test execution and its corresponding exception handlers

| 9
| annotation `org.junit.jupiter.api.AfterEach`
| user code executed after each test is executed

| 10
| interface `org.junit.jupiter.api.extension.AfterEachCallback`
| extension code executed after each test is executed

| 11
| annotation `org.junit.jupiter.api.AfterAll`
| user code executed after all tests of the container are executed

| 12
| interface `org.junit.jupiter.api.extension.AfterAllCallback`
| extension code executed after all tests of the container are executed

|===

In the simplest case only the actual test method will be executed (step 6); all other
steps are optional depending on the presence of user code or extension support for the
corresponding lifecycle callback. For further details on the various lifecycle callbacks
please consult the respective JavaDoc for each annotation and extension.
