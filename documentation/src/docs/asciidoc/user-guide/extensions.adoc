[[extensions]]
== 拡張モデル

[[extensions-overview]]
=== 概要

JUnit 4の `Runner`, `@Rule`, `@ClassRule` などの拡張ポイントとは異なり、
JUnit Jupiterの拡張モデルは、単一の一貫したコンセプトである `Extension` API
で構成されます。ただし、`Extension` 自身はただのマーカーインタフェースである点に
注意してください。

[[extensions-registration]]
=== 拡張機能の登録

拡張機能は、 <<extensions-registration-declarative,`@ExtendWith`>>
を使って _宣言的に_ 登録するか、
<<extensions-registration-programmatic,`@RegisterExtension`>>
を使って _手続き的に_ 登録するか、あるいは
Javaの <<extensions-registration-automatic,`ServiceLoader`>>
の仕組みを使って _自動的に_ 登録することができます。

[[extensions-registration-declarative]]
==== 宣言的な登録

開発者は、テストインターフェースやテストクラス、テストメソッド、
_<<writing-tests-meta-annotations, 合成アノテーション>>_ に
`@ExtendWith(...)` アノテーションを付与し、
拡張機能として登録したいクラスの参照を指定することで
1つ以上の拡張機能を _宣言的に_ 登録することができます。

例えば、特定のテストメソッドに `RandomParametersExtension` を登録したい場合は、
テストメソッドに次のようにアノテーションを付与します。

[source,java,indent=0]
----
@ExtendWith(RandomParametersExtension.class)
@Test
void test(@Random int i) {
	// ...
}
----

特定のクラスとそのサブクラスのすべてのテストに `RandomParametersExtension`
を登録したい場合は、テストクラスに次のようにアノテーションを付与します。

[source,java,indent=0]
----
@ExtendWith(RandomParametersExtension.class)
class MyTests {
	// ...
}
----

複数の拡張機能は、次のように同時に登録することができます。

[source,java,indent=0]
----
@ExtendWith({ FooExtension.class, BarExtension.class })
class MyFirstTests {
	// ...
}
----

別の方法としては、次のように個別に登録することができます。

[source,java,indent=0]
----
@ExtendWith(FooExtension.class)
@ExtendWith(BarExtension.class)
class MySecondTests {
	// ...
}
----

.拡張機能の登録順序
NOTE: `@ExtendWith` で宣言的に登録された拡張機能は、ソースコード上での宣言順で実行されます。
例えば、`MyFirstTests` と `MySecondTests` のテスト実行は、`FooExtension` と
`BarExtension` によって **まさにこの順序で** 拡張されます。

[[extensions-registration-programmatic]]
==== 手続き的な登録

開発者は、テストクラスのフィールドに
`{RegisterExtension}` アノテーションを付与することで、
拡張機能を _手続き的に_ 登録することができます。

拡張機能を <<extensions-registration-declarative,`@ExtendWith`>> で
_宣言的に_ 登録する場合、拡張機能の設定はアノテーション経由でしか行なえません。
しかし、拡張機能を `@RegisterExtension` で登録する場合は、
拡張機能のコンストラクタやstaticファクトリメソッド、
ビルダーAPIに引数を渡して _手続き的に_ 設定することができます。

NOTE: `@RegisterExtension` フィールドは、`private` または `null` (評価時)
であってはなりませんが、`static` か非 `static` はどちらでもかまいません。

[[extensions-registration-programmatic-static-fields]]
===== staticフィールド

`@RegisterExtension` フィールドが `static` の場合、その拡張機能は
`@ExtendWith` でクラスレベルに登録される拡張機能の後で登録されます。
そのような _staticな拡張機能_ は、実装する拡張APIに制限がありません。
そのため、staticフィールドとして登録される拡張機能は、
`BeforeAllCallback`, `AfterAllCallback`, `TestInstancePostProcessor`
のようなクラスレベルやインスタンスレベルの拡張APIだけでなく、
`BeforeEachCallback` などのようなメソッドレベルの拡張APIも実装できます。

次の例では、テストクラスの `server` フィールドは `WebServerExtension`
がサポートするビルダーパターンを使って手続き的に初期化されます。設定された
`WebServerExtension` は、クラスレベルの拡張機能として自動的に登録され、
例えば、すべてのテストを開始する前にサーバーを起動したり、
すべてのテストが完了した後でサーバーを停止したりすることができます。
加えて、`@BeforeEach`, `@AfterEach`, `@Test` メソッドだけでなく、
`@BeforeAll` や `@AfterAll` のようなstaticなライフサイクルメソッドも
必要であれば `server` フィールド経由でこの拡張機能のインスタンスにアクセスできます。

[source,java,indent=0]
.staticフィールド経由で登録される拡張機能
----
include::{testDir}/example/registration/WebServerDemo.java[tags=user_guide]
----

[[extensions-registration-programmatic-instance-fields]]
===== インスタンスフィールド

`@RegisterExtension` フィールドが非static (つまり、インスタンスフィールド)
の場合、その拡張機能はテストクラスがインスタンス化され、登録済みの各
`TestInstancePostProcessor` がテストインスタンスの事後処理
(拡張機能のインスタンスをアノテーションの付与されたフィールドに注入するなど)
をした後で登録されます。そのため、_インスタンスフィールドの拡張機能_ が
`BeforeAllCallback`, `AfterAllCallback`, `TestInstancePostProcessor`
のようなクラスレベルやインスタンスレベルの拡張APIを実装しても意味がありません。
デフォルトでは、インスタンスフィールドの拡張機能は `@ExtendWith`
でメソッドレベルに登録される拡張機能より _後で_ 登録されます。しかし、
テストクラスが `@TestInstance(Lifecycle.PER_CLASS)` モードに設定されている場合は、
`@ExtendWith` でメソッドレベルに登録される拡張機能の _前に_ 登録されます。

次の例では、テストクラスの `docs` フィールドは `lookUpDocsDir()`
メソッドを呼び出した結果を `DocumentationExtension` のstaticファクトリメソッド
`forPath()` に渡すことで、手続き的に初期化されます。設定された
`DocumentationExtension` は、メソッドレベルの拡張機能として自動的に登録されます。
加えて、`@BeforeEach`, `@AfterEach`, `@Test` メソッドは
必要であれば `docs` フィールド経由でこの拡張機能のインスタンスにアクセスできます。

[source,java,indent=0]
.インスタンスフィールド経由で登録される拡張機能
----
include::{testDir}/example/registration/DocumentationDemo.java[tags=user_guide]
----

[[extensions-registration-automatic]]
==== 自動的な登録

アノテーションを使った拡張機能の
<<extensions-registration-declarative, 宣言的な登録>> と
<<extensions-registration-programmatic, 手続き的な登録>> に加えて、
JUnit JupiterはJavaの `java.util.ServiceLoader` の仕組みを使った拡張機能の
_グローバルな登録_ もサポートしています。
これにより、クラスパスから利用可能なサードパーティの拡張機能を自動検出し、
自動的に登録させることができます。

具体的には、JARファイルの `/META-INF/services` フォルダの中に
`org.junit.jupiter.api.extension.Extension` という名前のファイルを作成し、
クラスの完全修飾名を指定することで拡張機能を登録できます。

[[extensions-registration-automatic-enabling]]
===== 拡張機能の自動検出を有効にする

自動検出は高度な機能なので、デフォルトでは有効になっていません。有効化するには、
_設定パラメーター_ `junit.jupiter.extensions.autodetection.enabled`
に `true` を指定します。これは、JVMのシステムプロパティか、
`Launcher` に渡される `LauncherDiscoveryRequest` の _設定パラメーター_、
あるいはJUnit Platform 設定ファイルで指定することができます
(詳細は、<<running-tests-config-params>> を参照)。

例えば、拡張機能の自動検出を有効化するには、JVMを次のシステムプロパティ付きで起動します。

`-Djunit.jupiter.extensions.autodetection.enabled=true`

自動検出が有効化されると、`ServiceLoader` の仕組みで検知された拡張機能は、
JUnit Jupiterのグローバルな拡張機能 (例えば、`TestInfo` や `TestReporter`
のサポート) の後で拡張機能レジストリに登録されます。

[[extensions-registration-inheritance]]
==== 拡張機能の継承

登録された拡張機能は、テストクラス階層の中で親から子に継承されます。
同様に、クラスレベルで登録された拡張機能は、メソッドレベルに継承されます。
Furthermore, a specific extension implementation can only be registered
once for a given extension context and its parent contexts.
register a duplicate extension implementation will be ignored.

[[extensions-conditions]]
=== Conditional Test Execution

`{ExecutionCondition}` defines the `Extension` API for programmatic, _conditional test
execution_.

An `ExecutionCondition` is _evaluated_ for each container (e.g., a test class) to
determine if all the tests it contains should be executed based on the supplied
`ExtensionContext`. Similarly, an `ExecutionCondition` is _evaluated_ for each test to
determine if a given test method should be executed based on the supplied
`ExtensionContext`.

When multiple `ExecutionCondition` extensions are registered, a container or test is
disabled as soon as one of the conditions returns _disabled_. Thus, there is no guarantee
that a condition is evaluated because another extension might have already caused a
container or test to be disabled. In other words, the evaluation works like the
short-circuiting boolean OR operator.

See the source code of `{DisabledCondition}` and `{Disabled}` for concrete examples.

[[extensions-conditions-deactivation]]
==== Deactivating Conditions

Sometimes it can be useful to run a test suite _without_ certain conditions being active.
For example, you may wish to run tests even if they are annotated with `@Disabled` in
order to see if they are still _broken_. To do this, simply provide a pattern for the
`junit.jupiter.conditions.deactivate` _configuration parameter_ to specify which
conditions should be deactivated (i.e., not evaluated) for the current test run. The
pattern can be supplied as a JVM system property, as a _configuration parameter_ in the
`LauncherDiscoveryRequest` that is passed to the `Launcher`, or via the JUnit Platform
configuration file (see <<running-tests-config-params>> for details).

For example, to deactivate JUnit's `@Disabled` condition, you can start your JVM with the
following system property.

`-Djunit.jupiter.conditions.deactivate=org.junit.*DisabledCondition`

[[extensions-conditions-deactivation-patterns]]
===== Pattern Matching Syntax

If the `junit.jupiter.conditions.deactivate` pattern consists solely of an asterisk
(`+*+`), all conditions will be deactivated. Otherwise, the pattern will be used to match
against the fully qualified class name (_FQCN_) of each registered condition. Any dot
(`.`) in the pattern will match against a dot (`.`) or a dollar sign (`$`) in the FQCN.
Any asterisk (`+*+`) will match against one or more characters in the FQCN. All other
characters in the pattern will be matched one-to-one against the FQCN.

Examples:

- `+*+`: deactivates all conditions.
- `+org.junit.*+`: deactivates every condition under the `org.junit` base package and any
  of its subpackages.
- `+*.MyCondition+`: deactivates every condition whose simple class name is exactly
  `MyCondition`.
- `+*System*+`: deactivates every condition whose simple class name contains `System`.
- `org.example.MyCondition`: deactivates the condition whose FQCN is exactly
  `org.example.MyCondition`.

[[extensions-test-instance-post-processing]]
=== Test Instance Post-processing

`{TestInstancePostProcessor}` defines the API for `Extensions` that wish to _post
process_ test instances.

Common use cases include injecting dependencies into the test instance, invoking custom
initialization methods on the test instance, etc.

For a concrete example, consult the source code for the `{MockitoExtension}` and the
`{SpringExtension}`.

[[extensions-parameter-resolution]]
=== Parameter Resolution

`{ParameterResolver}` defines the `Extension` API for dynamically resolving parameters at
runtime.

If a test constructor or a `@Test`, `@RepeatedTest`, `@ParameterizedTest`,
`@TestFactory`, `@BeforeEach`, `@AfterEach`, `@BeforeAll`, or `@AfterAll` method accepts
a parameter, the parameter must be _resolved_ at runtime by a `ParameterResolver`. A
`ParameterResolver` can either be built-in (see `{TestInfoParameterResolver}`) or
<<extensions-registration,registered by the user>>. Generally speaking, parameters may be
resolved by _name_, _type_, _annotation_, or any combination thereof. For concrete
examples, consult the source code for `{CustomTypeParameterResolver}` and
`{CustomAnnotationParameterResolver}`.

[WARNING]
====
Due to a bug in the byte code generated by `javac` on JDK versions prior to JDK 9,
looking up annotations on parameters directly via the core `java.lang.reflect.Parameter`
API will always fail for _inner class_ constructors (e.g., a constructor in a `@Nested`
test class).

The `{ParameterContext}` API supplied to `ParameterResolver` implementations therefore
includes the following convenience methods for correctly looking up annotations on
parameters. Extension authors are strongly encouraged to use these methods instead of
those provided in `java.lang.reflect.Parameter` in order to avoid this bug in the JDK.

* `boolean isAnnotated(Class<? extends Annotation> annotationType)`
* `Optional<A> findAnnotation(Class<A> annotationType)`
* `List<A> findRepeatableAnnotations(Class<A> annotationType)`
====

[[extensions-lifecycle-callbacks]]
=== Test Lifecycle Callbacks

The following interfaces define the APIs for extending tests at various points in the
test execution lifecycle. Consult the following sections for examples and the Javadoc for
each of these interfaces in the `{extension-api-package}` package for further details.

* `{BeforeAllCallback}`
** `{BeforeEachCallback}`
*** `{BeforeTestExecutionCallback}`
*** `{AfterTestExecutionCallback}`
** `{AfterEachCallback}`
* `{AfterAllCallback}`

.Implementing Multiple Extension APIs
NOTE: Extension developers may choose to implement any number of these interfaces
within a single extension. Consult the source code of the `{SpringExtension}` for a
concrete example.

[[extensions-lifecycle-callbacks-before-after-execution]]
==== Before and After Test Execution Callbacks

`{BeforeTestExecutionCallback}` and `{AfterTestExecutionCallback}` define the APIs for
`Extensions` that wish to add behavior that will be executed _immediately before_ and
_immediately after_ a test method is executed, respectively. As such, these callbacks are
well suited for timing, tracing, and similar use cases. If you need to implement
callbacks that are invoked _around_ `@BeforeEach` and `@AfterEach` methods, implement
`BeforeEachCallback` and `AfterEachCallback` instead.

The following example shows how to use these callbacks to calculate and log the execution
time of a test method. `TimingExtension` implements both `BeforeTestExecutionCallback`
and `AfterTestExecutionCallback` in order to time and log the test execution.

[[extensions-lifecycle-callbacks-timing-extension]]
[source,java,indent=0]
.An extension that times and logs the execution of test methods
----
include::{testDir}/example/timing/TimingExtension.java[tags=user_guide]
----

Since the `TimingExtensionTests` class registers the `TimingExtension` via `@ExtendWith`,
its tests will have this timing applied when they execute.

[source,java,indent=0]
.A test class that uses the example TimingExtension
----
include::{testDir}/example/timing/TimingExtensionTests.java[tags=user_guide]
----

The following is an example of the logging produced when `TimingExtensionTests` is run.

....
INFO: Method [sleep20ms] took 24 ms.
INFO: Method [sleep50ms] took 53 ms.
....

[[extensions-exception-handling]]
=== Exception Handling

`{TestExecutionExceptionHandler}` defines the API for `Extensions` that wish to handle
exceptions thrown during test execution.

The following example shows an extension which will swallow all instances of `IOException`
but rethrow any other type of exception.

[source,java,indent=0]
.An exception handling extension
----
include::{testDir}/example/exception/IgnoreIOExceptionExtension.java[tags=user_guide]
----

[[extensions-test-templates]]
=== Providing Invocation Contexts for Test Templates

A `{TestTemplate}` method can only be executed when at least one
`{TestTemplateInvocationContextProvider}` is registered. Each such provider is responsible
for providing a `Stream` of `{TestTemplateInvocationContext}` instances. Each context may
specify a custom display name and a list of additional extensions that will only be used
for the next invocation of the `{TestTemplate}` method.

The following example shows how to write a test template as well as how to register and
implement a `{TestTemplateInvocationContextProvider}`.

[source,java,indent=0]
.A test template with accompanying extension
----
include::{testDir}/example/TestTemplateDemo.java[tags=user_guide]
----

In this example, the test template will be invoked twice. The display names of the
invocations will be "`foo`" and "`bar`" as specified by the invocation context. Each
invocation registers a custom `{ParameterResolver}` which is used to resolve the method
parameter. The output when using the `ConsoleLauncher` is as follows.

....
└─ testTemplate(String) ✔
   ├─ foo ✔
   └─ bar ✔
....

The `{TestTemplateInvocationContextProvider}` extension API is primarily intended for
implementing different kinds of tests that rely on repetitive invocation of a test-like
method albeit in different contexts — for example, with different parameters, by preparing
the test class instance differently, or multiple times without modifying the context.
Please refer to the implementations of <<writing-tests-repeated-tests>> or
<<writing-tests-parameterized-tests>> which use this extension point to provide their
functionality.


[[extensions-keeping-state]]
=== Keeping State in Extensions

Usually, an extension is instantiated only once. So the question becomes relevant: How do
you keep the state from one invocation of an extension to the next? The
`ExtensionContext` API provides a `Store` exactly for this purpose. Extensions may put
values into a store for later retrieval. See the
`<<extensions-lifecycle-callbacks-timing-extension, TimingExtension>>` for an example of
using the `Store` with a method-level scope. It is important to remember that values
stored in an `ExtensionContext` during test execution will not be available in the
surrounding `ExtensionContext`. Since `ExtensionContexts` may be nested, the scope of
inner contexts may also be limited. Consult the corresponding JavaDoc for details on the
methods available for storing and retrieving values via the `{ExtensionContext_Store}`.

.`ExtensionContext.Store.CloseableResource`
NOTE: An extension context store is bound to its extension context lifecycle. When an
extension context lifecycle ends it closes its associated store. All stored values
that are instances of `CloseableResource` are notified by
an invocation of their `close()` method.

[[extensions-supported-utilities]]
=== Supported Utilities in Extensions

The `junit-platform-commons` artifact exposes a package named
`{junit-platform-support-package}` that contains _maintained_ utility methods for working
with annotations, classes, reflection, and classpath scanning tasks. `TestEngine` and
`Extension` authors are encouraged to use these supported methods in order to align with
the behavior of the JUnit Platform.

[[extensions-supported-utilities-annotations]]
==== Annotation Support

`AnnotationSupport` provides static utility methods that operate on annotated elements
(e.g., packages, annotations, classes, interfaces, constructors, methods, and fields).
These include methods to check whether an element is annotated or meta-annotated with a
particular annotation, to search for specific annotations, and to find annotated methods
and fields in a class or interface. Some of these methods search on implemented
interfaces and within class hierarchies to find annotations. Consult the JavaDoc for
`{AnnotationSupport}` for further details.

[[extensions-supported-utilities-classes]]
==== Class Support

`ClassSupport` provides static utility methods for working with classes (i.e., instances
of `java.lang.Class`). Consult the JavaDoc for `{ClassSupport}` for further details.

[[extensions-supported-utilities-reflection]]
==== Reflection Support

`ReflectionSupport` provides static utility methods that augment the standard JDK
reflection and class-loading mechanisms. These include methods to scan the classpath in
search of classes matching specified predicates, to load and create new instances of a
class, and to find and invoke methods. Some of these methods traverse class hierarchies
to locate matching methods. Consult the JavaDoc for `{ReflectionSupport}` for further
details.

[[extensions-execution-order]]
=== Relative Execution Order of User Code and Extensions

When executing a test class that contains one or more test methods, a number of extension
callbacks are called in addition to the user-provided test and lifecycle methods. The
following diagram illustrates the relative order of user-provided code and extension code.

:figure-caption: User code and extension code

[#extensions-execution-order-diagram,reftext='{figure-caption}']
image::extensions_lifecycle.png[caption='',title='{figure-caption}']

User-provided test and lifecycle methods are shown in orange, with callback code provided
by extensions shown in blue. The grey box denotes the execution of a single test method
and will be repeated for every test method in the test class.

The following table further explains the twelve steps in the
<<extensions-execution-order-diagram>> diagram.

[cols="5,15,80"]
|===
| Step | Interface/Annotation | Description

| 1
| interface `org.junit.jupiter.api.extension.BeforeAllCallback`
| extension code executed before all tests of the container are executed

| 2
| annotation `org.junit.jupiter.api.BeforeAll`
| user code executed before all tests of the container are executed

| 3
| interface `org.junit.jupiter.api.extension.BeforeEachCallback`
| extension code executed before each test is executed

| 4
| annotation `org.junit.jupiter.api.BeforeEach`
| user code executed before each test is executed

| 5
| interface `org.junit.jupiter.api.extension.BeforeTestExecutionCallback`
| extension code executed immediately before a test is executed

| 6
| annotation `org.junit.jupiter.api.Test`
| user code of the actual test method

| 7
| interface `org.junit.jupiter.api.extension.TestExecutionExceptionHandler`
| extension code for handling exceptions thrown during a test

| 8
| interface `org.junit.jupiter.api.extension.AfterTestExecutionCallback`
| extension code executed immediately after test execution and its corresponding exception handlers

| 9
| annotation `org.junit.jupiter.api.AfterEach`
| user code executed after each test is executed

| 10
| interface `org.junit.jupiter.api.extension.AfterEachCallback`
| extension code executed after each test is executed

| 11
| annotation `org.junit.jupiter.api.AfterAll`
| user code executed after all tests of the container are executed

| 12
| interface `org.junit.jupiter.api.extension.AfterAllCallback`
| extension code executed after all tests of the container are executed

|===

In the simplest case only the actual test method will be executed (step 6); all other
steps are optional depending on the presence of user code or extension support for the
corresponding lifecycle callback. For further details on the various lifecycle callbacks
please consult the respective JavaDoc for each annotation and extension.
